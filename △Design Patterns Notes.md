# 设计模式
设计模式是在特定环境下，人们解决某类重复出现问题的一套成功或有效的解决办法

GoF（Gang of Four）是设计模式的创始者，4个人

设计模式简单地说就是“在一定环境下，用固定套路解决问题”
# 软件建模
## 模型与建模
### 模型
对现实的人和物进行简单的抽象
### 建模
对现实系统进行适当的过滤，用适当的表现规则描述简洁的模型
建模是一种深入解决问题的方法
### 建模的原则
- 选择建立什么样的模型对如何发现和解决问题具有重要的影响，正确的模型有助于提高开发者的洞察力
- 每个模型可以有多种表达方式，使用者的身份和使用的原因是评判模型好坏的关键
- 最好的模型总能切合实际，模型是现实的简化，必须保证简化过程不会掩盖任何重要细节
- 孤立的模型是不完整的
### 软件建模的作用
把来源于现实世界的问题转化为计算机可以理解和实现的问题
现实世界->计算机世界
### 软件建模的实现过程
从需求入手，用模型表达分析设计过程，最终将模型映射成软件实现
需求->模型->编码


# 统一建模语言/UML
统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言

有10种图
## 静态模型图
描述系统的静态结构
### 类图（Class Diagram）
- 类图是面向对象系统建模中最常用的图，是定义其他图的基础
- 类图主要用来显示系统中的类、接口，以及它们之间的关系
- 类图包含的主要元素有类、接口和关系，其中关系有泛化关系、关联关系、依赖关系和实现关系，在类图中也可以包含注释和约束
#### 类
类是类图的主要组件，由三部分组成：类名、属性和方法。在UML中，类用矩形来表示，顶端部分存放类的名称，中间部分存放类的属性、属性的类型及值，底部部分存放类的方法、方法的参数和返回类型

在UML中，可以根据实际情况有选择地隐藏属性部分或方法部分或两者都隐藏

在UML中，共有类型用+表示，私有类型用-表示，保护类型用#表示，UML的工具开发商可以使用自己定义的符号来表示不同的可见性
#### 接口
接口中包含方法，但不包含属性。在UML中接口用一个带有名称的圆圈表示，并通过一条实线与它的模型元素相连
有时候接口也使用普通类的矩形符号表示
#### 关系

| 符号     | 关系               | 英文         |
|----------|--------------------|-------------------|
| --------> | 关联               | Association       |
| --------▷ | 继承               | Inheritance       |
| - - - -▷ | 实现               | Realization/Implementation |
| - - - - -> | 依赖               | Dependency        |
| --------<> | 聚合               | Aggregation       |
| --------◀▶ | 组合               | Composition       |



##### 关联关系---------> 
- 对于两个相对独立的系统，当一个系统的实例与另一个系统的一些特定实例存在固定的对应关系时，这两个系统之间为关联关系
- 例如客户与订单、公司与员工、自行车与主人属于关联关系。而自行车和打气筒之间不是固定的对应关系
- Person类与Bicycle类之间存在关联关系，意味着在Person类中需要定义一个Bicycle类型的成员变量
###### 关联关系的名称
关联关系可以有一个名称，用于描述该关系的性质。此关联名称应该是动词短语，因为它表明源对象正在目标对象上执行动作。在类图中用在箭头上加关联名来表示
###### 关联关系的多重性
关联关系的多重性指有多少对象可以参与该关联，多重性可以用来表达一个取值范围，特定值、无限定的范围
###### 关联关系总结
关联关系是类与类之间的联结，它使一个类知道另一个类的属性和方法，关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或没有箭头，单向的关联有一个箭头。在Java和C++中，关联关系是通过使用成员变量来实现的
##### 聚合关系--------<>
- 聚合关系是关联关系的一种，是更强的关联关系
- 聚合是整体和部分之间的关系，例如汽车由引擎、轮胎和其他零件组成，汽车可以选择各种型号的发动机
- 聚合关系也是通过成员变量来实现的。但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同的层次上，一个代表整体，一个代表部分
##### 组合关系--------◀▶
- 组合关系是关联关系的一种，是比聚合关系更强的关系
- 代表整体的对象负责代表部分对象的生命周期----这是组合和聚合的区别
- 例如公司和部门就是组合关系，如果公司不存在了，部门也就不存在了，而反之，如果所有的部门都不存在了，那么公司也不存在了
- 例如人和五脏六腑的关系
##### 泛化关系---------▷
- 在UML中，泛化关系用来表示类与类、接口与接口之间的继承关系，泛化关系有时也称为"is a kand of"关系
- 在UML中，泛化关系用一条实线加空心箭头表示，空心箭头由子类指向父类
##### 依赖关系- - - - ->
- 对于两个相对独立的系统，当一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务时，这两个系统之间体现为依赖关系，例如自行车和打气筒
- 一个类是另一个类的成员函数的参数或函数返回值，依赖关系用虚线加箭头表示，箭头指向依赖的类
##### 实现关系- - - - -▷ 
实现关系用来表示类与接口之间的实现关系，用虚线空心箭头表示，由子类指向父类

### 对象图
- 对象图是类图的一个实例，用于显示系统执行时的一个可能的快照，即在某一个时间上系统可能出现的样子，对象图用带下划线的对象名称来表示对象
- 对象图表现对象的特征
- 对象图展现了多个对象的特征及对象之间的交互

### 包图
- 由包和包之间的关系组成，包的图标就如同一个带标签的文件夹
包提供了一种用于组织各种元素的分组机制
- 在UML中，包用来对元素进行分组，并为这些元素提供命名空间，包所拥有的或者引用的所有元素称为包的内容，包没有实例

### 组件图
- 组件图用来建立系统中各组件之间的关系，各组件通过功能组织在一起
- Javabean/ejb/jsp都是组件。在UML中，组件使用在左侧有两个小矩形的大矩形来表示
- 组件图可以用来设计系统的整体架构

### 部署图
部署图用来帮助开发者了解软件中的各个组件驻留在什么硬件位置，以及这些硬件之间的交互关系
#### 节点
用来表示一种硬件，可以是打印机、计算机等，节点的标记符号是一个三维框，在框的左上方包含了节点的名称
#### 通信关联
节点通过通信关联建立彼此的关系，采用节点到节点绘制实线来表示关联


## 动态模型图
描述系统行为的各个方面
### 用例图（Use Case Diagram）
- 用例图也称为用户模型图，是从软件需求分析到最终实现的第一步，它是从客户的角度来描述系统功能
- 用例图包含3个基本组件
  - 参与者
  - 用例
  - 关系
#### 参与者（Actor）
与系统打交道的人或其他系统，即使用该系统的人或事物，在UML中参与者用人形图标表示
#### 用例（Use Case）
代表系统的某项完整的功能，在UML中使用一个椭圆来表示
#### 关系
定义用例之间的关
- 泛化关系
- 扩展关系
- 包含关系
##### 泛化关系
泛化对应C++中的继承，表示同一业务目的（父用例）的不同技术实现（各个子用例）。在UML中，用例泛化用一个三角箭头从子用例指向父用例
##### 扩展关系
如果在完成某个功能的时候偶尔会执行另一个功能，则用扩展关系表示。在UML中扩展关系用虚线箭头加```<<extend>>``` 表示，箭头指向被扩展的用例
##### 包含关系
一个用例可以包含其他用例具有的行为，并把它包含的用例行为作为自身行为的一部分，在UML中包含关系用虚线箭头加 ```<<include>>``` 表示，箭头指向被包含的用例
### 时序图
- 时序图用于描述对象之间的传递消息的时间顺序，即用例中的行为顺序
- 当执行一个用例时，时序图中的每条消息对应了一个类操作或引起转换的触发事件
- 在UML中，时序图表示为一个二维的关系图，其中，纵轴是时间轴，时间沿竖线向下延伸，横轴代表在协作中各个独立的对象，当对象存在时，生命线用一条虚线表示，消息用从一个对象的生命线到另一个对象的生命线的箭头表示，箭头以时间的顺序在图中上下排列
#### 时序图中的基本概念
##### 对象
时序图中对象用矩形表示，且在对象名称下有下划线，将对象置于时序图的顶部说明在交互开始时对象就已经存在了，如果对象的位置不在顶部，表示对象是在交互的过程中被创建的
##### 生命线
生命线是一条垂直的虚线，表示时序图中的对象在一段生命周期内的存在，每个对象底部中心的位置都带有生命线
##### 消息
两个对象之间的单路通信，从发送方指向接收方，在时序图中很少使用返回消息
##### 激活
时序图可以描述对象的激活和钝化。激活表示该对象被占用已完成某项任务，钝化指对象处于空闲状态，等待消息。在UML中，对象的激活是将对象的生命线拓宽为矩形来表示的，矩形称为计划条或控制期，对象就是在激活条的顶部被激活的，对象在完成自己的工作后被钝化
##### 对象的创建和销毁
在时序图中，对象的默认位置是在图的顶部，这说明对象在交互开始之前就已经存在了。如果对象是在交互过程中创建的，那么就应该将对象放到中间部分。如果要撤销一个对象，在其生命线终止点处放置“X”符号

### 协作图
协作图也叫合作图，是一种交互图
时序图主要侧重于对象间消息传递在时间上的先后关系，而协作图表达对象间的交互过程及对象间的关联关系

### 状态图
通过建立对象的生命周期模型来描述对象随时间变化的动态行为
#### 状态
用圆角矩形表示，状态名称表示状态的名字，通常用字符串表示，一个状态的名称在状态图所在的上下文中应该是惟一的
#### 转换
用带箭头的直线表示，一端连着源状态，一端连着目标状态
#### 初始状态
每个状态图都有一个初始状态，此状态代表状态图的起始位置，初始状态只能作为转换的源，不能作为转换的目标，并且在状态图中只能有一个，初始状态用一个实心圆表示
#### 终止状态
模型元素的最后状态，是一个状态图的终止点，终止状态在一个状态图中可以有多个

### 活动图
在UML中，活动图本质上就是流程图，用于描述系统的活动、判定点和分支等
活动图基本概念
#### 动作状态
原子的、不可中断的动作，并在此动作完成之后向另一个动作转变。在UML中动作状态用圆角矩形表示，动作状态所表示的动作写在圆角矩形内部
#### 分支与合并
分支在软件系统中很常见，一般用于表示对象类所具有的条件行为，用一个布尔型表达式的真假来判定动作的流向，条件行为用分支和合并表达。在活动图中，分支用空心小菱形表示，分支包括一个入转换和两个带条件的出转换，出转换的条件应该是互斥的，必须保证只有一条出转换能够被触发。合并包含两个带条件的入转换和一个出转换
#### 分叉与汇合
分叉用来描述并发线程，每个分叉可以有一个输入转换和两个或多个输出转换。每个转换都可以是独立的控制流。汇合代表两个或多个并发控制流同步发生，当所有的控制流都达到汇合点后，控制才能继续往下进行。每个汇合可以有两个或多个输入转换和一个输出转换。在UML中分叉和汇合用一条粗直线表示
#### 泳道
泳道将活动图中的活动划分为若干组，并将每一组指定给负责这组活动的业务组织。泳道区分负责活动的对象，明确地表示哪些活动是由哪些对象进行的。每个活动指定明确地属于一个泳道，在活动图中，泳道用垂直实线绘出，垂直线分隔的区域即为泳道


# 软件生命周期
## 软件设计与软件开发
### 软件设计
把软件开发想清楚的过程
### 软件开发
对软件开发全过程进行建模和管理
## 过程模型与开发方法
### 软件过程模型
- 瀑布模型
- 原型模型
- 迭代模型
- 螺旋模型
- 统一过程模型
- 敏捷模型
### 软件开发方法
结构化方法、面向对象方法、敏捷统一方法
# 设计模式概述
## 软件设计模式数量
共24个
GoF提出的设计模式有23个+简单工厂模式
## 软件设计模式用途
学习设计模式将有助于更加深入理解面向对象思想
1. 如何将代码分散在几个不同的类中？
2. 为什么要有“接口”？
3. 什么是针对抽象编程？
4. 什么时候不应该使用继承？
5. 如果不修改源代码，如何增加新功能？
6. 更好地阅读和理解现有类库与其他系统中的源代码
## 如何学好设计模式
设计模式的基础是多态
- 初学者：积累案例，不要盲目背类图
- 初级开发者：多思考，多梳理，归纳总结，尊重事物的认知规律，注意临界点的突破，不要浮躁
- 中级开发者：合适的开发环境，寻找合适的设计模式来解决问题，多应用，对经典组合设计模式大量、自由运用，要不断的追求

**设计模式的基础是多态**


# 设计模式基本原则
- 如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一
- 面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，他们是从许多设计方案中总结出的指导性原则
- 面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一

**原则的目的：高内聚，低耦合**
## 面向对象设计具体原则
### 单一职责原则
（Single Responsibility Principle,SRP）
类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个
### 开闭原则/开放封闭原则
（Open-Closed Principle,OCP）
**重要原则**
对扩展开放，对修改关闭。类的改动是通过增加代码进行的，而不是修改源代码
### 里氏代换原则
（Liskov Substitution Principle,LSP）
任何抽象类出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能
### 依赖倒转原则
（Dependence Inversion Principle,DIP）

**重要原则**
依赖于抽象（接口），不要依赖具体的实现（类），也就是针对接口编程

传统的过程式设计倾向于使高层次的模块依赖于低层次的模块，抽象层依赖于具体的层次，即高层业务逻辑依赖中层模块，中层模块依赖底层模块。这样底层模块、中间层模块和高层模块耦合性极高，任意修改其中一个，很容易导致全面积的修改
简单地说就是框架和实现层都向中间层（协议层/抽象层）靠拢
#### 依赖倒转的实现原理
1. 高层模块不能依赖于底层模块 二者都应该依赖其抽象
2. 抽象不应该依赖细节 细节要依赖于抽象
3. 依赖倒转的中心思想就是面向接口编程
#### 依赖倒转的设计理念
- 考虑到细节的多变性 抽象的东西要更加稳定
- 以抽象为基础搭建的结构比以细节为基础搭建的架构也要稳定的多
- 抽象是指接口或抽象类 细节就是具体的实现类
- 使用抽象类的目的是为了制定好规范 而不涉及任何具体的操作，把展示细节的任务交给实
- 现类去完成

### 接口隔离原则
（Interface Segregation Principle,ISP）
不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去
### 合成复用原则
（Composite Reuse Principle,CRP）
如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系，对于继承和组合，优先使用组合（组合即把一个类缓存到另一个类的成员变量中）
### 迪米特法则
（Law of Demeter,LoD）

**重要原则**
又叫最少知识原则。一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常提供一个统一的接口来实现。这样其他模块不需要了解另一个模块的内部实现细节。当一个模块内部的实现发生改变时，不会影响其他模块的使用（黑盒原理）


# 设计模式
### 简单工厂模式
- 又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一
- 简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例
- 简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现
- 不直接由自己从类创建对象，而是用一个工厂类来来创建对象
- 传入参数，让工厂知道应该创建什么类型的对象
#### 模式结构
##### creator/工厂
简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象
##### Product/抽象产品
简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口
##### concrete Product/具体产品
简单工厂模式所创建的具体实例对象
#### 优点
1. 实现了对象创建和使用的分离
2. 不需要记住具体类名，记住参数即可，减少使用者记忆量
#### 缺点
1. 对工厂类职责过重，一旦不能工作，系统受到影响
2. 增加系统中类的个数，复杂度和理解度增加
3. 违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂
**因为不符合开闭原则，所以不属于GOF设计模式**
#### 适用场景
1. 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂
2. 客户端只知道传入工厂类的参数，对于如何创建对象并不关心

## 创建型模式
通常和对象创建有关，涉及到对象实例化的方式，共有5种模式
### 工厂方法模式(Factory Method)
- 简单工厂不符合开闭原则，要让它符合开闭原则，则需要把工厂类也抽象出来，这就是工厂方法模式，又叫多态工厂模式
- 工厂方法模式=简单工厂模式+开闭原则
- 工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品
- 工厂方法模式是简单工厂模式的衍生，解决了许多简单工厂模式的问题。首先完全实现开闭原则，实现了可扩展
#### 定义
定义一个用于创建产品的接口，由子类决定生产什么产品
#### 模式结构
##### creator/抽象工厂
工厂方法模式的核心，任何工厂类都必须实现这个接口
##### Concrete Creator/具体工厂
具体工厂类是抽象工厂的一个实现，负责实例化产品对象
##### Product/抽象产品
工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口
##### Concrete Product/具体产品
工厂方法模式所创建的具体实例对象
#### 优点
1. 不需要记住具体类名，甚至连具体参数都不用记忆
2. 实现了对象创建和使用的分离
3. 系统的可扩展性也就变得非常好，无需修改接口和原类。符合开闭原则
#### 缺点
1. 类的个数成倍增加，每新增一个新功能时就需要增加两个类，导致系统的复杂度增加，增加维护成本
2. 在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度
#### 适用场景
1. 客户端不知道它所需要的对象的类
2. 抽象工厂类通过其子类来指定创建哪个对象

### 抽象工厂模式（Abstract Factory）
抽象工厂针对的是产品族，而不是产品等级结构
- 产品族
同一产地或同一厂商，功能不同
- 产品等级
功能相同，产地或厂商不同
#### 定义
提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品
#### 抽象工厂与工厂模式的区别
工厂模式只能生产一个产品，抽象工厂可以生产一个产品族
#### 模式结构
##### creator/抽象工厂
抽象工厂模式的核心，包含对多个产品结构的声明，任何工厂类都必须实现这个接口
##### Concrete Creator/具体工厂
具体工厂类是抽象工厂的一个实现，负责实例化某个产品族中的产品对象
##### Product/抽象产品
抽象工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口
##### Concrete Product/具体产品
抽象工厂模式所创建的具体实例对象
#### 优点
1. 拥有工厂方法模式的优点
2. 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象
3. 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”
#### 缺点
增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”
#### 适用场景
1. 系统中有多于一个的产品族。而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族
2. 产品等级结构稳定。设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构

### 建造者模式（Builder）
- Builder模式也叫建造者模式或者生成器模式，是一种对象创建型模式，用来隐藏复合对象的创建过程，它把复合对象的创建过程加以抽象，通过子类继承和重载的方式，动态地创建具有复合属性的对象

- 产品需要很多步骤才能完成构建，创建一个抽象建造者用来完成这些构建步骤，通过子类实现出不同产品的相同步骤的不同赋值

- 建造者模式，其实就是相当于一个设计师，指挥建造师造房子，建造师可能是不同的，因为每个建造师建造水平和会造的房子都是不一样的
#### 定义
将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示
#### 模式结构
##### Builder/抽象建造者
为创建产品各个部分，统一抽象接口，提供各功能的接口，供Director使用
##### ConcreteBuilder/具体建造者
具体的创建产品的各个部分，部分A，部分B，部分c。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口
##### Director/指挥者
构造一个使用Builder接口的对象，负责业务逻辑
##### Product/具体产品
表示被构造的复杂对象
#### 适用场景
一个对象的构造比较复杂，将一个对象的构造和对象的表示进行分离
#### 建造者模式与工厂模式的区别
##### Factory模式中
- 有一个抽象的工厂
- 实现一个具体的工厂 - 汽车工厂
- 工厂生产的汽车A，得到汽车产品A
- 工厂生产汽车B，得到汽车产品B
- 实现了购买者和生产线的隔离，强调的是结果
##### Builder模式中
- 引擎工厂生产引擎产品，得到汽车的部件A
- 轮胎工厂生产轮子产品，得到汽车部件B
- 底盘工厂生产车身产品，得到汽车部件C
- 将这些部件放到一起，形成刚好能够组装成一辆汽车的整体
- 这样做，目的是为了实现复杂对象生产线和其部件的解耦。强调的是过程
##### 两者的区别在于以下几种情况
1. 工厂模式不考虑对象的组装过程，而直接生成一个我想要的对象；建造者模式先一个个的创建对象的每一个部件，再统一组装成一个对象
2. 工厂模式所解决的问题是，工厂生产产品；而建造者模式解决的是工厂控制产品 生成器组装各个部件的过程，然后从产品生成器中得到产品


### 原型模式（Prototype）
原型模式是一种对象创建型模式,它采取复制原型对象的方法来创建对象的实例。使用原型模式创建的实例，具有与原型一样的数据
1. 由原型对象自身创建目标对象。也就是说，对象创建这一动作发自原型对象本身
2. 目标对象是原型对象的一个克隆。也就是说，通过Prototype模式创建的对象，不仅仅与原型对象具有相同的结构，还与原型对象具有相同的值
3. 根据对象克隆深度层次的不同，有浅度克隆与深度克隆

#### 定义
用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象
#### 适用场景
一个复杂对象，具有自我复制功能，统一一套接口

### 单例模式（Singleton）
单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案
#### 定义
某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式
#### 实现单例步骤
- 第1步：构造函数私有化
- 第2步：增加静态私有的当前类的指针变量
- 第3步：提供静态对外接口，可以让用户获得单例对象
#### 创建方式
##### 懒汉式
**需要的时候才会创建**
在类外初始化静态成员变量时，初始值赋值NULL，在提供的对外接口Get中作判定，如果静态成员变量=NULL，则进行new创建，如果不为NULL，则返回静态成员变量

##### 饿汉式
**直接创建，理解为main执行前，就创建好了**
在类外初始化静态成员变量时就进行new创建
#### 单例对象的释放问题
单例不需要考虑释放问题，因为单例对象从头到尾就一份内存不会栈溢出，没必要释放

如果一定要释放单例对象，具体方法为：
- 第1步：在单例类中声明一个内嵌类Garbo（Garbo意为垃圾工人），在该类的析构函数中释放new出来的单例对象
- 第2步：给单例类增加一个static Garbo静态成员变量

因为Garbo存放在静态区，所以进程结束时Garbo对象会自动释放，它释放的时候会释放单例对象
#### 单例与多线程
- 多线程中，懒汉式是线程不安全的，如果使用懒汉式，需要增加加锁和解锁的步骤
- 因为可能线程1和线程2同时创建单例对象，但是因为此时并不存在单例对象，可能会创建出两个单例对象
- 多线程中，饿汉式是线程安全的，可以直接使用饿汉式


## 结构型模式
让类与类进行组合，获取更大的结构，共7种模式
### 代理模式（Proxy）
为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用

简单地说，就是a中包含b类，a、b类都实现协议类protocol，a和b类都继承自protocol，且把b作为a的成员变量
#### 定义
为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性
#### 模式结构
##### Subject（抽象主题角色）
声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程
##### Proxy（代理主题角色）
代理主题角色通过关联关系引用真实主题角色，因此可以控制和操纵真实主题对象；代理主题角色中提供一个与真实主题角色相同的接口（以在需要时代替真实主题角色），同时还可以在调用对真实主题对象的操作之前或之后增加新的服务和功能
##### RealSubject（真实主题角色）
定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作
#### 代理模式的举例
1. 通过代理服务器上外网
2. 缓冲服务器
#### 优点
1. 必须有权限验证，不是所有人都能来启动我的系统，必须提供用户名和密码
2. 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度
3. 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性
#### 缺点
1. 在客户端和真正目标对象之间增加代理对象，请求速度有可能会变慢
2. 增加代理会使系统复杂度变高
#### 适用场景
为其他对象提供一种代理以控制对这个对象的访问
#### 模式应用
1. 代理服务器，通过代理服务器访问无法访问的服务器
2. 可以在代理服务器实现负载均衡、数据缓存
#### 常见的代理模式
##### 远程代理（Remote）
为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是同一台主机中，也可以是在另一台主机中
##### 虚拟代理（Virtual）
如果需要创建一个资源消耗比较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只有需要时才会被真正创建
如打开网页时，先看到文字，比较大的图片一张张下载
##### 保护代理（Protect or Access）
控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。
##### 其他的代理
缓冲代理、防火墙代理、同步化代理

### 外观模式（Facade）
根据迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用

Facade模式也叫外观模式，是由GoF提出的23种设计模式中的一种。Facade模式为一组具有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade

比如有两个子系统，如果都初始化，传统需要一个一个new一下，现在提供一个类，在这个类里面做完初始化工作
#### 定义
为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问
#### 模式结构
##### Facade(外观角色)
调用方, 定义简单的调用接口
##### SubSystem(子系统角色)
功能提供者，指提供功能的类群（模块或子系统）
#### 外观模式本质
外观模式就是将复杂的子类系统抽象到同一个的接口进行管理，外界只需要通过此接口与子类系统进行交互，而不必要直接与复杂的子类系统进行交互
#### 优点
1. 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少
2. 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可
3. 一个子系统的修改对其他子系统没有任何影响
#### 缺点
1. 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性
2. 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则
#### 适用场景
1. 复杂系统需要简单入口使用
2. 客户端程序与多个子系统之间存在很大的依赖性
3. 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度


### 适配器模式（Adapter）
在软件开发中，有的时候系统的数据和行为都正确，但接口不符合，我们应该考虑使用适配器模式，目的是使控制范围之外的一个原有对象与某个接口匹配
#### 定义
将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作
#### 优点
1. 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构
2. 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用
3. 灵活性和扩展性都非常好，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”
#### 缺点
过多地使用适配器，会让系统非常零乱，不易整体进行把握。一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构
#### 适用场景
1. 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码
2. 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作
#### 实现形式
##### 类适配器
适配器Adapter继承自Target和Adaptee类，Adapter类需要重写Target类的Request函数，在Request中做适当的处理，调用Adaptee类的SepcificRequest

最终，Target实际调用的是Adaptee的SpecificRequest来完成Request的，完成适配；这种叫做类适配器
##### 对象适配器
适配器Adapter类继承自Target类，同时，在Adapter类中有一个Adaptee类型的成员变量

Adapter类重写Request函数时，在Request中，使用Adaptee类型的成员变量调用Adaptee的SpecificRequest函数，最终完成适配；这种叫做对象适配器
##### 类适配器和对象适配器对比
类适配器有以下特点：
1. 由于Adapter直接继承自Adaptee类，所以，在Adapter类中可以对Adaptee类的方法进行重定义
2. 如果在Adaptee中添加了一个抽象方法，那么Adapter也要进行相应的改动，这样就带来高耦合
3. 如果Adaptee还有其它子类，而在Adapter中想调用Adaptee其它子类的方法时，使用类适配器是无法做到的

对象适配器有以下特点：
1. 有的时候会发现，不是很容易去构造一个Adaptee类型的对象
2. 当Adaptee中添加新的抽象方法时，Adapter类不需要做任何调整，也能正确的进行动作
3. 可以使用多态的方式在Adapter类中调用Adaptee类子类的方法

由于对象适配器的耦合度比较低，所以通常使用对象适配器。在我们实际项目中，也是如此，能使用对象组合的方式，就不使用多继承的方式
#### 代码案例
```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

//适配器模式 就是将已经写好的接口，但是这个接口不符合需求
//将写好的接口转换成目标接口

//已写好但不适配的函数接口
struct Myprint{
	void operator()(int v1,int v2) {
		cout << v1 + v2 << endl;
	}
};

//定义目标接口
//要适配成只能传一个参数的，适配for_each第三个参数的适用
class Target {
public:
	virtual void operator()(int v) = 0;

};

//写适配器
class Adapater :public Target {
public:
	Adapater(int param) {
		this->param = param;
	}
	virtual void operator() (int v) {
		print(v,param);
	}
public:
	Myprint print;
	int param;
};

//MyBind2nd，原来param固定的10，现在提供一个方法改
Adapater MyBind2nd(int v) {
	return Adapater(v);
}


int main(void) {
	vector<int> v;
	for (int i = 0; i < 10; i++) {
		v.push_back(i);
	}
	
	//适配器模式的运用
	//for_each()的第三个参数是个带一个参数的函数，但是Myprint需要两个参数
	for_each(v.begin(),v.end(), MyBind2nd(10));

	return 0;
}
```

### 装饰模式（Decorator）
- 装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代
- 装饰模式就是把要附加的功能分别放在单独的类中，并让这个类包含它要装饰的对象，当需要执行时，客户端就可以有选择的、按顺序的使用装饰功能包装对象
- 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。有时我们希望给某个对象而不是整个类添加一些功能。
- 比如有一个手机，允许你为手机添加特性，比如增加挂件、屏幕贴膜等。一种灵活的设计方式是，将手机嵌入到另一对象中，由这个对象完成特性的添加，我们称这个嵌入的对象为装饰。这个装饰与它所装饰的组件接口一致，因此它对使用该组件的客户透明
#### 定义
动态的给对象增加一些职责，即增加其额外的功能
#### 模式结构
##### Component（抽象组件类）
定义一个对象接口，可以给这些对象动态地添加职责
##### ConcreteComponent（具体组件类）
定义一个具体的Component，继承自Component，重写了Component类的虚函数
##### Decorator（抽象装饰器类）
继承自Component抽象组件类，维持一个指向Component对象的指针，该指针指向需要被装饰的对象，并定义一个与Component接口一致的接口
##### ConcreteDecorator（具体装饰器类）
继承自Decorator，向组件添加职责

**要特别注意抽象装饰器类要继承自抽象组件类，因为穿了装备的英雄，还是英雄**

#### 优点
1. 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加
2. 可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为
3. 可以对一个对象进行多次装饰
4. 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”
#### 缺点
使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能
#### 适用场景
1. 动态、透明的方式给单个对象添加额外的职责，就增加功能来说，装饰模式比生成子类更灵活
2. 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。

装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。而当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器

### 桥接模式（Bridge）
Bridge模式又叫做桥接模式，是构造型的设计模式之一。Bridge模式基于类的最小设计原则，通过使用封装、聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展

桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，也减少了代码量
#### 定义
将抽象部分与实际部分分离，使它们都可以独立的变化
#### 模式结构
##### Client
Bridge模式的使用者
##### Abstraction
抽象类接口（接口或抽象类）维护对行为实现（Implementor）的引用
##### Refined Abstraction
Abstraction子类
##### Implementor
行为实现类接口 (Abstraction接口定义了基于Implementor接口的更高层次的操作)
##### Concrete Implementor
Implementor子类

### 组合模式（Composite）
组合模式又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构

组合模式意图是通过整体与局部之间的关系，通过树形结构的形式进行组织复杂对象，屏蔽对象内部的细节，对外展现统一的方式来操作对象，是我们处理更复杂对象的一个手段和方式
#### 定义
将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性
#### 模式结构
##### Component
1. 为组合中的对象声明接口
2. 在适当的情况下，实现所有类共有接口的缺省行为
3. 声明一个接口用于访问和管理Component的子组件
##### Leaf
1. 在组合中表示叶节点对象，叶节点没有子节点
2. 在组合中定义叶节点的行为
##### Composite
1. 定义有子部件的那些部件的行为
2. 存储子部件
##### Client
通过Component接口操作组合部件的对象
#### 优势
1. 可以结合C++的多态和递归设计出复杂的树形结构，但接口单一
2. 符合开闭原则，当需要增加新的节点或树时，无需修改原有代码，并且可以成为现有树节点的一部分
#### 劣势
如果本质上叶子节点差异巨大时，很难抽象，只能通过适配器or桥接的形式给叶子节点提供适配接口，代码会变得难以理解
#### 实现要点
- Composite的关键之一在于一个抽象类，它既可以代表Leaf，又可以代表Composite；所以在实际实现时，应该最大化Component接口，Component类应为Leaf和Composite类尽可能多定义一些公共操作。Component类通常为这些操作提供缺省的实现，而Leaf和Composite子类可以对它们进行重定义
- Component是否应该实现一个Component列表，由于在Leaf中，不可能存在子Composite，所以在Composite中维护了一个Component列表，这样就减少了内存的浪费
- 内存的释放；由于存在树形结构，当父节点都被销毁时，所有的子节点也必须被销毁，所以，在析构函数中对维护的Component列表进行统一销毁，这样就可以免去客户端频繁销毁子节点的困扰
- 由于在Component接口提供了最大化的接口定义，导致一些操作对于Leaf节点来说并不适用，比如：Leaf节点并不能进行Add和Remove操作，由于Composite模式屏蔽了部分与整体的区别，为了防止客户对Leaf进行非法的Add和Remove操作，所以，在实际开发过程中，进行Add和Remove操作时，需要进行对应的判断，判断当前节点是否为Composite。
#### 适用场景
- 对于系统对象层次具备整体和部分的特征，并且可以构造出呈树形结构，这属于组合模式的适用场景，实际场景如公司的组织架构，电脑的目录结构
- 通过组合模式可以最终把不同的叶子节点，抽象成相同的节点，达成了忽略整体-部分差异，最终给用户的是统一的抽象接口

当发现需求中是体现部分与整体层次结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式了



## 行为型模式
用来对类或对象怎样交互和怎样分配职责进行描述，共11种模式
### 模板方法模式（Template Method）
#### 定义
定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤
#### 优点
1. 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序
2. 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用
3. 可实现一种反向控制结构，通过子类覆盖父类的方法来决定某一特定步骤是否需要执行
4.在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则
#### 缺点
需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象


### 策略模式（Strategy）
#### 定义
定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户
#### 优点
1. 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为
2. 使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后
3. 策略模式提供了一种算法的复用机制。由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类
#### 缺点
1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况
2. 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类
#### 策略模式的适用场景
准备一组算法，并将每一个算法封装起来，使得它们可以互换


### 命令模式（Command）
将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式

命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求

一般通过队列容器（Queue）来完成命令模式
#### 定义
将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开，从而使我们可以用不同的请求对客户进行参数化，对请求排列或记录请求日志，以及支持可撤销的操作，命令模式是一种对象行为模式
#### 模式结构
命令者模式包括请求的发送者、接受者、抽象命令、具体命令等角色
##### Command（抽象命令类）
抽象命令类一般是一个接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作
Command实现请求调用者和接受者解耦
##### ConcreteCommand(具体命令类)
具体命令类是抽象命令类的子类，实现抽象命令类的子类，在实现execute()方法时，将调用接受者对象的相关操作（action）
##### Invoker（调用者）
调用者即请求的发送者，它通过命令对象来执行请求，一个调用者并不需要在设计时确定其接受者，因此它只与抽象命令类之间存在关联关系
##### Receiver（接受者）
接受者执行与请求相关的操作，它具体实现对请求业务处理
##### Client(客户类)
在客户端类中需要创建发送者对象和具体命令类对象，在创建具体命令对象时指定其对应的接受者，发送者和接受者之间无直接关系，通过具体命令对象实现间接调用
#### 优点
1. 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性
2. 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求
3. 可以比较容易地设计一个命令队列或宏命令（组合命令）
#### 缺点
使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用
#### 命令模式本质
命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分隔开

每一个命令都是一个操作，请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。请求的一方不必知道接受请求的一方的接口，更不必知道请求是怎么被接收、操作是否被执行、何时被执行，以及是怎么被执行的

命令模式使得请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递
#### 适用场景
1. 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用
2. 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现
3. 系统需要将一组操作组合在一起形成宏命令

### 观察者模式（Observer）
随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车

观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展

这种交互也称为发布-订阅(publish-subscribe)，观察者模式又叫发布-订阅模式、模型-视图模式
#### 定义
多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为
#### 模式结构
##### 抽象目标（Abstract Subject）角色
抽象目标角色提供维护一个观察者对象集合的操作方法，对集合的增加、删除等
##### 具体目标（Concrete Subject）角色
将有关状态存入具体的观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发通知。具体主题角色负责实现抽象主题中的方法
##### 抽象观察者（Abstract Observer）角色
为具体观察者提供一个更新接口。该接口声明了更新数据的方法
##### 具体观察者（Concrete Observer）角色
存储具体观察者的有关状态，这些状态需要和具体目标的状态一致，实现抽象观察者提供的更新接口
#### 优点
1. 可以实现表示层与数据逻辑层的分离
2. 观察者模式支持广播通信，观察目标会向所有的注册的观察者发出通知，简化了一对多系统的设计难度；
3. 符合“开闭原则”，增加新的具体观察者无须修改原有的系统代码
#### 缺点
如果一个观察目标对象有很多直接或间接的观察者，将所有的观察者都通知会花费很多时间
#### 工作原理
观察者模式按照以下方式进行协作：
当ConcreteSubject(具体目标)发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者；
在得到一个具体目标的改变通知后，ConcreteObserver（具体观察者）对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致
#### 应用场景
日志备份系统




