# 基础
## 常用DOS命令
- 切换到某个盘符下
```
C:
```
- 查看当前路径下的文件信息
```
dir
```
- 进入目录
```
cd
```
  - 进入单级目录
  ```
  cd 文件夹名
  ```
  - 进入多级目录
  ```
  cd D:\文件夹1\文件夹2
  ```
  - 回退到上一级目录
  ```
  cd ..
  ```
  - 回退到盘符根目录
  ```
  cd\
  ```
- 清屏
```
cls
```
## JDK的组成
### JVM(Java Virtual Machine)
Java虚拟机，真正运行Java程序的地方
### 核心类库
Java自己写好的程序，给程序员调用
#### JRE(Java Runtime Environment)
Java的运行环境，包括JVM和核心类库
#### JDK(Java Development Kit)
Java开发工具包，包括JRE和开发工具（Java,Javac,...）  
**LTS：长期支持板，如JDK8、11、17**
## JDK的2个最重要程序
### Javac
编译程序
### Java
执行程序  
**HDK安装后要验证是否安装成功**
打开命令行窗口，输入```java javac java-version```看提示有没有问题



### 跨平台
#### Java跨平台的含义
一次编译，处处可用
#### 实现原理
程序只需要开发一次，可以在各种安装了JVM的系统平台上运行
#### Java最重要的特性
可移植性


### Java的技术体系
#### JavaSE
标准版，Java技术的核心和基础
#### JavaEE
企业版，大型互联网企业级解决方案，充分被市场认可
#### JavaME
小型版，移动应用解决方案，没有被市场认可，主流的是安卓开发

### 环境变量
#### Path环境变量
用于记住程序路径，方便在命令行窗口的任意目录启动程序
#### Path环境变量位置
我的电脑->属性->高级系统设置->高级->环境变量

#### Java_home环境变量
告诉操作系统JDK安装在哪个位置（将来其他技术要通过这个环境变量找JDK）  
**新版JDK会自动配置Path，但不会自动配置JAVA_HOME,需自己手动配置**  
###### 推荐配置名
```
Path %JAVA_HOME%\bin
```

### IDE
集成开发环境（Integrated Development Environment）
#### IntelliJ Idea
###### 快捷键
- 快速键入相关代码```main/psvm、sout、...```
- 复制当前行数据到下一行'''Ctrl+D'''
- 删除所在行```Ctrl+Y```，建议用```Ctrl+X```
- 格式化代码```Ctrl+ALT+L```
- 上下移动当前代码```ALT+Shift+↑```，```ALT+Shift+↓```
- 对代码进行注释```Ctrl+/```，```Ctrl+Shift+/```
- 调出包裹选项，while、do...while、try...catch等```Ctrl+ALT+T```


## 基础语法
### 注释
注释是写在程序中对代码进行解释说明的文字，方便自己和其他人查看，以便理解程序
#### 注释种类
###### 代码注释
- 单行注释
```//```
快捷键```Ctrl+/```
- 多行注释
```
/*    */
```
对选中的代码进行多行注释 快捷键```Ctrl+Shift+/```
###### 文档注释
```
/**   */
```
文档注释可以自动提取到文档说明中
#### 注释特点
注释不影响程序的执行

### 字面量
字面量是数据在程序中的书写格式
#### 书写格式
- 数字
- 字符
  - 单引号，且只能有一个字符
- 字符串
双引号
- 布尔值
- 空值
- 特殊字符
  - 换行
```
\n
```
  - 跳一个Tab值
```
\t
```

### 变量
变量是用来记住程序要处理的数据的
#### 变量的定义格式
```
数据类型 变量名称 = 数据;
```
##### 数据类型
限制盒子中只能存储某种数据形式，例如：```int```, ```double```
##### 变量名称
首字母建议小写，有意义
##### 赋值
```=```
#### 使用变量的优点
- 使用变量储存要处理的数据，编写的代码更灵活，管理代码更方便
- 便于扩展和维护
#### 变量的执行原理
变量就是内存中的一块区域，用来存储一段数据
#### 变量的特点
变量中的数据可以替换
#### 使用变量的注意事项
- 变量要先声明，才能使用
- 什么类型的变量，只能存储什么类型的数据
- 变量存在访问范围，同一个范围内，多个变量的名字不能一样
- 变量定义时可以不给赋初始值，但是在使用时，变量里必须有值

### 关键字
Java语言自己用到的一些词，有特殊作用的，我们称之为关键字，如：```public```、```class```、```int```、```double``` ...

关键字不能用作类名、变量名，否则会报错

### 标识符
标识符就是写程序时起的名字，如类名、变量名等等都是标识符
#### 标识符的要求
- 基本组成  
由数字、字母、下划线 ```_``` 和美元符号 ```$``` 等组成
- 强制要求  
不能以数字开头，不能用关键字作为标识符，且标识符是区分大小写的
#### 标识符的建议规范
- 变量名称  
满足标识符规则，同时建议用英文、有意义、首字母小写，满足“驼峰模式”
- 类名称  
满足标识符规则，同时建议全英文、有意义，首字母大写，满足“驼峰模式”


## 语法
### 数据存储原理
#### 二进制
只有0和1，按照逢2进1的方式表示数据
##### 十进制与二进制转换
- 十进制转二进制  
**除二取余法**
- 二进制转十进制  
**八四二一**
#### 八进制和十六进制
为了便于观察和表示二进制，推出了八进制和十六进制
###### 八进制
每3位二进制作为一个单元，最小数是0，最大数是7，共8个数字
###### 十六进制
每4位二进制作为一个单元，最小数是0，最大数是15，共16个数字，依次用A B C D E F代表10-15  
**java程序中支持书写二进制、八进制、十六进制的数据，分别需要以0B或0b、0、0X或者0x开头**

#### 计算机中表示数据的最小单元
###### 字节
计算机中表示数据的最小单元  
一个字节（byte，简称B，是使用8个二进制位组成的）
###### 位
字节中每个二进制位称为位（bit，简称b），1B=8b
#### 字符存储方式
ASCII代码，即美国信息交换标准编码，规定了现代英语、数字字符和其他西欧字符对应的数字编号
- 字符“A”对应数字是65
- 字符“a”对应数字是97
- 字符“0”对应数字是48
#### 图片数据存储方式
图片由无数个像素点组成  
每个像素点的数据用0-255*255*255表示其颜色
#### 声音数据存储方式
把波形图映射到坐标上，存储相应的数据


### 数据类型
#### 基本数据类型
4大类8种
###### 整型
####### byte
- 内存占用1字节
- 数据范围-128到127
####### short
- 内存占用2字节
- 数据范围-32768到32767
####### int
- 内存占用4字节
- 数据范围-21447483648到21447483647
####### long
- 内存占用8字节
- 数据范围
-9223372036854775808到9223372036854775807  
**注意，整型字面量默认是int类型，使用long需要在数据后加L或l**
###### 浮点型
####### float
- 内存占用4字节
- 数据范围1.401298E-45到3.4028235E+38  
**注意，小数字面量默认是double类型，使用float需要在数据后加F或f**
####### double
- 内存占用8字节
- 数据范围4.9000000E-324到1.797693E+308
###### 字符型
####### char
- 内存占用2字节
- 数据范围0到65535
###### 布尔型
####### boolean
- 内存占用1字节
- true、false
#### 引用数据类型
###### 字符串型--String

### 类型转换
类型转换原因
- 存在某种类型的变量赋值给另一种类型的变量
- 存在不同类型的数据一起运算
#### 自动类型转换
类型范围小的变量，可以直接赋值给类型范围大的变量
###### 自动类型转换的形式
byte->short->int->long->float->double
char->int
#### 表达式的自动类型转换
在表达式中，小范围类型的变量，会自动转换成表达式中较大范围的类型，再参与运算  
byte、short、char->int->long->float->double

**注意事项**  
- **表达式的最终结果类型由表达式中的最高类型决定**  
- **在表达式中，byte、short、char是直接转换成int类型参与运算的**

#### 强制类型转换
类型范围大的数据或变量，直接赋值给类型范围小的变量，会报错

强制类型转换可以强行将类型范围大的变量、数据赋值给类型范围小的变量
数据类型 变量2 = （数据类型）变量1/数据

快捷键 ```Alt+Enter```

**注意事项**
1. 强制类型转换可能造成数据（丢失）溢出
2. 浮点型强转成整型，直接丢掉小数部分，保留整数部分返回

### 类型查询
Java中无法直接查询基础类型数据，主要用于查询引用类型（对象），有两种方法
#### 使用getClass方法
###### 语法
```
对象名/类名.getClass()
```
#### 使用instanceof运算符
###### 语法
```
对象名 instanceof 类名
```
返回一个布尔值

**对于基本数据类型（如int、double等），这些方法不太适用，因为它们不是对象，而是直接存储在堆栈中。在这种情况下，通常是在编码时就知道变量的类型，或者通过IDE等工具提供的功能来查看**

### 运算符
#### 算术运算符
```
- +
```
```+```符号与字符串运算时可以用作连接符，其结果依然是一个字符串
```
"abc"+5 ---> "abc5"
```
计算机秉承的原则是能算则算，不能算就连在一起
```
-
*
/
```
整型相除还是整数,浮点数和整数相除得浮点数  
*如果整型相除，想得到浮点数，可以乘以1.0*
```
int i=5;
int j=2;
System.out.println(1.0*i/j); //结果为2.5
```
取余
```
%
```


#### 自增自减运算符
###### 自增++
放在某个变量前面或后面，对变量自身的值加1
###### 自减--
放在某个变量前面或后面，对变量自身的值减1

**注意**  
1. **++和--只能操作变量，不能操作字面量**
2. **++和--如果不是单独使用（如在表达式中，或同时有其他操作），放在变量前后会存在明显区别**
   - **放在变量前面，先对变量进行+1或-1，再拿变量的值进行运算（先加再用）**
   - **放在变量后面，先拿变量的值进行运算，再对变量进行+1或-1（先用再加）**

#### 赋值运算符
###### 基本赋值运算符
####### =
要从右向左看，把右值赋值给左值
```
=
```
###### 扩展赋值运算符
####### a+=b
加后赋值，底层代码形式为```a=(a的类型)(a+b);```
```
+=
```
####### a+=b
减后赋值，底层代码形式为```a=(a的类型)(a-b);```
```
-=
```
####### a*=b
乘后赋值，底层代码形式为```a=(a的类型)(a*b);```
```
*=
```
####### a/=b
除后赋值，底层代码形式为```a=(a的类型)(a/b);```
```
/=
```
####### a%=b
取余后赋值，底层代码形式为```a=(a的类型)(a%b);```
```
%=
```

**注意：扩展的赋值运算符隐含了强制类型转换**

#### 关系运算符
判断数据是否满足条件，最终会返回一个判断结果，这个结果是布尔类型的值
####### a>b,
判断a是否大于b，成立返回true,不成立返回false
```
>
```
####### a>=b
判断a是否大于或等于b，成立返回true,不成立返回false
```
>=
```
####### a<b
判断a是否小于b，成立返回true,不成立返回false
```
<
```
####### a<=b
判断a是否小于或等于b，成立返回true,不成立返回false
```
<=
```
####### a==b
判断a是否等于b，成立返回true,不成立返回false
```
==
```
####### a!=b
判断a是否不等于b，成立返回true,不成立返回false
```
!=
```

**注意不要把==误写成=**

#### 逻辑运算符
####### 逻辑与
例如2>1&3>2，多个条件必须都是true，结果才是true；有一个是false，结果就是false
```
&
```
####### 逻辑或
例如2>|3<5，多个条件中只要有一个是true，结果就是true
```
|
```
####### 逻辑非
例如!(2>1)，就是取反；你真我假，你假我真。```!true==false```，```!false==true```
```
!
```
####### 逻辑异或
例如2>1^3>1，前后条件的结果相同，就直接返回```false```，前后条件的结果不同，才返回```true```
```
^
```

**注意：&和|，无论左边是false还是true，右边都要执行**



####### 短路与
例如```2 > 10 && 3 > 2```，运算逻辑为左边是```false```，则右边不执行
```
&&
```
####### 短路或
例如```2 > 1 || 3 < 5```，运算逻辑为左边是```true```，则右边不执行
```
||
```

由于&&和||运算效率更高，所以在开发中用的更多

#### 三元运算符
###### 格式
```
条件表达式 ? 值1 : 值2;
```
###### 执行流程
首先计算关系表达式的值，如果值为```true```，返回```值1```，如果为```false```，则返回```值2```

#### 运算符优先级
在表达式中，哪个运算符先执行后执行是要看优先级的
|优先级|运算符| 
|  :---:   | :---: |
| 1    |     () |
|  2    |     !、++、--|
|  3    |     *、/、%|
|  4    |     +、-|
|  5    |     <<、>>、>>>|
|  6    |     <、<=、>、>=、instanceof|
|  7    |     ==、!= |
|  8    |     &  |
|  9    |     ^  |
| 10    |     \|  |
|  11   |      &&|
|  12    |     \|\||
|  13    |     ?:|
|  14    |     =、+=、-=、*=、/=、%=、&=|

## 流程控制
程序中最经典的三种执行顺序
- 顺序结构  
自上而下的执行代码
- 分支结构  
根据条件，选择对应代码执行
- 循环结构  
控制某段代码重复执行

### 分支结构
#### if
if分支三种形式
###### ```if```
```
if(条件表达式){
  代码;
}
```
###### ```if...else...```
```
if(条件表达式){
  代码1;
}else{
  代码2;
}
```
###### ```if...else if...else```
```
if(条件表达式){
  代码1;
}else if(条件表达式2){
  代码2;
}else if(条件表达式3){
  代码3;
}
...
else{
  代码n;
}
```
#### switch
通过比较值来决定执行哪条分支
###### 语法
```
switch(表达式){
  case值1:
    执行代码1;
    break;
  case值2:
    执行代码2;
    break;
  ...
  case值n-1:
    执行代码n-1;
    break;
  default:
    执行代码n;
}
```
###### switch分支的优点
格式良好，性能较好，代码优雅

###### if和switch比较
- if在功能上远远强于switch
- 当前条件是区间时，应该使用if分支结构
- 当条件是与一个一个的值比较时，switch分支更合适

###### 使用switch分支的注意事项
- 表达式类型只能是byte、short、int、char，JDK5开始支持enum（枚举），JDK7开始支持String，但是不支持double、float、long（浮点数计算不精确，无法等于；long占字节数太长，使用case太消耗内存）
- case给出的值不允许重复，且只能是字面量，不能是变量
- 正常使用switch时，不要忘记写break，否则会出现穿透现象 


**switch穿透性在有些情况下可以简化代码**  
**当存在多个case分支的代码相同时，可以把相同的代码放到一个case块中，其他的case块都通过穿透性穿透到该case块执行代码即可，这样可以简化代码**


### 循环结构
```Ctrl+alt+T```快速添加循环语句
#### for循环
###### 格式
```
for(初始化语句;循环语句;迭代语句){
        循环体语句;
}
```
###### for循环的优点
减少代码重复编写，灵活控制程序的执行

###### for循环的常见应用场景
- 批量生产数据

#### while循环
###### 格式
```
while(循环条件){
    循环体语句(被重复执行的代码);
    迭代语句;
}
```
###### for与while的区别
- 功能上完全一样，for能解决的，while也能解决，反之亦然
- 使用规范：知道循环几次时使用for；不知道循环几次时使用while

#### do-while循环
###### 格式
do{
    循环体语句(被重复执行的代码);
    迭代语句;
}while(循环条件)

###### 特点
先执行，后判断

#### 死循环
可以一直执行下去的一种循环，如果没有干预，不会停下来

###### 格式
####### ```for```
```
for(;;){
        循环体语句;
}
```
####### ```while```
```
while(true){
    循环体语句(被重复执行的代码);
    迭代语句;
}
```
####### ```do...while```
```
do{
    循环体语句(被重复执行的代码);
    迭代语句;
}while(true)
```
###### 应用场景
- 服务器程序

#### 循环嵌套
循环中又包含循环
###### 循环嵌套的特点
外部循环每循环一次，内部循环会全部执行完一轮

#### 跳转关键字
###### ```break```
用于跳出并结束当前所在循环的执行  
**只能用于结束所在循环，或者结束所在switch分支的执行**
###### ```continue```
用于跳出当前循环的当次执行，直接进入循环的下一次执行  
**只能在循环中使用**



## API
Application Programming Interface（应用程序编程接口）  
Java写好的程序，供程序员直接调用。Java为API提供了相应的程序使用说明书（API文档）

JDK->JRE->JVM和程序（API）

### ```Scanner```
#### 功能
用来接收用户键盘输入的数据
#### 使用方法
使用Scanner接收用户键盘输入的数据，需要3个步骤：
1. 导包  
告诉程序去JDK的哪个包中找扫描器
```
import java.util.Scanner;
```
2. 抄代码  
代表得到键盘扫描器对象
```
Scanner sc= new Scanner (System.in);
```
3. 抄代码  
等待接收用户输入数据
```
int age = sc.nextInt();
String name = sc.next();
```
**注意：**
- **System、String在JDK中的Java.lang包下**
- **lang包不需要我们导包，是默认的包**


### Random
#### 功能
用于生成伪随机数流，该类使用48位种子，使用线性同余公式进行修改
#### 使用方法
1. 导包  
告诉程序去JDK的哪个包中找扫描器
```
import java.util.Random;
```
2. 抄代码  
代表得到随机数流对象
```
Random r= new Random ();
```
3. 抄代码  
等待接收用户输入数据
```
int num = r.nextInt(数字);
```
**注意：**  
```nextInt(n)```**功能只能生成：0至n-1之间的随机数，不包含n**



## 数组
数组就是一个容器，用来存储一批同种类型的数据
### 静态初始化数组
定义数组时直接给数组赋值
#### 格式
完整格式
```
数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3,...};
int[] ages=new int[]{12,24,36}
```
简化格式
```
数据类型[] 数组名 = {元素1,元素2,元素3,...};
int[] ages = {12,24,36};
```
**注意**  
- ```数据类型[] 数组名``` **也可以写成** ```数据类型 数组名[]```
- **什么类型的数组只能存放什么类型的数据**

### 数组在计算机中的基本原理
数组变量名中存储的是数组在内存中的地址，数组是一种引用数据类型

### 数组的访问
```
数组名[索引]
```
### 查询数组的长度
```
数组名.length
```
### 数组最大索引
```
数组名.length - 1 // 前提：元素个数大于0
```

**注意：如果访问数组时，使用的索引超过了数组最大索引，执行程序会出bug，出现一个索引越界的异常提示**

### 数组的遍历
遍历就是一个一个数据的访问

### 动态初始化数组
#### 格式
```
数据类型[] 数组名 = new 数据类型[长度];
int[] arr = new int[3];
```
**注意：静态初始化和动态初始化数组的写法是独立的，不可以混用**

#### 动态初始化数组元素默认值规则
- 基本类型  
  - ```byte```、```short```、```char```、```int```、```long```默认值为```0```
  - ```float```、```double```默认值为```0.0```
  - ```boolean```默认值为```false```
- 引用类型  
  - ```classs```、```interface```、```array```、```String```默认值为```null```

### 两种数组定义方法的适用场景
- 动态初始化  
适合一开始不确定元素值，只知道元素个数的业务场景
- 静态初始化  
适合一开始就知道要存入哪些元素值的业务场景

### 数组在计算机中的执行原理
#### Java内存分配
- 方法区  
存放class文件，字节码文件先加载到这里
- 栈  
方法运行时所进入的内存，变量也是在这里
- 堆  
new出来的对象会再这里开辟空间并产生地址
- 本地方法栈
- 寄存器

#### 多个变量指向同一数组
原理是多个变量存储相同的数组在内存中的地址

#### 使用数组时常见问题
如果某个数组变量存储的地址是null，那么该变量将不再指向任何数组对象


## Debug工具
IDEA自带的断点调试工具，可以控制代码从断点开始一行一行的执行，然后详细观看程序执行的情况
### 使用步骤
#### 第1步
在需要控制的代码行左侧，点击一下，形成断点
#### 第2步
选择使用Debug方式启动程序，启动后程序会在断点暂停
#### 第3步
控制代码一行一行地往下执行

## 方法
方法是一种语法结构，它可以把一段代码封装成一个功能，以便重复调用
### 方法的完整格式
```
修饰符 返回值类型 方法名(形参列表){
    方法体代码(需要执行的功能代码)
    return 返回值;
}
```
### 方法定义时的几个注意点
- 方法的修饰符：```public``` ```static```
- 方法申明了具体的返回值类型，内部必须使用return返回对应类型的数据
- 形参列表可以有多个，甚至可以没有；如果有多个形参，多个形参之间必须用 ```,``` 隔开，且不能给初始化值

### 方法的注意事项
#### 方法定义时，需要按照方法解决的实际业务需求，来设计合理的方法形式解决问题
- 方法是否需要接收数据处理？
即是否需要定义形参列表
- 方法是否需要返回数据？
即是否需要声明具体的返回值类型
- 方法要处理的业务

##### 注意事项
- 如果方法不需要返回数据，返回值类型必须申明成```void```，此时方法内部不可以使用```return```返回数据
- 如果方法不需要接收数据，则不需要定义形参，且调用方法时也不可以传数据给方法
- 没有参数，且没有返回值类型```void```申明的方法，称为无参数、无返回值的方法，以此类推

###### 常见问题
- 方法在类中的位置放前放后无所谓，但一个方法不能定义在另一个方法里
- 方法的返回值类型写```void```（无返回申明）时，方法内不能使用```return```返回数据，如果方法的返回值类型写了具体类型，方法内部则必须使用```return```返回对应类型的数据
- ```return```语句的下面，不能编写代码，属于无效代码，无法执行
- 方法不调用就不会执行，调用方法时，传给方法的数据，必须严格匹配方法的参数情况
- 调用有返回值的方法，有3种方式：
  1. 可以定义变量接收结果；
  2. 直接输出调用；
  3. 直接调用
- 调用无返回值的方法只能直接调用


### 方法在计算机中的执行原理
方法被调用时，是进入到栈内存中运行的（先进后出）

栈内存的先进后出特性可以保证一个方法调用完另一个方法后，还可以回来

### Java方法参数传递机制
Java的参数传递机制都是值传递
#### 值传递
在传输实参给方法的形参时，传输的是实参变量中存储的值的副本
#### 实参
在方法内部定义的变量
#### 形参
定义方法时形参列表中所声明的参数
### 基本类型的参数传递
### 引用类型的参数传递
### 基本类型和引用类型的参数在传递时有什么相同点和不同点
- 相同点  
都是值传递
- 不同点  
基本类型的参数传输存储的是数据值；  
引用类型的参数传输存储的是地址


### 方法重载
一个类中，出现多个方法的名称相同，但是它们的形参列表不同，这些方法称为方法重载
#### 方法重载的优点
方法名相同标记是同一个功能，可读性好。形参列表不同，体现功能的差异化，让方法设计专业合理，还可以提高开发效率
#### 注意事项
- 一个类中，只要一些方法的名称相同，形参列表不同，那么它们就是方法重载了，其他的都不用考虑（如：修饰符、返回值类型是否一样都不需要考虑）
- 形参列表不同指的是：形参的个数、类型、顺序不同，不关心形参的名称

### return关键字
return关键字可以单独用在无返回值的方法中，作用是立即跳出并结束当前方法的执行


# 进阶
## 面向对象编程
开发对象，把数据交给对象，再调用对象的方法来完成对数据的处理
更符合人类思维习惯，编程也会更加直观
### 类
#### 格式
```
public class 类名{
   1.变量，用来说明对象可以处理什么数据
   2.方法，描述对象有什么功能，可以对数据进行什么样的处理
   ...
}
```

### 对象
万物皆对象，谁的数据谁处理  
对象是类的具体的实例  
对象```object```本质上是一种特殊的数据结构  
类```class```可以看作是对象的模板
#### 对象在计算机中的执行原理
- ```Student s1 = new Student();```
- 每次```new Student()```，就是在堆内存中开辟一块内存区域代表一个学生对象
- ```s1```变量里面记录的是学生对象的地址

#### 引用类型的变量
如果一个变量中存储的是对象地址，这个变量就是引用类型变量

#### 类和对象的注意事项
- 类名建议用英文单词，首字母大写，满足驼峰模式，且要有意义
- 类中定义的变量也称为成员变量（对象的属性），类中定义的方法也称为成员方法（对象的行为）
- 成员变量本身存在默认值，在定义成员变量时一般不需要赋初值
- 一个代码文件中，可以写多个class类，但只能用一个public修饰，且public修饰的类名必须成为代码文件名
- 对象与对象之间的数据不会互相影响，但多个变量指向同一个对象时就会互相影响
- 如果某个对象没有一个变量引用它，则该对象无法被操作，会成为所谓的垃圾对象。Java存在自动垃圾回收机制，会自动清除掉垃圾对象，不需要程序员手动操作


### this
#### 定义
```this```是一个变量，可以用在方法中，来获取当前对象
#### 应用场景
```this```主要用来解决变量名称冲突问题

### 构造器
```Ctrl+P```可以调出构造器可用的参数列表
#### 格式
```
public class 类名 {
       public Student(){
              ...
       }

}
```
#### 特点
创建对象时，对象会自动调用构造器
#### 应用场景
创建对象时，同时完成对对象成员变量（属性）的初始化赋值
#### 注意事项
- 类在设计时，如果不写构造器，Java会为类自动生成一个无参构造器
- 一旦定义了有参构造器，Java就不会自动生成无参构造器了，需要自己手写一个无参构造器

### 封装
面向对象三大特征：封装、继承、多态
#### 封装定义
用类设计对象处理某一个事物的数据时，应该把要处理的数据，以及处理这些数据的方法，设计到一个对象中
#### 封装的设计规范
合理隐藏，合理暴露

### 实体JavaBean（实体类）
#### 实体类定义
是一种特殊形式的类，用来存取数据
- 这个类中的成员变量都要私有，且要对外提供相应的```getter```和```settter```方法，除此之外，没有别的方法
- 类中必须要有一个公共的无参的构造器
##### 实体类特点
仅仅只是一个用来保存数据的java类，可以用它创建对象，保存某个事物的数据
##### 实体类应用场景
实体类只负责数据存取，而对数据的处理交给其他类来完成，以实现数据和数据业务处理相分离


### 成员变量与局部变量的区别
- 类中位置不同
  - 成员变量在类中，方法外
  - 局部变量常见于方法中
- 初始化值不同
  - 成员变量有默认值，不需要初始化赋值
  - 局部变量没有默认值，使用之前必须完成赋值
- 内存位置不同
  - 成员变量在堆内存中
  - 局部变量在栈内存中
- 作用域不同
  - 成员变量作用域是整个对象
  - 局部变量作用域在所归属的大括号中
- 生命周期不同
  - 成员变量与对象共存亡
  - 局部变量随着方法的调用而生，随着方法的运行结束而亡


## API
Application Programming Interface 应用程序编程接口  
不要重复造轮子
### 包（Package）
包是分门别类管理各种不同的程序的，类似于文件夹，建包有利于程序的管理和维护
#### 建包的语法格式
```
package com.Smiler.javabean;
public class Student{
}
```
**在Idea中是先建包，再创建类，因此不需要写代码来建包**

#### 在自己程序中调用其他包下的程序的注意事项
- 如果当前程序中，要调用自己所在包下的其他程序，可以直接调用（同一个包下的类，互相可以直接调用）
- 如果当前程序中，要调用其他包下的程序，则必须在当前程序中导包，才可以访问，导包格式：```import 包名.类名;```
- 如果当前程序中，要调用java提供的程序，也需要先导包才可以使用，但是```Java.lang```包下的程序不需要导包，可以直接使用
- 如果当前程序中，要调用多个不同包下的程序，而这些程序名正好一样，此时默认只能导入一个程序，另一个程序必须带包名访问

### String
#### 创建String对象封装字符串数据的方式
##### 方式1
java程序中的所有字符串文字都为此类的对象  
语法：
```
String 对象名 = "字符串内容";
```
##### 方式2
new String类，调用String类的构造器初始化字符串对象
```
public String()
```
创建一个空白字符串对象，不含有任何内容
```
public String(String original)
```
根据传入的字符串内容，来创建字符串对象
```
public String(char[] chars)
```
根据字符数组的内容，来创建字符串对象
```
public String(byte[] bytes)
```
根据字节数组的内容，来创建字符串对象

#### String提供的操作字符串数据的常用方法
```
public int length()
```
获取字符串的长度返回（即字符个数）
```
public char charAt(int index)
```
获取某个索引位置处的字符返回
```
public char[] toCharArray():
```
将当前字符串转换成字符数组返回
```
public boolean equals(Object anObject)
```
判断当前字符串与另一个字符串的内容是否一样，一样返回```true```
```
public String equalsIgnoreCase(String anotherString)
```
判断当前字符串与另一个字符串的内容是否一样（忽略大小写）
```
public String substring(int beginIndex, int endIndex)
```
根据开始和结束索引进行截取，截取到末尾，得到新的字符串
```
public String substring(int beginIndex)
```
从传入的索引处开始，截取到末尾，得到新的字符串
```
public String replace(CharSequence target, CharSequence replacement)
```
使用新值，将字符串中的旧值替换，得到新的字符串
```
public boolean contains(CharSequence s)
```
判断字符串是否包含了某个字符串
```
public boolean startsWith(String prefix)
```
判断字符串是否以某个字符串内容开头，是则返回true
```
public String[] split(String regex)
```
把字符串按照某个字符串内容分割，并返回字符串数组回来

#### String使用时的注意事项
- ```String```对象的内容不可改变，被称为不可变字符串对象

**每次试图改变字符串对象，实际上是产生了新的字符串对象，变量每次都是指向了新的字符串对象，之前的字符串对象的内容并没有改变，因此说String对象的内容是不可变的**

- 只要是以```...```方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份。但是通过```new```方式创建的字符串对象，每```new```一次都会产生一个新的对象放在堆内存中

**Java这样设计是为了节约内存**

**Java存在编译优化机制，程序在编译时，```"a"+"b"+"c"```会直接转成```"abc"```，以提高程序的执行性能**

### ArrayList
```ArrayList<E>```是用的最多、最常见的一种集合
#### 集合
集合是一种容器，用来装数据，类似于数组
##### 集合的用途
数组定义完成并启动后，长度就固定了。而集合大小可变，开发中用的更多
##### 集合的种类
Java提供的集合种类非常多，最常用的是```ArrayList```

#### 泛型
```
ArrayList<E>
```
约束集合在编译阶段只能操作某种数据类型  
只支持非基本类型的数据  
集合都支持泛型  
**集合和泛型都不支持基本数据类型，只能支持引用数据类型**

*如果什么类型都存*
```
ArrayList list = new ArrayList();
```
*或更规范的书写格式*
```
ArrayList<Object> list = new ArrayList();
```



#### 构造器
```
public ArrayList()
```
创建一个空的集合对象

##### 语法
```
Arraylist<数据类型>list = new ArrayList<>();
```
- 等号右边<>里数据类型一般省略
- 如果不加数据类型，什么数据都可以添加进去


#### 常用方法
```
public boolean add(E e)
```
将指定的元素添加到此集合的末尾
```
public void add(int index,E element)
```
在此集合中的指定位置插入指定的元素
```
public E get(int index)
```
返回指定索引处的元素
```
public int size()
```
返回集合中的元素的个数
```
public E remove(int index)
```
删除指定索引处的元素，返回被删除的元素
```
public boolean remove(Object o)
```
删除指定的元素，返回删除是否成功
```
public E set(int index,E element)
```
修改指定索引处的元素，返回被修改的元素




## static
静态，可以修饰成员变量、成员方法
### 成员变量
#### 类变量
有static修饰，属于类，在计算机里只有一份，会被类的全部对象共享
##### 类变量的访问  
```类名.类变量```
##### 类变量的执行原理
类变量属于类，与类一起加载一次，在内存中只有一份，可以被类和类的所有对象共享
##### 类变量的应用场景
在开发中，如果某个数据只需要一份，且希望能够被共享（访问、修改），则该数据可以定义成类变量

**类变量一般都设为```public```，为的是让外部访问和共享**


#### 实例变量（对象的变量）
无```static```修饰，属于每个对象
##### 实例变量的访问
```对象.实例变量```
##### 实例变量的执行原理
属于对象，每个对象中都有一份，只能用对象访问

### 成员方法
#### 类方法（静态方法）
有```static```修饰的成员方法，属于类
##### 类方法的访问
```类名.类方法```
##### 类方法的应用场景
类方法最常见的应用场景是做工具类

##### 使用类方法来设计工具类的优点
- 提高代码复用
- 调用方便，提高了开发效率

##### 为什么工具类中的方法要用类方法，而不用实例方法
- 实例方法需要创建对象来调用，此时对象只是为了调用方法，对象要占用内存，这样会浪费内存
- 类方法，直接用类名调用即可，调用方便，也能节省内存

*工具类没有创建对象的需求，一般将工具类的构造器进行私有*

#### 实例方法（对象的方法）
无```static```修饰的成员方法，属于对象
##### 实例方法的访问
```对象.实例方法```

##### 使用类方法和实例方法时的注意事项
- 类方法中可以直接访问类的成员，不可以直接访问实例成员
- 实例方法中既可以直接访问类成员，也可以直接访问实例成员
- 实例方法中可以出现```this```关键字，类方法中不可以出现```this```关键字


### 代码块
代码块是类的5大成分之一
- 成员变量
- 构造器
- 方法
- 代码块
- 内部类
#### 代码块分类
##### 静态代码块
###### 格式
```
static{}
```
###### 特点
类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次
###### 作用
完成类的初始化，例如：对类变量的初始化赋值
##### 实例代码块
###### 格式
```
{}
```
###### 特点
每次创建对象时，执行示例代码块，且它的执行在构造器前
###### 作用
和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值

### 单例设计模式
确保一个类只有一个对象
#### 写法
- 把类的构造器私有
- 定义一个类变量记住类的一个对象
- 定义一个类方法，返回对象
#### 类型
##### 饿汉式单例
在获取类的对象时，对象已经创建好了
##### 懒汉式单例
在第一次使用对象时，才开始创建对象
#### 优点
避免浪费内存


## 继承
Java中提供了一个关键字extends，用这个关键字，可以让一个类和另一个类建立起父子关系
### 基础知识
#### 格式
```
public class B extends A{

}
```
#### 特点
- 子类能继承父类的非私有成员（成员变量，成员方法）
- 子类的对象是由子类和父类共同完成的

#### 优点
减少重复代码的编写

### 权限修饰符
用来限制类中的成员（成员变量、成员方法、构造器、代码块...）能够被访问的范围
#### public
```public```
在任意包下的任意类里均可访问
#### private
```private```
仅能在本类中访问
#### protected
```protected```
可以在本类中、同一个包下的其他类里和任意包下的子类里访问
**注意是在任意包下的子类里访问，在其他类里创建的子类对象无法访问**
#### 缺省
即不写权限修饰符  
可以在本类中和同一个包下的其他类中访问

### 权限大小
```private``` < 缺省 < ```protected``` < ```public```

### 单继承
Java是单继承的，Java中的类不支持多继承，但是支持多层继承

### Object类
```Object```类是Java所有类的祖宗类。我们写的任何一个类，都是```object```的子类或子孙类

### 方法重写
父类的方法无法满足子类的需求时，子类可以重写一个方法名相同、参数列表相同的方法，去覆盖父类的方法，这就是方法重写

快捷键```Alt+Enter```

**注意：
方法重写后，Java对方法的访问会遵循就近原则**

#### 方法重写的注意事项
- 重写小技巧
使用Override注解（格式 @Override），可以指定Java编译器，检查方法重写的格式是否正确，代码可读性也会更好
- 子类重写父类方法时，访问权限必须大于或者等于父类该方法的权限（public > protected > 缺省）
- 重写的方法返回值类型，必须与被重写方法的返回值类型一样，或者范围更小
- 私有方法、静态方法不能被重写

#### 方法重写的常见应用场景
子类重写```Object```类的```toString()```方法，以便返回对象的内容

toString()可以返回对象地址  
**直接打印对象名，输出的是对象地址，本质上是调用了```toString()```方法**

*可以在类中重写```toString()```方法，返回对象内容*

#### 子类中访问其他成员
##### 在子类中访问其他成员（成员变量、成员方法），是依照就近原则的
- 先在子类局部范围查找
- 然后在子类成员范围查找
- 然后在父类成员范围查找，如果父类范围还没有找到则报错


##### 如果在子类和父类中，出现了重名的成员，会优先使用子类的
- 访问子类的成员可以用```this```
- 指定访问父类的成员可以用```super```

#### 子类构造器
- 子类的全部构造器，都会先调用父类的无参构造器，再执行自己

原因是在子类构造器的第一行会有一个默认存在的```super()```，来调用父类的无参构造


**注意：
如果父类没有无参构造器（例如手写了有参构造而没有写无参构造），子类中的所有构造器都会报错。此时可以在子类的构造器中添加```super(父类有参构造器的传入参数)```，指定去调用父类的有参构造器**

#### ```this(...)```调用兄弟构造器
任意类的构造器中，都可以通过```this(...)```调用该类的其他构造器，这样可以在传入参数数量不同时避免重复代码

```this()```和```super()```都只能放在第一行，而且不能同时出现


## 多态（polymorphism）
多态是在继承/实现情况下的一种现象，表现为：对象多态、行为多态
### 多态概念
#### 多态的前提
有继承/实现关系；存在父类引用子类对象；存在方法重写

**注意：
多态是对象、行为的多态，Java中的属性（成员变量）不谈多态**

#### 多态的好处
- 在多态形式下，右边对象是解耦合的，更便于扩展和维护
- 使用父类类型的变量作为方法的形参时，可以接收一切子类对象


#### 多态存在的问题
多态下不能直接调用子类的独有方法（使用多态下的类型转换来解决）

### 多态的类型转换
### 自动类型转换
```
父类 变量名 = new 子类();
```
### 强制类型转换
```
子类 变量名 = (子类)父类变量
```
### 强制类型转换的注意事项
- 存在继承/实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错
- 运行时，如果发现对象的真实类型与强转后的类型不同，就会报类型转换异常(ClassCastException)的错误

**强转前，Java建议：
使用```instanceof```关键字，来判断当前对象的真实类型，再进行强转**
```
变量名 instanceof 子类名
```
会返回一个布尔值，在强转之前先通过布尔值判断

### final关键字
可以修饰类、方法、变量
#### 最终类
```final```修饰类，该类被称为最终类，特点是不能被继承了
#### 最终方法
```final```修饰方法，该方法被称为最终方法，特点是不能被重写了
#### 修饰变量
```final```修饰变量，该变量只能被赋值一次

**Java变量只有局部变量和成员变量2种，没有全局变量** 

**成员变量分为静态成员变量和实例成员变量**


**```public``` ```static``` ```final```修饰的成员变量，通常名称全部大写，多个单词下划线连接**

##### final修饰变量的注意事项
- ```final```修饰基本类型的变量，变量存储的数据不能被改变
- ```final```修饰引用类型的变量，变量存储的地址不能被改变，但地址所指向对象的内容是可以被改变的

### 常量
使用```static``` ```final```修饰的成员变量被称为常量
#### 作用
通常用于记录系统的配置信息
#### 命名规范
使用大写英文单词，多个单词使用下划线连接
#### 优点
可读性更好，可维护性也更好
#### 执行原理
程序编译后，常量会被“宏替换”，即出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接使用字面量的性能是一样的

## 抽象类
在Java中有一个关键字：```abstract```，可以用它修饰类、成员方法

```abstract```修饰类，这个类就是抽象类；修饰方法，这个方法就是抽象方法。抽象方法只有方法声明，没有方法实现

### 抽象类的特点
- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
- 类该有的成员（成员变量、方法、构造器），抽象类都可以有
- 抽象类最主要特点
抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现
- 一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类

### 抽象类的应用场景
父类知道每个子类都要做某个行为，但是每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现。设计这样的抽象类，就是为了更好的支持多态

#### 模板方法设计模式
##### 模板方法设计模式解决的问题
解决方法中存在重复代码的问题

##### 模板方法设计模式的写法
定义一个抽象类，在抽象类中定义2个方法
- 一个是模板方法，把相同代码放进去
- 一个是抽象方法，具体实现交给子类完成

**一般要使用```final```关键字修饰模板方法。因为模板方法是给对象直接使用的，不能被子类重写。一旦子类重写了模板方法，模板方法就失效了**


## 接口
### 概念
Java提供了一个关键字```interface```，用这个关键字可以定义出一个特殊的结构：接口
#### 格式
```
public interface 接口名{
     成员变量(默认就是常量，注意变量名要大写，不需要加public static);
     成员方法(默认就是抽象方法，不需要加public abstract);

}
```
**接口中不能有构造器和代码块**

### 实现类
接口不能创建对象；接口是用来被类实现```implements```的，实现接口的类称为实现类
#### 格式
```
修饰符 class 实现类 implements 接口1,接口2,接口3,...{

}
```
一个类可以实现多个接口。实现类实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义成抽象类

### 接口的优点
- 弥补了类单继承的不足，一个类可以同时实现多个接口
- 让程序可以面向接口编程，可以灵活方便的切换各种业务实现

### JDK8新增的3种接口用法
这3种用法增强了接口的能力，更便于项目的扩展和维护
#### 默认方法
使用```default```修饰，默认会被```public```修饰。它属于实例方法，必须使用实现类的对象来访问
##### 格式
```
default 返回值类型 函数名(){
   函数实现
}
```

#### 私有方法
使用```private```修饰（JDK9开始支持）。它属于实例方法，但是实现类的对象无法直接访问，一般是在接口的其他方法中调用

#### 静态方法
使用```static```修饰，默认会被```public```修饰，可以直接使用```接口.函数名```调用

### 接口的多继承
一个接口可以同时继承多个接口

通过多继承，可以把多个接口合成一个接口，便于实现类去实现

### 接口的注意事项
- 一个接口继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承
- 一个类实现多个接口，如果多个接口中存在方法签名冲突，则此时不支持多实现
- 一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会优先用父类的
- 一个类实现了多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可

### 标记接口
如果一个接口里什么也没有，那么它就是一个标记接口。它是一种规则，即如果一个类实现了这个接口，那么这个类就遵循了这个规则，获得了一种能力，例如实现```Cloneable```可以让类获得克隆能力

## 内部类
### 概念
内部类是类中的五大成分之一
- 成员变量
- 方法
- 构造器
- 内部类
- 代码块 

如果一个类定义在另一个类内部，这个类就是内部类

### 使用场景
当一个类的内部，包含了一个完整的事物，且这个事物没必要单独设计时，就可以把这个事物设计成内部类

### 4种形式
#### 成员内部类
是类中的一个普通成员，类似普通的成员变量、成员方法
##### 语法
定义格式
```
class Outer{
    class Inner{

   }
}
```
创建对象格式
```
Outer.Inner in = new Outer().new Inner();
```

**JDK16开始，成员内部类支持定义静态成员**
```
Outer.this
```
通过```Outer.this```可以获取到外部类的成员

##### 成员内部类特点
- 成员内部类的实例方法中，可以直接访问外部类的实例成员和静态成员
- 可以在成员内部类的实例方法中，拿到当前外部类对象，格式是：```外部类名.this```

#### 静态内部类
有static修饰的内部类，属于外部类自己持有
##### 语法
定义格式
```
class Outer{
    static class Inner{

   }
}
```
创建对象格式
```
Outer.Inner in = new Outer.Inner();
```
##### 静态内部类特点
- 可以直接访问外部类的静态成员，不可以直接访问外部类的实例成员
**使用时类比静态成员方法的用法**

#### 局部内部类
局部内部类是定义在类内的方法中、代码块中、构造器等执行体中

局部内部类实际用途不大

#### 匿名内部类（最重要的内部类）
是一种特殊的局部内部类；程序员不需要为这个类声明名字
##### 语法
定义格式
```
new 类或接口(参数值...){
   类题（一般是方法重写）;
};
```
##### 特点
匿名内部类的本质就是一个子类，并会立即创建出一个子类对象
##### 作用
用于更方便的创建一个子类对象

##### 使用场景
通常作为一个参数传输给方法

## 枚举
枚举是一种特殊的类
### 格式
```
修饰符 enum 枚举类名{
    名称1,名称2,...;
    其他成员...
}
```
**注意**：
- 枚举类中的第一行，只能写一些合法的标识符（名称），多个名称用逗号隔开
- 这些名称，本质是常量，每个常量都会记住枚举类的一个对象

### 特点
- 枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量记住的都是枚举类的一个对象
- 枚举类的构造器都是私有的（写不写都只能是私有的），因此，枚举类对外不能创建对象
- 枚举都是最终类，不可以被继承
- 枚举类中，从第二行开始，可以定义类的其他各种成员
- 编译器为枚举类新增了几个方法，并且枚举类都是继承自```java.lang.Enum```类的，从```enum```类也会继承到一些方法


### 抽象枚举类
枚举中包含```abstract```修饰的方法。他需要第一行的枚举对象来实现抽象方法
#### 格式
```
public enum E{
  X(){
     @Override
     public void func(){
     
     }
  },Y(){
     @Override
     public void func(){
     
     }
  };

  public abstract void func();

}
```
*使用枚举实现单例模式*
```
public enum Single{
   X;
}
```
### 枚举的应用场景
- 用来表示一组信息，然后作为参数进行传输
选择定义一个一个的常量来表示一组信息，并作为参数传输
- 参数值不受约束
选择定义枚举表示一组信息，并作为参数传输
- 代码可读性好，参数值得到了约束，对使用者更友好


## 泛型
定义类、接口、方法时，同时声明一个或多个类型变量（如：<E>），称为泛型类、泛型接口、泛型方法，它们统称为泛型
### 作用
泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力。这样可以避免强制类型转换，及其可能出现的异常
### 泛型的本质
把具体的数据类型作为参数传给类型变量

### 泛型类
#### 格式
```
修饰符 class 类名<类型变量,类型变量,...>{

}

public class ArrayList<E>{
  ...
}
```


### 泛型接口
#### 格式
```
修饰符 interface 接口名<类型变量,类型变量,...>{

}

public interface A<E>{
   ...
}
```
**注意：类型变量建议用大写的英文字母，常用的有：```E```、```T```、```K```、```V```等**


### 泛型方法
#### 格式
```
修饰符 <类型变量,类型变量,...> 返回值类型 方法名(形参列表){

}

public static <T> void func(T t){

}
```
### 泛型的通配符
```? ```表示通配符，在使用泛型时可以代表一切类型（```E``` ```T``` ```K``` ```V```是在定义泛型时使用）
#### 格式
```
<?>
```
通配符也可以限定为继承自某个类
```
- <? extends class1>
```
也叫作泛型上限，只能接收```class1```及其子类
```
- <? super class1>
```
也叫作下限，只能接收```class1```及其父类


### 泛型的擦除问题和注意事项
- 泛型是工作在编译阶段的，一旦程序编译成```class```文件，```class```文件中就不存在泛型了，这就是泛型擦除

- 泛型不支持基本数据类型，只能支持对象类型（引用数据类型）


## API
### 概念
API（Application Programming interface）应用程序编程接口
就是Java已经写好的一些程序，如：类、方法等，直接拿来用就可以解决一些问题

### Object类
#### 作用
```Object```类是Java中所有类的祖宗类，因此，Java中所有类的对象都可以直接使用```Object```类中提供的一些方法
#### Object类的常见方法
##### toString()
###### 语法
```
public String toString()
```
###### 用法
返回对象的字符串表示形式， ```toString()```方法可以省略不写，默认只输入对象名就是调用```toString()```
```toString()```方法一般是供重写的，来返回对象的内容
###### 意义
```toString()```方法存在的意义就是为了被子类重写，以便返回对象具体的内容
##### equals
###### 语法
```
public boolean equals(Object o)
```
###### 用法
判断两个对象是否相等，比较的时两个对象的地址，与```==```功能一样
```equals(Object o)```方法一般是供重写的，来比较对象的内容
###### 意义
直接比较两个对象的地址是否相同，完全可以用```==```替代```equals```，```equals```存在的意义就是为了被子类重写，以便自己来定制比较规则（比如比较对象内容）
##### clone()
对象克隆
###### 语法
```
protected Object clone()
```
###### 用法
当某个对象调用这个方法时，这个方法会复制一个一模一样的新对象返回

需要在类中重写```clone()```方法，因为它的权限是```protected```，不重写外部对象无法调用

类需要实现```Cloneable```接口，这个接口是一个标记接口，没有任何内容，只是让实现此接口的类获得克隆能力

###### 克隆机制
- 浅克隆
拷贝出新对象，与原对象中的数据一模一样（引用类型拷贝的只是地址）
- 深克隆
  - 对象中的基本类型的数据直接拷贝
  - 对象中的字符串数据拷贝的还是地址
  - 对象中如果还包含其他对象（例如数组对象），不会拷贝地址，会创建新对象


### Objects类
#### 作用
```Objects```类是一个工具类，提供了很多操作对象的静态方法
#### Objects类的常见方法
##### equals
```
public static boolean equals(Object a,Object b)
```
先做非空判断，再比较两个对象
###### 优点
```Objects.equals(Object a,Object b)```和```a.equals(b)```功能相同，但是比后者更安全，因为如果```a == null```，```a```对象不存在，```a.equals(b)```会报错

##### isNull
```
public static boolean isNull(Object obj)
```
判断对象是否为```null```，如果是```null```则返回```true```  
原理与```obj == null```相同
##### nonNull
```
- public static boolean nonNull(Object obj)
```
判断对象是否不为```null```，如果不为```null```则返回```true``` 
原理与```obj != null```相同

### 包装类
包装类就是把基本类型的数据包装成对象
#### 基本数据类型和包装类（引用数据类型）的对应
| |  | |
| :---: | :---: |:---: |
|byte|<->|Byte|
|short|<->|Short|
|int|<->|Integer|
|long|<->|Long|
|char|<->|Character|
|float|<->|Float|
|double|<->|Double|
|boolean|<->|Boolean|

#### 基本类型的数据包装成对象的方案
```
public Integer(int value) // 已过时
```
```
public static Integer valueOf(int i)
```
#### 自动机制
##### 自动装箱机制
Java可以自动把基本类型的数据转换成对象
##### 自动拆箱机制
Java可以把包装类型的对象转换成对应的基本数据类型

#### 包装类的用途
泛型和集合不支持基本数据类型，只支持引用数据类型，需要使用包装类

#### 包装类提供的常用方法
##### 把基本类型的数据转换成字符串类型
```
public static String toString(double d)
```
```
public String toString()
```
##### 把字符串类型的数值转换成数值本身对应的数据类型（这个功能在开发中非常重要）
```
public static int parseInt(String s)
```
```
public static Integer valueOf(String s) //这种方法最常用
```
**注意：
传入的数据类型必须和包装类对应，否则会报错**


### StringBuilder
```StringBuilder```代表可变字符串对象，相当于是一个容器，它里面装的字符串是可以改变的，就是用来操作字符串的

#### 优点
- ```StringBuilder```比```String```更适合做字符串的修改操作，比```String```的性能好
- 对于字符串相关的操作，如频繁的拼接、修改等，一般使用```StringBuilder```,效率更高
- 如果操作字符串较少，或者不需要拼接、修改操作。以及定义字符串变量，一般使用```String```

#### 构造器
```
public StringBuilder()
```
创建一个空白的可变的字符串对象，不包含任何内容
```
public StringBuilder(String str)
```
创建一个指定字符串内容的可变字符串对象

#### StringBuilder类提供的常用方法
```
public StringBuiler append(任意类型)
```
添加数据并返回```StringBuilder```对象本身  
```append```方法支持链式编程
```
public StringBuilder reverse()
```
将对象的内容反转
```
public int length()
```
返回对象内容长度
```
public String toString()
```
通过```toString()```可以把```StringBuilder```转换为```String```

### StringBuffer
```StringBuffer```的用法与```StringBuilder```是一模一样的。但是```StringBuilder```是线程不安全的，```StringBuffer```是线程安全的

如果程序是单用户使用，就用```StringBuilder```，如果涉及到多用户，就用```StringBuffer```

### StringJoiner
JDK8开始支持，跟```StringBuilder```一样，也是用来操作字符串的，也可以看做是一个容器，创建之后里面的内容是可变的
#### 优点
不仅能提高字符串的操作效率，并且在有些场景下使用它操作字符串，代码会更简洁

#### 构造器
```
public StringJoiner(间隔符号)
```
创建一个```StringJoiner```对象，指定拼接时的间隔符号
```
public StringJoiner(间隔符号,开始符号,结束符号)
```
创建一个```StringJoiner```对象，指定拼接时的间隔符号、开始符号、结束符号

#### StringJoiner类提供的常用方法
```
public StringJoiner add(添加的内容)
```
添加数据，并返回对象本身
```
public int length()
```
返回长度（字符出现的个数）
```
public String toString()
```
返回一个字符串（该字符串就是拼接后的结果）

### Math
是一个工具类，里面提供的都是对数据进行操作的一些静态方法，包含用于执行基本数字运算的方法
#### Math类提供的常用方法
```
public static int abs(int a)
```
获取参数绝对值
```
public static double ceil(double a)
```
向上取整
```
public static double floor(double a)
```
向下取整
```
public static int round(float a)
```
四舍五入
```
public static int max(int a,int b)
```
获取两个```int```值中的较大值
```
public static double pow(double a,double b)
```
返回a的b次幂的值
```
public static double random()
```
返回值为```double```的随机值，范围[0.0,1.0)

### System
```System```类也是一个工具类，包括:
- 标准输入，标准输出和错误输出流; 
- 访问外部定义的属性和环境变量; 
- 加载文件和库的方法; 
- 以及用于快速复制阵列的一部分的实用方法
#### System类提供的常用方法
```
public static void exit(int status)
```
终止当前运行的Java虚拟机  
传入参数status作为状态代码；按照惯例，非零状态代码表示异常终止  
**一般不要使用这个代码**  



  
```
public static long currentTimeMillis()
```
返回当前系统的时间毫秒值形式

可以用来统计一段程序的运行时间，用作性能分析


### Runtime
代表程序所在的运行环境。```Runtime```是一个单例类。它允许应用程序与运行应用程序的环境进行交互。可以从```getRuntime```方法获得当前运行时  
应用程序无法创建自己的此类实例
#### Runtime类提供的常用方法
```
public static Runtime getRuntime()
```
返回与当前Java应用程序关联的运行时对象
```
public void exit(int status)
```
终止当前运行的虚拟机

*一般不要使用这个代码*

```
public int availableProcessors()
```
返回Java虚拟机可用的处理器数
```
public long totalMemory()
```
返回Java虚拟机汇总的内存总量
```
public long freeMemory()
```
返回Java虚拟机中的可用内存
```
public Process exec(String command)
```
启动某个程序，并返回代表该程序的对象


### BigDecimal
很常用，用于解决浮点型运算时，出现结果失真的问题
#### 构造器
```
public BigDecimal(double val)
```
将```double```转换为```BigDecimal```  
**注意：它并没有解决浮点型运算的精度问题，一般不使用这个构造器**
把```String```转成```BigDecimal```

#### BigDecimal类提供的常用方法
```
public static BigDecimal ValueOf(double val)
```
转换一个```double```成```BigDecimal```
```
public BigDecimal add(BigDecimal b)
```
加法
```
public BigDecimal substract(BigDecimal b)
```
减法
```
public BigDecimal multiply(BigDecimal b)
```
乘法
```
public BigDecimal divide(BigDecimal b)
```
除法，如果结果为无限循环或无限不循环，会报错，例如1.0除以3.0，需要传入精确到几位
```
public BigDecimal divide(BigDecimal b，scale，RoundingMode)
```
除法，可以控制精确到几位小数。```scale```传入一个整数，控制精确多少位小数，```RoundingMode```是一个枚举值，控制舍入模式，使用```RoundingMode.```选择舍入模式

**遇到代码不知道怎么写，可以按Ctrl+Alt+空格，会弹出提示**
```
public double deoubleValue()
```
将```BigDecimal```转换为```double```


### JDK8之前传统的日期和时间
#### Date
系统当前的日期和时间
##### 构造器
```
public Date()
```
创建一个```Date```对象，代表的是系统当前此刻日期时间
```
public Date(long time)
```
把时间毫秒值转换成```Date```日期对象

##### Date的常用方法
```
public long getTime()
```
```
public void setTime(long time)
```
#### SimpleDateFormat
简单日期格式化，可以用来把日期对象、时间毫秒值格式化成需要的形式
##### 常用构造器
```
public SimpleDateFormat(String pattern)
```
创建简单日期格式化对象，并封装时间的格式
```yyyy年MM月dd日 HH时mm分ss秒 EEE星期几 a上午/下午```

##### ```SimpleDateFormat```格式化时间的常用方法
```
public final String format(Date date)
```
将日期格式化成日期/时间字符串
```
public final String format(Object time)
```
将时间毫秒值格式化成日期/时间字符串
```
public Date parse(String source)
```
把字符串时间解析成日期对象，注意字符串时间的格式要和```SimpleDateFormat```对象定义的时间格式相同才能解析成功

#### Calendar
代表系统此刻时间对应的日历  
通过它可以单独获取、修改时间中的年、月、日、时、分、秒等

##### Calendar日历类的常用方法
```
public static Calendar getInstance()
```
获取当前日历对象
```
public int get(int field)
```
获取日历中的某个信息
```
public final Date getTime()
```
获取日期对象
```
public long getTimeInMillis()
```
获取时间毫秒值
```
public void set(int field,int value)
```
修改日历的某个信息
```
public void add(int field,int amount)
```
为某个信息增加/减少指定的值

**注意：```Calendar```是可变对象，一旦修改后其对象本身表示的时间将产生变化**



### JDK8开始新增的日期和时间
#### JDK8之前传统的时间API存在的问题
- 设计不合理，使用不方便，很多都被淘汰了
- 都是可变对象，修改后会丢失最开始的时间信息
- 线程不安全
- 只能精确到毫秒

#### JDK8开始新增的时间API的优点
- 设计更合理，功能丰富，使用更方便
- 都是不可变对象，修改后会返回新的时间对象，不会丢失最开始的时间
- 线程安全
- 能精确到毫秒、纳秒

#### 取代Calendar的API
##### LocalDate
代表本地日期(年、月、日、星期)
获取本地日期对象的方法:
```
public static LocalDate now()
```
获取日期对象中的信息
```
getYear()
 ```
返回年份
```
getMonthValue()
```
返回月份
```
getDayOfMonth()
```
返回日
```
getDayOfYear()
```
返回一年中的第几天
```
getDayOfWeek().getValue()
```
返回星期几


###### 直接修改日期中的某个信息
```LocalDate```是不可变对象，修改后会创建一个新的```LocalDate```对象
```
withYear()
```
修改年份
```
withMonth()
```
修改月份
```
withDayOfMonth()
```
修改日期
```
withDayOfYear()
```
修改在全年的哪一天
###### 把日期对象中的信息加多少
返回的是新的```LocalDate```对象
```
plusYears()
```
增加年份
```
plusMonths()
```
增加月份
```
plusDays()
```
增加天数
```
plusWeeks()
```
增加星期

###### 把日期对象中的信息减多少
返回的是新的```LocalDate```对象
```
minusYears()
```
减少年
```
minusMonths()
```
减少月
```
minusDays()
```
减少天
```
minusWeeks()
```
减少星期

###### 获取指定日期的LocalDate对象
返回的是新的LocalDate对象
```
public static LocalDate of(int year, int month, int dayOfMonth)
```
###### 判断2个日期对象是否相等，在前还是在后
```equals```
判断2个日期是否相等
```isBefore```
判断日期是否在前
```isAfter```
判断日期是否在后

##### LocalTime
代表本地时间(时、分、秒、纳秒)，方法与```LocalDate```基本相同
###### 获取对象的方法
```
public static LocalTime now()
```

##### LocalDateTime
代表本地日期、时间(年、月、日、星期、时、分、秒、纳秒)，包含```LocalDate```和```LocalTime```的所有方法
###### 获取对象的方法
```
public static LocalDateTime now()
```
##### ZoneId
时区，支持洲名/城市名，例如```Asia/Shanghai``` ```America/New_York```
###### 常用方法
```
public static ZoneId systemDefault()
```
获取系统默认的时区
```
public static Set<String> getAvailableZoneIds()
```
获取Java支持的全部时区Id
```
public static ZoneId of(String ZoneId)
```
把某个时区id封装成ZoneId对象

##### ZonedDateTime
带时区的时间
###### 常用方法
```
public static ZoneDateTime now(ZoneId zone)
```
获取某个时区的```ZonedDateTime```对象
```
public static ZonedDateTime now()
```
获取系统默认时区的```ZonedDateTime```对象

#### 取代Date的API
##### Instant
时间戳/时间线上的某个时刻，它是精确到纳秒的  
通过获取```Instant```的对象可以拿到此刻的时间，该时间由两部分组成：从```1970-01-01 00:00:00```开始走到此刻的总秒数+不够1秒的纳秒数
###### 常用方法
```
public static Instant now()
```
获取当前时间的```Instant```对象（标准时间）
```
public long getEpochSecond()
```
获取从```1970-01-01T00:00:00```开始记录的秒数
```
public int get Nano()
```
从时间线开始，获取从第二个开始的纳秒数
```
plusMillis plusSeconds plusNanos
```
增加时间系列的方法
```
minusMillis minusSeconds minusNanos
```
减少时间系列的方法
```
equals isBefore isAfter
```
判断时间系列的方法

###### Instant的用途
因为可以精确到纳秒，所以经常用作代码性能分析，或者用作记录用户的操作时间点

#### 取代SimpleDateFormat的API
##### DateTimeFormatter
用于时间的格式化和解析
###### 常用方法
```
public static DateTimeFormatter ofPattern(时间格式)
```
获取格式化器对象
```
public String format(时间对象)
```
格式化时间

###### ```LocalDateTime```提供的格式化、解析时间的方法
```
public String format(DateTimeFormatter formatter)
```
格式化时间
```
public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)
```
解析时间

### 其他补充的API
#### Period
时间间隔(年,月,日)，可以用于计算两个```LocalDate```对象相差的年数、月数、天数
##### 常用方法
```
public static Period between(LocalDate start, LocalDate end)
```
传入两个日期对象，得到```Period```对象
```
public int getYears()
```
计算间隔几年，并返回
```
public int getMonths()
```
计算间隔几个月，并返回
```
public int getDays()
```
计算间隔几天，并返回

#### Duration
时间间隔(时,分,秒,纳秒)，可以用于计算两个时间对象相差的天数、小时数、分数、秒数、纳秒数，支持```LocalTime```、```LocalDateTime```、```Instant```等时间对象
##### 常用方法
```
public static Duration between(开始时间对象1,截止时间对象2)
```
传入两个时间对象，得到```Duration```对象
```
public long toDays()
```
计算间隔多少天，并返回
```
public long toHours()
```
计算间隔多少小时，并返回
```
public long toMinutes()
```
计算间隔多少分，并返回
```
public long toSeconds()
```
计算间隔多少秒，并返回
```
public long toMillis()
```
计算间隔多少毫秒，并返回
```
public long toNanos()
```
计算间隔多少纳秒，并返回


### Arrays
用来操作数组的一个工具类
#### Arrays类提供的常用方法

- public static String toString(类型[] arr)

返回数组的内容
```
public static int[] copyOfRange(类型[] arr,起始索引,结束索引)
```
拷贝数组（指定范围）
```
public static copyOf(类型[] arr,int newLength)
```
拷贝数组
```
public static setAll(类型[] array,intToDoubleFunction generator)
```
把数组中的原数据改为新数据
```
public static void sort(类型[] arr)
```
对数组进行排序（默认是升序排序）
- 如果数组中存储的是对象，排序规则需要自己制定，有2种方法
  - 方法1：
让该对象的类实现```Comparable```（比较规则）接口，然后重写```compareTo```方法，自己来制定比较规则  
语法格式
```public class Person implements Comparable<Person>```
  - 方法2：
使用下面的sort方法，创建Comparator比较器接口的匿名内部类对象，然后自己制定比较规则
```public static <T> void sort(T[]arr, Comparator<?superT> c) //对数组进行排序（支持自定义排序规则）```

- 自定义排序规则时，需要遵循官方约定：
  - 左边大于右边，返回正整数
  - 左边小于右边，返回负整数
  - 左边等于右边，返回0


## Lambda表达式
### 定义
```Lambda```表达式是JDK8开始新增的一种语法形式；作用是用于简化匿名内部类的代码写法

注意：```Lambda```表达式并不是能简化全部匿名内部类的写法，只能简化函数式接口的匿名内部类

##### 函数式接口
- 一个接口有且只有一个抽象方法
- 大部分函数式接口，上面都可能会有一个```@FunctionalInterface```注解，有该注解的接口必定是函数接口

### 格式
```
(被重写方法的形参列表) -> {
    被重写方法的方法体代码

}
```

### Lambda表达式的省略写法（进一步简化Lambda表达式的写法）
- 参数类型可以省略不写
- 如果只有一个参数，参数类型可以省略，同时```()```也可以省略
- 如果```Lambda```表达式中的方法体代码只有一行，可以省略大括号不写，同时要省略分号。此时，如果这行代码是```return```语句，也必须去掉```return```不写

### 方法引用
进一步简化```Lambda```表达式，方法引用的标志性符号是```::```
#### 静态方法的引用
##### 格式
```
类名::静态方法
```
##### 使用场景
如果某个Lambda表达式里只是调用一个静态方法，且前后参数的形式一致，就可以使用静态方法引用

#### 实例方法的引用
##### 格式
```
对象名::实例方法
```
##### 使用场景
如果某个Lambda表达式里只是调用一个实例方法，且前后参数的形式一致，就可以使用实例方法引用

### 特定类型方法的引用
#### 格式
```
类型::方法
```
#### 使用场景
如果某个Lambda表达式里只是调用一个实例方法，且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，此时就可以使用特定类型的方法引用

### 构造器引用
#### 格式
```
类名::new
```
#### 使用场景
如果某个Lambda表达式里只是在创建对象，并且前后参数情况一致，就可以使用构造器引用


## 算法
解决某个实际问题的过程和方法

算法学习的技巧
- 第1步：搞清楚算法的流程
- 第2步：直接去推敲如何写代码

### 排序算法
#### 冒泡排序
每次从数组中找到最大值，放到数组的最后面去

#### 选择排序
每轮选择当前位置，开始找出后面的较小值与该位置交换

#### 查找算法
##### 基本查找/顺序查找
在数据量特别大的时候，基本查找这种从前往后挨个找的形式，性能是很差的

##### 二分查找/折半查找
前提条件：数组中的数据必须是有序的  
核心思想：每次排除一半的数据

## 正则表达式
### 概念
#### 定义
由一些特定的字符组成，代表的是一个规则

#### 作用
- 用来校验数据格式是否合法
- 在一段文本中查找满足要求的内容
- 搜索替换、分割内容


此功能需要结合```String```提供的下列方法完成
```
public String replaceAll(String regex, String newStr)
```
按照正则表达式匹配的内容进行替换
```
public String[] split(String regex)
```
按照正则表达式匹配的内容进行分割字符串，返回一个字符串数组


### 书写规则
#### 语法格式
```
public boolean matches(String regex)  //判断字符串是否匹配正则表达式，匹配返回true，不匹配返回false
```
#### 字符类（只匹配单个字符）
```
[abc]
```
只能是a，b或者c
```
[^abc]
```
除了a，b，c之外的任何字符
```
[a-zA-Z]
```
a到z，A到Z，包括（范围）
```
[a-d[m-p]]
```
a到d，或m到p
```
[a-z&&[def]]
```
d，e或f（交集）
```
[a-z&&[^bc]]
```
a到z，除了b和c
```
[a-z&&[^m-p]]
```
a到z，不包含m到p

#### 预定义字符（只匹配单个字符）
||||
| :---: | :---: | :---: |
|.|任何字符||
|\d|一个数字，即[0-9]|注意：使用时需要转义，否则会报错，多加一个反斜杠，即\\d|
|\D|非数字，即[^0-9]||
|\s|一个空白字符||
|\S|非空白字符，即[^\s]||
|\w|一个字符，可以是字母或数字，即[a-zA-Z_0-9]||
|\W|一个非单词字符，即[^\w]||
|(?i)|忽略大小写||

###### 数量词
|||
| :---: | :---: |
|X?|X，1次或0次|
|X*|X，0次或多次|
|X+|X，1次或多次|
|X{n}|X，正好n次|
|X{n,}|X，至少n次|
|X{n,m}|X，至少n次，但是不超过m次|


## 异常
### 概念
异常就是代表程序出现的问题
#### 定义
Java会以异常对象的形式告知程序员
### 异常的体系

#### 根父类
```
Java.lang.Throwable
```

#### 子类1：Error
```Error```代表系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成```Error```对象给出来。本质上，```Error```是给sun公司自己使用的，不是给程序员使用的，因此开发人员不用管它
#### 子类2: Exception
异常，代表的是程序可能出现的问题，所以，程序员通常会用```Exception```以及它的子类来封装程序出现的问题
#### RuntimeException
```RuntimeException```及其子类是运行时异常，编译阶段不会出现错误提醒，运行时出现的异常（如：数组索引越界异常）
#### 其他异常
编译时异常：编译阶段就出现错误提醒的（如：日期解析异常）

### 处理异常的方法
#### 抛出异常（throws）
在方法上使用```throws```关键字，可以将方法内部出现的异常抛出去给调用者处理
##### 语法格式
```
方法 throws 异常1,异常2,异常3..{
    ...
}
```
#### 捕获异常（try...catch）
直接捕获程序出现的异常  
##### 语法格式
```
try{
    //监视可能出现异常的代码
}catch(异常类型1 变量){
    //处理异常
}catch(异常类型2 变量){
    //处理异常
}...
```

#### 自定义异常
Java无法为全部问题都提供异常类来代表，如果企业自己的某种问题，想通过异常来表示，以便用异常来管理该问题，就需要自己来定义异常类
##### 自定义运行时异常
- 定义一个异常类继承```RuntimeException```
- 重写构造器
- 通过```throw new 异常类(xxx)```来创建异常对象并抛出
**编译阶段不报错，提醒不强烈，运行时才可能出现**

##### 自定义编译时异常
- 定义一个异常类继承```Exception```
- 重写构造器
- 通过```throw new异常类(xxx)```来创建异常对象并抛出
**编译阶段就报错，提醒更加强烈**

### 异常的用途
- 异常是用来查询系统Bug的关键参考信息的
- 异常可以作为方法内部的一种特殊返回值，以便通知上层调用者底层的执行情况

### 异常的处理
#### 语法
```
throws
```
```
try-catch
```
### 开发中对于异常的常见处理方式
方法异常抛给调用者，最外层捕获异常，记录异常并响应合适的信息给用户或尝试重新修复



## 集合
集合是一种容器，用来装数据的，类似于数组，但集合的大小可变，开发中非常常用
### 集合体系结构
#### Collection<E>
单列集合，每个元素（数据）只包含一个值
##### List接口
```
- List<E>
```
##### List实现类
```
ArrayList<E>
```
```
LinkedList<E>
```
##### Set接口
```
Set<E>
```
##### Set实现类
```
HashSet<E>
```
```
LinkedHashSet<E>
```
```
TreeSet<E>
```
##### Map
双列集合，每个元素包含两个值（键值对）

### Collection
#### Collection集合特点
##### List系列集合特点
添加的元素是有序的、可重复、有索引
##### Set系列集合特点
添加的元素是无序、不重复、无索引
- HashSet  
无序、不重复、无索引
- LinkedHashSet  
有序、不重复、无索引
- TreeSet  
按照大小默认升序排序、不重复、无索引

#### Collection常用方法
```
public boolean add(E e)
```
添加元素，添加成功返回```true```
```
public void clear()
```
清空集合的元素
```
public boolean isEmpty()
```
判断集合是否为空，是空返回```true```
```
public int size()
```
获取集合的大小
```
public boolean contains(Object obj)
```
判断集合中是否包含某个元素
```
public boolean remove(E e)
```
删除某个元素，如果有多个重复元素，默认删除前面的第一个
```
public Object[] toArray()
```
把集合转换成数组
```
public boolean addAll(Collection<? extends E> c)
```
把指定集合中的所有元素添加到此集合中


#### Collection的遍历方式
因为```Collection```没有索引，因此不支持传统```for```循环
##### 迭代器
迭代器是用来遍历集合的专用方式（数组没有迭代器），在Java中迭代器的代表是```Iterator```
###### Collection集合获取迭代器的方法
```
Iterator<E> iterator()
```
返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素

###### Iterator迭代器中的常用方法
```
boolean hasNext()
```
询问当前位置是否有元素存在，存在返回true，不存在返回false
```
E next()
```
获取当前位置的元素，并同时把迭代器对象指向下一个元素处

##### 增强for（forEach遍历）
增强for可以用来遍历集合或数组
###### 语法
```
for (元素的数据类型 变量名:数组或集合){

}
```
增强for遍历集合，本质上就是迭代器遍历集合的简化写法

##### Lambda表达式
Lanbda表达式提供了一种更简单、更直接的方式来遍历集合，Lambda表达式遍历Map时，非常简洁方便

需要使用Collection的如下方法来完成
```
default void forEach(Consumer<? super T> action)
```
结合Lambda遍历集合


### List集合
#### 特点
有序，可重复，有索引
#### 集合体系
##### 接口
```
- List<E>
```
##### 实现类
两个实现类特点相同，但是底层采用的数据结构不同，应用场景不同
```
ArrayList<E>
```
```
LinkedList<E>
```

#### List集合的特有方法
List集合支持索引，因此多了很多与索引相关的方法。同时，List继承了所有Collection的方法
```
void add(int index, E element)
```
在此集合中的指定位置插入指定的元素
```
E remove(int index)
```
删除指定索引处的元素，返回被删除的元素
```
E set(int index, E element)
```
修改指定索引处的元素，返回被修改的元素
```
E get(int index)
```
返回指定索引处的元素

#### List集合支持的遍历方式
- ```for```循环（因为```List```集合有索引）
- 迭代器
- 增强```for```循环（```forEach```遍历）
- ```Lambda```表达式

#### ArrayList
##### 底层原理
基于数组实现的，即顺序表
- 利用无参构造器创建的集合，会在底层创建一个默认长度为0的数组
- 添加第一个元素时，底层会创建一个新的长度为10的数组
- 存满时，会扩容1.5倍
- 如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准
##### 特点
- 查询速度快  
因为是根据索引查询数据，查询数据通过地址值和索引定位，查询任意数据耗时相同
- 删除效率低  
可能需要把后面很多数据进行前移
- 添加效率极低  
可能需要把后面很多的数据后移，再添加元素；或者也可能需要进行数组扩容
##### ArrayList集合适合的应用场景
- ArrayList适合的场景  
根据索引查询数据，比如根据随机索引取数据（高效）。或者数据量不是很大时
- ArrayList不适合的场景  
数据量大的同时，又要频繁的进行增删操作


#### LinkedList
##### 底层原理
基于双链表实现的
- 查询慢，增删相对较快，但对首尾元素进行增删改查的速度是极快的
##### LinkedList新增的方法
LinkedList新增了很多收尾操作的特有方法

- public void addFirst(E e)

在该列表开头插入指定的元素
```
public void addLast(E e)
```
将指定的元素追加到此列表的末尾
```
public E getFirst()
```
返回此列表中的第一个元素
```
public E getLast()
```
返回此列表中的最后一个元素
```
public E removeFirst()
```
从此列表中删除并返回第一个元素
```
public E removeLast()
```
从此列表中删除并返回最后一个元素

##### LinkedList集合的应用场景
- 可以用来设计队列  
先进先出，后进后出
- 可以用来设计栈  
后进先出，先进后出


### Set集合
#### 特点
无序，不重复，无索引，添加数据的顺序和获取出的数据顺序不一致
#### 集合体系
##### 接口
```
Set<E>
```
##### 实现类
```
HashSet<E>
```
无序，不重复，无索引
```
LinkedHashSet<E>
```
有序，不重复，无索引
```
TreeSet<E>
```
排序，不重复，无索引

#### HashSet
无序，不重复，无索引
##### 哈希值
哈希值是一个```int```类型的数值，Java中每个对象都有一个哈希值
Java中的所有对象，都可以调用```Object```类提供的```hashCode```方法，返回该对象自己的哈希值

##### hashCode方法
```
public int hashCode()
```
返回对象的哈希码值

##### 对象哈希值的特点
同一个对象多次调用```hashCode()```方法返回的哈希值是相同的
不同的对象，它们的哈希值一般不相同，但也有可能会相同（哈希碰撞）

##### HashSet的底层原理
基于哈希表实现


##### 哈希表
哈希表是一种增删改查数据，性能都较好的数据结构
- JDK8之前，哈希表=数组+链表  
  - 创建一个默认长度为16的数组，默认加载因子为0.75，数组名table
  - 使用元素的哈希值对数组的长度求余，计算出应存入的位置
  - 判断当前位置是否为null，如果是null直接存入
  - 如果不为null，表示有元素，则调用equals方法比较，如果相等则不存，如果不相等，则存入数组
  - JDK8之前，新元素存入数组，占用老元素位置，老元素挂在下面（链表）
- JDK8开始，哈希表=数组+链表+红黑树
  - 引入红黑树后，进一步提高了哈希表操作数据的性能
  - JDK8开始，当链表长度超过8，且数组长度>=64时，自动将链表转成红黑树


##### 树
###### 二叉树
任一节点的度<=2  
二叉查找树（二叉排序树）  
小的存左边，大的存右边，一样的不存  
*二叉查找树存在的问题：  
当数据已经是有序的，会导致查询的性能与单链表一样，查询速度变慢*
###### 平衡二叉树
在满足查找二叉树的大小规则下，让树尽可能矮小，以此提高查数据的性能
###### 红黑树
可以自平衡的二叉树，是一种增删改查数据性能相对都较好的数据结构

##### HashSet集合的去重复机制
HashSet集合默认不能对内容一样的两个不同对象去重复

如果希望HashSet集合认为2个内容一样的对象是重复的，就必须重写对象的```hashCode()```和```equals()```方法



#### LinkedHashSet
有序，不重复，无索引
##### LinkedHashSet的底层原理
- 基于哈希表（数组、链表、红黑树）实现
- 它的每个元素都额外多了一个双链表的机制记录它前后元素的位置


#### TreeSet
不重复，无索引，可排序（默认升序排序，按照元素的大小，由小到大排序）
##### TreeSet的底层原理
底层是基于红黑树实现的排序
##### TreeSet的注意事项
- 对于数值类型：```Integer```、```Double```，默认按照数值本身的大小进行升序排序
- 对于字符串类型：默认按照首字符的编号升序排序
- 对于自定义类型，TreeSet默认是无法直接排序的
##### 自定义排序规则
TreeSet集合存储自定义类型的对象时，必须指定排序规则，支持如下两种方式来指定比较规则
- 方式1  
让自定义的类实现```Comparable```接口，重写里面的```compareTo```方法来指定比较规则
  - 语法格式
  ```
  public class Person implements Comparable<Person>
  ```
- 方式2  
通过调用```TreeSet```集合的有参构造器，可以设置Comparator对象（比较器对象，用于指定比较规则），创建Comparator比较器接口的匿名内部类对象，然后自己制定比较规则
```
public TreeSet(Comparator<? super E> comparator)
```
**如果类本身有实现Comparable接口，TreeSet集合同时也自带比较器，会默认就近使用集合自带的比较器排序**

### Collection集合总结
#### 集合的选择
- 如果希望记住元素的添加顺序，需要存储重复的元素，又要频繁的根据索引查询数据
使用ArrayList
- 如果希望记住元素的添加顺序，且增删首尾数据的情况较多
使用LinkedArrayList
- 如果不在意元素顺序，也没有重复元素需要存储，只希望增删改查都快
使用HashSet
- 如果希望记住元素的添加顺序，也没有重复元素需要存储，且希望增删改查都快
使用LinkedHashSet
- 如果要对元素进行排序，也没有重复元素需要存储，且希望增删改查都快
使用TreeSet

#### 集合的并发修改异常问题
使用迭代器遍历集合时，又同时在删除集合中的数据，程序就会出现并发修改异常的错误  

使用forEach和Lambda表达式遍历时，无法解决并发修改异常错误。使用迭代器遍历时可以解决，使用迭代器的remove方法，而不是集合的remove方法


#### 可变参数
可变参数就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：数据类型...参数名称;
##### 可变参数的特点和好处
###### 特点
- 可以不传数据给它；
- 可以传一个或者同时传多个数据给它；
- 也可以传一个数组给它
###### 好处
常常用来灵活的接收数据

##### 可变参数的注意事项
- 可变参数在方法内部实际上就是一个数组
- 一个形参列表中，只能有一个可变参数
- 可变参数必须放在形参列表的最后面

#### Collections
是一个用来操作集合的工具类
##### Collections提供的常用静态方法
```
public static <T> boolean addAll(Collection<? super T> c, T... elements)
```
给集合批量添加元素
```
public static void shuffle(List<?> list)
```
打乱List集合中的元素顺序
```
public static <T> void sort(List<T> list)
```
对List集合中的元素进行升序排序
```
public static <T> void sort(List<T> list, Comparator<? super T> c)
```
对List集合中的元素，按照比较器对象指定的规则进行排序


### Map
#### Map集合
##### Map集合概念
- Map集合称为双列集合，格式为```{key1=value1,key2=value2,key3=value3,...}```，一次需要存一对数据作为一个元素
- Map集合的每个元素```key=value```称为一个```键值对/键值对对象/一个Entry对象```，Map集合也被叫做“键值对集合”
- Map集合的所有键是不允许重复的，但值可以重复，键和值是一一对应的，每个键只能找到自己对应的值

##### Map集合适用场景
需要存储一一对应的数据时，就可以考虑使用Map集合来做

##### Map集合体系
###### 接口
```
Map<K,V>
```
###### 实现类
```
HashMap<K,V>
```
无序、不重复、无索引（用的最多）
```
LinkedHashMap<K,V>
```
有序，不重复，无索引
```
TreeMap<K,V>
```
按照大小默认升序排序，不重复，无索引

##### Map集合体系的特点
Map系列集合的特点都是由键决定的，值只是一个附属品，值是不做要求的

##### Map提供的常用方法
```
put(K,key, V value)
```
添加元素
```
public int size()
```
获取集合的大小
```
public void clear()
```
清空集合
```
public boolean isEmpty()
```
判断集合是否为空，为空返回true
```
public v get(object key)
```
根据键获取对应值
```
public v remove(Object key)
```
根据键删除整个元素(删除键会返回键的值)
```
public boolean containsKey(Object key)
```
判断是否包含某个键﹐包含返回true
```
public boolean containsValue(object value)
```
判断是否包含某个值
```
public Set<K> keySet()
```
获取Hap集合的全部键

##### Map集合的遍历方式
###### 键找值
先获取Map集合全部的键，再通过遍历键来找值  
需要用到方法
```
public Set<K> keySet()
```
获取所有键的集合
```
public V get(Object key)
```
根据键获取其对应的值

###### 键值对
把“键值对”看成一个整体进行遍历  
需要用到方法
```
Set<Map.Entry<K,V>> entrySet()
```
获取所有“键值对”的集合

###### Lambda
JDK1.8开始之后的新技术  
需要用到方法
```
default void forEach(BiConsumer<? super K, ? super V> action)
```
结合Lambda遍历Map集合

流程格式
```
map.forEach((k,v) -> {
   System.out.println(k + "---->" + v);
});
```

#### HashMap
##### HashMap集合的底层原理
HashMap与HashSet的底层原理是一样的，都是基于哈希表实现的

**实际上，Set系列集合的底层就是基于Map实现的，只是Set集合中的元素只要键数据，不要值数据**

##### HashMap集合的特点
- HashMap集合是一种增删改查数据，性能都较好的集合
- 它是无序的，不能重复，没有索引支持的（由键决定特点）
- HashMap的键依赖hashCode方法和equals方法保证键的唯一
- 如果键存储的是自定义类型的对象，可以通过重写hashCode和equals方法，这样可以保证多个对象内容一样时，HashMap集合就能认为是重复的
#### LinkedHashMap
##### LinkedHashMap集合的底层原理
LinkedHashMap集合的底层数据结构也是基于哈希表实现的，只是每个键值对元素又额外多了一个双链表的机制记录元素顺序（保证有序）

**实际上，LinkedHashSet集合的底层就是基于LinkedHashMap实现的**

#### TreeMap
##### TreeMap集合的底层原理
TreeMap集合的底层数据结构和TreeSet集合相同，都是基于红黑树实现的排序

**实际上，TreeSet集合的底层就是基于TreeMap实现的**

##### TreeMap指定排序规则
TreeMap集合同样也支持两种方式来指定排序规则
- 让类实现Comparable接口，重写比较规则
- TreeMap集合有一个有参构造器，支持创建Comparator比较器对象，以便用来指定比较规则


### 集合的嵌套
指的是集合中的元素又是一个集合


## JDK8新特性
### Lambda

### Stream
也叫Stream流，是JDK8开始新增的一套API（java.util.stream.*），可以用于操作集合或者数组的数据
#### 优势
Stream流大量结合了Lambda的语法风格来编程，提供了一种更加强大，更加简单的方式操作集合或者数组中的数据，代码更简洁，可读性更好

#### 使用步骤
- 从数据源（集合/数组/...）获取Stream流，Stream流代表一条流水线，并能与数据源建立连接
- 调用流水线的各种方法对数据进行处理计算，如过滤、排序、去重等
- 获取处理的结果，遍历、统计、收集到一个新集合中返回

#### Stream流的常用方法
##### 获取Stream流
###### 获取集合的Stream流
```
default Stream<E> stream()
```
获取当前集合对象的Stream流
**注意，只能获取集合，不能获取Map，Map使用Stream要先把键或值添加到一个Set集合中，再对Set集合使用Stream。或者使用entrySet方法把map转为Set**

###### 获取数组的Stream流
```
public static <T> Stream<T> stream(T[] array)
```
Arrays类提供的方法，用于获取当前数组的Stream流
```
public static<T> Stream<T> of(T... values)
```
Stream类提供的方法，用于获取当前接收数据的Stream流

##### Stream流的中间方法
中间方法指的是调用完成后会返回新的Stream流，可以继续使用（支持链式编程）
```
Stream<T> filter(Predicate<? super T> predicate)
```
用于对流中的数据进行过滤
```
Stream<T> sorted()
```
对元素进行升序排序
```
Stream<T> sorted(Comparator<? supet T> comparator)
```
按照指定规则排序
```
Stream<T> limit(long maxSize)
```
获取前几个元素
```
Stream<T> skip(long n)
```
跳过前几个元素
```
Stream<T> distinct()
```
去除流中重复的元素
```
<R> Stream<R> map(Function<? super T, ? extends R> mapper) 
```
对元素进行加工，并返回对应的新流
```
static <T> Stream<T> concat(Stream a, Stream b)
```
合并a和b两个流为一个流
##### Stream流的终结方法
终结方法指的是调用完成后，不会返回新的Stream了，没法继续使用流了
```
void forEach(Consumer action)
```
对此流运算后的元素执行遍历
```
long count()
```
统计此流运算后的元素个数
```
Optional<T> max(Comparator<? super T> comparator)
```
获取此流运算后的最大值元素
```
Optional<T> min(Comparator<? super T> comparator)
```
获取此流运算后的最小值元素

##### 收集Stream流
就是把Stream流操作后的结果转回到集合或者数组中去返回

Stream流是方便操作集合/数组的手段，集合/数组才是开发中的目的
```
R collect(Collector collector)
```
把流处理后的结果收集到一个指定的集合中去
```
Object[] toArray()
```
把流处理后的结果收集到一个数组中去

**流只能收集一次**

具体的收集方式
```
public static <T> Collector toList()
```
把元素收集到List集合中
```
public static <T> Collector toSet()
```
把元素收集到Set集合中
```
public static Collector toMap(Function KeyMapper,Function valueMapper)
```
把元素收集到Map集合中


## File、IO流
变量、数组对象、集合是内存中的数据容器，他们记录的数据，在断电或程序终止时会丢失

### File
File是```java.io.```包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件或文件夹）  
可以获取文件信息（大小、文件名、修改时间），判断文件类型，创建文件/文件夹、删除文件/文件夹等操作

#### File类的构造器
```
public file(String pathname)
```
根据文件路径创建文件对象

**路径分隔符可以用 ```/``` 或 ```\\``` 或 ```File.separator```**
```
public file(String parent,String child)
```
根据父路径和子路径名字创建文件对象
```
public file(File parent,String child)
```
根据父路径对应文件对象和子路径名字创建文件对象

#### File类的注意事项
- File类只能对文件本身进行操作，不能读写文件里面存储的数据
- File对象既可以代表文件，也可以代表文件夹
- File封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的

#### 绝对路径和相对路径
##### 绝对路径
从盘符开始
##### 相对路径
```
模块名\\文件名
```
不带盘符的，默认直接去当前工程下寻找文件  
开发中一般要用相对路径

#### File的常用方法
##### 判断文件类型、获取文件信息功能
```
public boolean exists()
```
判断当前文件对象，对应的文件路径是否存在，存在返回true
```
public boolean isFile()
```
判断当前文件对象指代的是否是文件，是文件返回true
```
public boolean isDirectiry()
```
判断当前文件对象指代的是否是文件夹，是文件夹返回true
```
public String getName()
```
获取文件的名称（包含后缀）
```
public long length()
```
获取文件的大小，返回字节个数
```
public long lastModified()
```
获取文件的最后修改时间
```
public String getPath()
```
获取创建文件对象时，使用的路径
```
public String getAbsolutePath()
```
获取绝对路径

##### 创建文件、删除文件功能
###### 创建文件
```
public boolean createNewFile()
```
创建一个新文件（文件内容为空），创建成功返回true
```
public boolean mkdir()
```
用于创建文件夹，注意：只能创建一级文件夹
```
public boolean mkdirs()
```
用于创建文件夹，注意：可以创建多级文件夹
###### 删除文件
```
public boolean delete()
```
删除文件，或者空文件，注意：不能删除非空文件夹，且删除后的文件不会进入回收站

###### 遍历文件夹功能
```
public String[] list()
```
获取当前目录下所有的“一级文件名称”到一个字符串数组中去返回
```
public File[] listFiles()
```
获取当前目录下所有的“一级文件对象”到一个文件对象数组中去返回（重点）

使用listFiles方法时的注意事项
- 当主调是文件，或者路径不存在时，返回null
- 当主调是空文件夹时，返回一个长度为0的数组
- 当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回
- 当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件
- 当主调是一个文件夹，但是没有权限访问该文件夹时，返回null


## 方法递归
### 概念
方法递归是一种算法，在程序设计语言中广泛应用
从形式上说，方法调用自身的形式称为方法递归（recursion）
### 形式
#### 直接递归
方法自己调用自己
#### 间接递归
方法调用其他方法，其他方法由回调方法自己

### 使用方法递归时要注意的问题
递归如果没有控制好终止，会出现递归死循环，导致栈内存溢出错误

### 递归算法三要素
- 递归的公式
- 递归的终结点
- 递归的方向必须走向终结点


## 字符集
### 标准ASCII字符集
#### 定义
ASCII(American Standard Code for Information Interchange)：美国信息交换标准代码，包括了英文、符号等
#### 特点
标准ASCII使用1个字节存储一个字符，首位是0，总共可表示128个字符，对英文来说完全够用
### GBK
汉字内码扩展规范，国标
#### 定义
汉字编码字符集，包含了2万多个汉字等字符
#### 特点
GBK中一个中文字符编码成2个字节的形式存储  
GBK兼容了ASCII字符集  
汉字的第一个字节的第一位必须是1

### Unicode字符集
统一码，也叫万国码
#### 定义
Unicode是国际组织制定的，可以容纳世界上所有的文字、符号的字符集
#### 编码方案
##### UTF-32
4个字节表示一个字符，优点是能涵盖所有语言所有类别的字符，缺点是占存储空间大，通信效率低
##### UTF-8
采取可变长编码方案，共分2个长度区：1个字节、2个字节、3个字节、4个字节  
英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节
###### UTF-8编码方式（二进制）
- 1个字节  
即ASCII码方式，0xxxxxxx
- 2个字节  
110xxxxx 10xxxxxx
- 3个字节  
1110xxxx 10xxxxxx 10xxxxxx
- 4个字节  
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

**技术人员在开发时都应该使用UTF-8编码**  
**字符编码时使用的字符集，和解码时使用的字符集必须一致，否则会出现乱码**  
**英文和数字一般不会乱码，因为很多字符集都兼容ASCII编码**

#### 字符集的编码、解码操作
##### 编码
把字符按照指定字符集编码成字节  
###### Java代码对字符的编码方式  
String提供了如下方法
```
byte[] getBytes()
```
使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中
```
byte[] getBytes(String charsetName)
```
使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中

##### 解码
把字节按照指定字符集解码成字符
###### Java代码对字符的解码方式
String提供了如下方法
```
String(byte[] bytes)
```
通过使用平台的默认字符集解码指定的字节数组来构造新的String
```
String(byte[] bytes, String charsetName)
```
通过指定的字符集解码指定的字节数来构造新的String

## IO流
用于读写数据，可以读写文件，或网络中的数据
### 概念
#### I指Input，称为输入流，负责把数据读到内存中去
#### O指Output,称为输出流，负责把数据存到磁盘或网络上

### IO流的分类
#### 按流的方向，分为输入流和输出流
#### 按流中数据的最小单位，分为字节流和字符流
- 字节流  
适合操作所有类型的文件，比如：音频、视频、图片文本文件的复制、转移等
- 字符流  
只适合操作纯文本文件，比如：读写txt、java文件等

#### IO流总体来看有4大流
- 字节输入流  
以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流
- 字节输出流  
以内存为基准，把内存中的数据以字节的形式写出到磁盘文件或者网络中去的流
- 字符输入流  
以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流
- 字符输出流  
以内存为基准，把内存中的数据以字符的形式写出到磁盘文件或者网络中去的流

#### IO流的体系
##### 字节流
###### 字节输入流
- 抽象类InputStream
- 实现类FileInputStream（原始流/低级流）
- 字节缓冲输入流BufferedInputStream（包装流/处理流）
- 数据输入流DataInputStream（数据流）
- 对象字节输入流ObjectInputStream（序列化流）
###### 字节输出流
- 抽象类OutputStream
- 实现类FileOutputStream（原始流/低级流）
- 字节缓冲输出流BufferedOutputStream（包装流/处理流）
- 打印流PrintStream（打印流）
- 数据输出流DataOutputStream（数据流）
- 对象字节输出流ObjectOutputStream（序列化流）

##### 字符流
###### 字符输入流
- 抽象类Reader
- 实现类FileReader（原始流/低级流）
- 字符缓冲输入流BufferedReader（包装流/处理流）
- 字符输入转换流InputStreamReader（转换流）
###### 字符输出流
- 抽象类Writer
- 实现类FileWriter（原始流/低级流）
- 字符缓冲输入流BufferedWriter（包装流/处理流）
- 字符输出转换流OutputStreamWriter（转换流）
- 打印流PrintWriter（打印流）

### 字节流实现类
#### FileInputStream（文件字节输入流）
以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中
##### 构造器
```
public FileInputStream(File file)
```
创建字节输入流管道，与源文件接通
```
public FileInputStream(String pathname)
```
创建字节输入流管道，与源文件接通
##### 常用方法
###### 每次读取单个字节
```
public int read()
```
每次读取一个字节并返回，如果发现没有数据可读会返回-1  


每次读取单个字节存在的缺点：
- 需要不断地读取硬盘，速度慢，效率差
- 读取的汉字是乱码，且无法避免（因为每次读一个字节，会强行拆散汉字的编码）


###### 每次读取多个字节
```
public int read(byte[] buffer)
```
每次用一个字节数组去读取数据，返回字节数组读取了多少个字节，如果发现没有数据可读会返回-1

**使用FileInputStream每次读取多个字节，读取性能得到了提升，但是读取汉字输出还是可能会出现乱码，因此不适合读取汉字。但是在文件拷贝等操作中很适用**

###### 一次读取完全部字节
方法1  
自己定义一个字节数组与被读取的文件大小相同，使用该字节数组，一次读完文件的全部内容  

方法2  
JDK9版本以上，Java官方为InputStream提供了如下方法，可以直接把文件的全部字节读取到一个字节数组中返回
```
public byte[] readAllBytes() throws IOException
```
直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回

**如果文件过大，创建的字节数组也会过大，可能会引起内存溢出**

**流在使用完毕之后，必须关闭，释放系统资源（非常重要）,先开启的流后关闭，后开启的流先关闭**

##### 适用场景
- 字节流适合做数据的转移，如文件复制等
- 字符流等适合读写文本内容


#### FileOutputStream（文件字节输出流）
以内存为基准，把内存中的数据以字节的形式写出到文件中去

##### 构造器
```
public FileOutputStream(File file)
```
创建字节输出流管道与源文件对象接通
```
public FileOutputStream(String filepath)
```
创建字节输出流管道与源文件路径接通
```
public FileOutputStream(File file, boolean append)
```
创建字节输出流管道与源文件对象接通，可追加数据
```
public FileOutputStream(String filepath, boolean append)
```
创建字节输出流管道与源文件路径接通，可追加数据

##### 提供的方法
```
public void write(int a)
```
写一个字节出去
```
public void write(byte[] buffer)
```
写一个字节数组出去
```
public void write(byte[] buffer, int pos, int len)
```
写一个字节数组的一部分出去
```
public void close() throws IOException
```
关闭流


**换行符 ```\r\n``` 在不同的系统中都可以识别**

##### 适用场景
字节流非常适合做一切文件的复制操作。因为任何文件的底层都是字节，字节流做复制，是一字不漏的转移完全部字节，只要复制后的文件格式一致就没问题

#### 释放资源的方式
##### try-catch-finally
###### 语法格式
```
try{
  ...
  ...
}catch (IOException e){
    e.printStackTrace();
}finally{

}
```
###### finally代码区特点
无论try中的程序是正常执行，还是出现异常，最后都一定会执行finally区，除非JVM终止

###### 作用
一般用于在程序执行完成后进行资源的释放操作（专业级做法）

##### try-with-resource
try-catch-finally代码比较臃肿，JDK7开始提供了更简单的资源释放方案try-with-resource
###### 语法格式
```
try(定义资源1;定义资源2;...){  
        可能出现异常的代码;
}catch(异常类名 变量名){
        异常的处理代码;
}
```
括号内只能放资源对象,不能放普通变量  
资源都是会实现AutoCloseable接口的,资源都有一个close方法，且把资源放在括号中后，待资源用完之后，会自动调用其close方法完成资源的释放操作  
该资源使用完毕后，会自动调用其close()方法，完成对资源的释放


### 字符流实现类
#### FileReader（文件字符输入流）
以内存为基准，可以把磁盘文件中的数据以字符的形式读入到内存中
##### 构造器
```
public FileReader(File file)
```
创建字符输入流管道，与源文件接通
```
public FileReader(String pathname)
```
创建字符输入流管道，与源文件接通
##### 常用方法
###### 每次读取单个字符
```
public int read()
```
每次读取一个字符并返回，如果发现没有数据可读会返回-1
- 每次读取单个字符存在的缺点：
  - 需要不断地读取硬盘，速度慢，效率差

###### 每次读取多个字符
```
public int read(byte[] buffer)
```
每次用一个字符数组去读取数据，返回字符数组读取了多少个字符，如果发现没有数据可读会返回-1

#### FileWriter（文件字符输出流）
以内存为基准，把内存中的数据以字符的形式写出到文件中去

##### 构造器
```
public FileWriter(File file)
```
创建字符输出流管道与源文件对象接通
```
public FileWriter(String filepath)
```
创建字符输出流管道与源文件路径接通
```
public FileWriter(File file, boolean append)
```
创建字符输出流管道与源文件对象接通，可追加数据
```
public FileWriter(String filepath, boolean append)
```
创建字符输出流管道与源文件路径接通，可追加数据

##### 提供的方法
```
public void write(int c)
```
写一个字符
```
public void write(String str)
```
写一个字符串
```
public void write(String str,int off,int len)
```
写一个字符串的一部分
```
public void write(char[] cbuf)
```
写一个字符数组
```
public void write(char[] cbuf, int off, int len)
```
写一个字符数组的一部分
```
public void flush()
```
刷新流操作，字符输出流为减少读写磁盘，提高效率，进行了优化，增加了缓冲池，通过刷新流，会把缓冲池的数据存入磁盘，关闭流操作自带刷新流。如果缓冲区数据存满了，会自动刷新流

##### 注意事项
字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效（非常重要，要特别重视）

### IO流-缓冲流
#### 体系
##### 字节缓冲流
继承自各自的字节流,提高字节流读写数据的性能
- BufferedInputStream（字节缓冲输入流）
- BufferedOutputStream（字节缓冲输出流）
##### 字符缓冲流
继承自各自的字符流,提高字符流读写数据的性能
- BufferedReader（字符缓冲输入流）
- BufferedWriter（字符缓冲输出流）


#### 字节缓冲流
##### 原理
字节缓冲输入流BufferedInputStream自带8KB缓冲池  
字节缓冲输出流BufferedOutputStream也自带8KB缓冲池

##### 构造器
```
public BufferedInputStream(InputStream is)
```
把低级的字节输入流包装成一个高级的缓冲字节输入流，从而提高读数据的性能
```
public BufferedOutputStream(OutputStream os)
```
把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能

#### 字符缓冲流
字符缓冲输出流BufferedWriter也自带8KB缓冲池
##### 字符缓冲输入流BufferedReader
字符缓冲输入流BufferedReader自带8KB缓冲池，可以提高字符输入流读取字符数据的性能
###### 构造器
```
public BufferedReader(Reader r)
```
把低级的字符输入流包装成一个高级的缓冲字符输入流管道，从而提高字符输入流读字符数据的性能
###### 方法
```
public String readLine()
```
字符缓冲输入流新增的功能：按照行读取字符
读取一行数据返回，如果没有数据可读了，就返回null

##### 字符缓冲输出流BufferedWriter
字符缓冲输出流BufferedWriter自带8KB缓冲池，可以提高字符输出流读取字符数据的性能
###### 构造器
```
public BufferedWriter(Writer r)
```
把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写字符数据的性能
###### 方法
```
public void newLine()
```
字符缓冲输入流新增的功能：换行

### IO流-转换流
如果代码编码和被读取的文本文件的编码一致，使用字符流读取文本文件时不会出现乱码  
如果代码编码和被读取的文本文件的编码不一致，使用字符流读取文本文件时就会出现乱码
#### 字符输入转换流InputStreamReader
解决不同编码时，字符流读取文本内容乱码的问题
##### 解决思路
先获取文件的原始字节流，再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了
##### 构造器
```
public InputStreamReader(InputStream is)
```
把原始的字节输入流，按照代码默认编码转成字符输入流（与直接用FileReader的效果一样）
```
public InputStreamReader(InputStream is, String charset)
```
把原始的字节输入流，按照指定字符集编码转成字符输入流（重点）
#### 字符输出转换流OutputStreamWrite
可以控制写出去的字符使用什么字符集编码
- 需要控制写出去的字符使用什么字符集编码，有两种方法
  - 调用String提供的getBytes方法解决
  - 使用字符输出转换流实现

##### 解决思路
先获取字节输出流，再按照指定的字符集编码将其转换成字符输出流，以后写出去的字符就会用该字符集编码了
##### 构造器
```
public OutputStreamWriter(OutputStream os)
```
把原始的字节输出流，按照代码默认编码转成字符输出流
```
public OutputStreamWriter(OutputStream os, String charset)
```
把原始的字节输出流，按照指定字符集编码转成字符输出流（重点）

### IO流-打印流
打印流可以实现更方便、更高效的打印数据  
**打印流不能追加数据，如果要追加数据，需要包装低级流**
#### PrintStream
继承自字节输出流，内部包装了缓冲流，使用方便，同时性能好
##### 构造器
```
public PrintStream(OutputStream/File/String)
```
打印流直接通向字节输出流/文件/文件路径
```
public PrintStream(String fileName, Charset charset)
```
可以指定写出去的字符编码
```
public PrintStream(OutputStream out, boolean autoFlush)
```
可以指定实现自动刷新
```
public PrintStream(OutputStream out, boolean autoFlush, String encoding)
```
可以指定实现自动刷新，并可指定字符的编码
##### 提供的方法
```
public void println(Xxx xx)
```
打印任意类型的数据
```
public void write(int/byte[]/byte[]的一部分)
```
可以支持写字节数据

#### PrintWriter
继承自字符输出流
##### 构造器
```
public PrintWriter(OutputStream/Writer/File/String)
```
打印流直接通向字节输出流/文件/文件路径
```
public PrintWriter(String fileName, Charset charset)
```
可以指定写出去的字符编码
```
public PrintWriter(OutputStream out/Writer, boolean autoFlush)
```
可以指定实现自动刷新
```
public PrintWriter(OutputStream out, boolean autoFlush, String encoding)
```
可以指定实现自动刷新，并可指定字符的编码
##### 提供的方法
```
public void println(Xxx xx)
```
打印任意类型的数据
```
public void write(int/String/char[]/...)
```
可以支持写字节数据

##### PrintStream和PrintWriter的区别
- 打印数据的功能是一模一样的，都使用方便，性能高效（核心优势）
- PrintStream继承自字节输出流OutputStream，因此支持写字节数据的方法
- PrintWriter继承自字符输出流Writer，因此支持写字符数据出去

##### 打印流的一种应用：输出语句的重定向
- 可以把输出语句的打印位置改动到某个文件中去 

语法格式
```
PrintStream ps = new PrintStream("文件地址")
System.setOut(ps);
```

### IO流-数据流
#### 数据输出流DataOutputStream
允许把数据和其类型一并写出去
##### 构造器
```
public DataOutputStream(OutputStream out)
```
创建新数据输出流包装基础的字节输出流

##### 提供的方法
```
public final void writeByte(int v) throws IOException
```
将byte类型的数据写入基础的字节输出流
```
public final void writeInt(int v) throws IOException
```
将int类型的数据写入基础的字节输出流
```
public final void writeDouble(Double v) throws IOException
```
将double类型的数据写入基础的字节输出流
```
public final void writeUTF(String str) throws IOException
```
将字符串数据以UTF-8编码成字节写入基础的字节输出流
```
public void write(int/byte[]/byte[]一部分)
```
支持写字节数据

**输出的数据显示的像是乱码，实际不是乱码，可以用DataInputStream读取**

#### 数据输入流DataInputStream
用于读取数据输出流写出去的数据
##### 构造器

public DataInputStream(InputStream is)

创建新数据输入流包装基础的字节输出流
##### 提供的方法
```
public final byte readByte() throws IOException
```
读取字节数据返回
```
public final int readInt() throws IOException
```
读取int类型的数据返回
```
public final double readDouble() throws IOException
```
读取double类型的数据返回
```
public final String readUTF() throws IOException
```
读取字符串数据（UTF-8）返回
```
public int read(int/byte[]/byte[]一部分)
```
支持读字节数据

### IO流-序列化流
对象序列化：把java对象写入到文件中去  
对象反序列化：把文件里的Java对象读出来
#### 对象字节输出流ObjectOutputStream  
可以把Java对象进行序列化，把Java对象存入到文件中去
**如果要把Java对象序列化，就必须让对象的类实现序列化接口Serializable**
##### 构造器
```
public ObjectOutputStream(OutputStream out)
```
创建对象字节输出流，包装基础的字节输出流
##### 提供的方法
```
public final void writeObject(object o) throws IOException
```
把对象写出去

- 如果不想让某个成员变量序列化，可以用transient关键字修饰该成员变量，这样序列化时会忽略该成员变量

- 如果要一次序列化多个对象，可以用一个ArrayList集合存储多个对象，然后直接对集合进行序列化（注意：ArrayList集合已经实现了序列化接口）

#### 对象字节输入流ObjectInputStream
可以把Java对象进行反序列化，把存储在文件中的Java对象读入到内存中
##### 构造器
```
public ObjectInputStream(InputStream is)
```
创建对象字节输入流，包装基础的字节输入流
##### 提供的方法
```
public final Object readObject()
```
把存储在文件夹中的Java对象读出来

### IO框架
#### 框架
解决某类问题，编写的一套类、接口等，可以理解成一个半成品，大多数框架都是第三方研发的
- 使用框架开发的好处  
在框架的基础上开发，可以得到优秀的软件架构，并能提高开发效率
- 框架的形式  
一般是把类、接口等编译成class形式，再压缩成一个.jar结尾的文件发行出去

#### IO框架
封装了Java提供的对文件、数据进行操作的代码，对外提供了更简单的方式来对文件进行操作，对数据进行读写等


#### Commons-io
apache开源基金组织提供的一组有关IO操作的小框架，目的是提高IO流的开发效率
- 使用前需要把Commons-io.jar框架导入到项目中
- 在项目中创建文件夹lib
- 将Commons-io.jar文件复制到lib文件夹
- 在jar文件上点击右键，选择Add as Library
- 在类中导包使用
##### FileUtils类提供的常用方法
```
public static void copyFile(File srcFile, File destFile)
```
复制文件
```
public static void copyDirectory(File srcDir, File destDir)
```
复制文件夹
```
public static void deleteDirectory(File directory)
```
删除文件夹，注意可以删除非空文件夹
```
public static String readFileToString(File file, String encoding)
```
读数据
```
public static void writeStringToFile(File file, String data, String charname, boolean append)
```
写数据

##### IOUtils类提供的常用方法
```
public static int copy(InputStream inputStream, OutputStream outputStream)
```
复制文件
```
public static int copy(Reader reader, Writer writer)
```
复制文件
```
public static void write(String data, OutputStream output, String charsetName)
```
写数据


## 特殊文本文件
### 使用特殊文件的必要性
存储有关系的数据，作为系统的配置文件和作为信息进行传输
### 属性文件.properties
#### 特点
- 都只能是键值对
- 键不能重复
- 文件后缀一般是.properties结尾的
- 注释用#开头
#### 读取.properties文件的方法
##### Properties类
是一个Map集合（键值对），但是我们一般不会把它当做集合使用

核心作用：Properties是用来代表属性文件的，通过Properties可以读写属性文件里的内容

使用Properties读取属性文件里的键值对数据
###### Properties构造器
```
public Properties()
```
用于构建Properties集合对象（空容器）
###### Properties常用方法
```
public void load(InputStream is)
```
通过字节输入流，读取属性文件里的键值对数据
```
public void load(Reader reader)
```
通过字符输入流，读取属性文件里的键值对数据
```
public String getProperty(String key)
```
根据键获取值（其实就是get方法的效果）
```
public Set<String> stringPropertyNames()
```
获取全部键的集合（其实就是KetSet方法的效果）

#### 使用Properties把键值对数据写出到属性文件中去
##### Properties构造器
```
public Properties()
```
用于构建Properties集合对象（空容器）
##### Properties常用方法
```
public Object setProperty(String key, String value)
```
保存键值对数据到Properties对象中去
```
public void store(OutputStream os, String comments)
```
把键值对数据，通过字节输出流写出到属性文件中去
```
public void store(Writer w, String comments)
```
把键值对数据，通过字符输出流写出到属性文件中去


### XML文件.xml
XML（Extensible Markup Language，可扩展标记语言）
本质上是一种数据的格式，可以用来存储复杂的数据结构和数据关系
#### XML的特点
- XML中的<标签名>称为一个标签或一个元素，一般是成对出现的
- XML中的标签名可以自己定义（可扩展），但是必须要正确的嵌套
- XML中只能有一个根标签
- XML中的标签可以有属性
- 如果一个文件中放置的是XML格式的数据，这个文件就是XML文件，后缀一般要写成.xml
- XML元素是可扩展的
#### XML的结构
- XML文档形成一种树结构
- XML文档必须包含根元素。该元素是所有其他元素的父元素
- XML文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端
- 所有元素均可拥有子元素
- 父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）
- 所有元素均可拥有文本内容和属性（类似 HTML 中）

**在XML中，应该尽量避免使用属性。如果信息感觉很像数据，那么就使用子元素**


- XML属性的缺点
  - 属性无法包含多重的值（元素可以）
  - 属性无法描述树结构（元素可以）
  - 属性不易扩展（为未来的变化）
  - 属性难以阅读和维护

#### XML的语法规则
- 所有XML元素都须有关闭标签，在XML中，省略关闭标签是非法的  
**XML声明没有关闭标签。声明不属于XML本身的组成部分。它不是XML元素，也不需要关闭标签**
- XML标签对大小写敏感，在 XML 中，标签 ```<Letter> ```与标签 ```<letter>``` 是不同的。必须使用相同的大小写来编写打开标签和关闭标签
- 在XML中，所有元素都必须彼此正确地嵌套
- XML文档必须有一个元素是所有其他元素的父元素。该元素称为根元素
- XML的属性值必须加引号
**如果属性值本身包含双引号，那么有必要使用单引号包围它**
- XML中，空格会被保留，不会被删节
- XML以LF存储换行


在 Windows 应用程序中，换行通常以一对字符来存储：回车符 (CR) 和换行符 (LF)。这对字符与打字机设置新行的动作有相似之处。在 Unix 应用程序中，新行以 LF 字符存储。而 Macintosh 应用程序使用 CR 来存储新行

#### XML命名规则
- 名称可以含字母、数字以及其他的字符
- 名称不能以数字或者标点符号开始
- 名称不能以字符 “xml”（或者 XML、Xml）开始
- 名称不能包含空格
#### XML命名习惯
- 使名称具有描述性。可以使用下划线的名称
- 名称应当比较简短，比如：```<book_title>```，而不是：```<the_title_of_the_book>```
- 避免 ```-``` 字符。如果按照这样的方式进行命名：```first-name```，一些软件会认为只需要提取第一个单词
- 避免 ```.``` 字符。如果按照这样的方式进行命名：```first.name```，一些软件会认为 ```name``` 是对象 ```first``` 的属性。
- 避免 ```:``` 字符。冒号会被转换为命名空间来使用
- XML文档经常有一个对应的数据库，其中的字段会对应XML文档中的元素。可以使用数据库的名称规则来命名 XML 文档中的元素
- 非英语的字母比如 ```éòá``` 也是合法的XML元素名，不过需要留意当软件开发商不支持这些字符时可能出现的问题
#### XML的格式
##### 第一行要放声明
```
<?xml version="1.0" encoding="UTF-8" ?>
```
version:XML默认的版本号码，该属性是必须存在的  
encoding:本XML文件的编码格式

##### 注释格式
```
<!-- 注释 -->
```
XML中书写```<``` ```&```等符号，可能会出现冲突，导致报错，此时可以用如下实体引用来替代

||||
| :---:| :---:| :---:|
|\&lt;  |   <  | 小于|
|\&gt;  |   > |  大于|
|\&amp; |   & |  和号|
|\&apos; |  '  | 单引号|
|\&quot; |  "  | 引号|

**在XML中，只有字符 "<" 和 "&" 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯**

XML中可以写一个叫CDATA的数据区：```<![CDATA[...内容...]]>```，里面的内容可以随便写

##### XML DTD
文档类型定义（DTD）可定义合法的XML文档构建模块。DTD 的作用是定义 XML 文档的结构，它使用一系列合法的元素来定义文档的结构

DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用

###### 内部的 DOCTYPE 声明
DTD被包含在XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中
```
<!DOCTYPE 根元素 [元素声明]>
```
带有 DTD 的 XML 文档实例
```
<?xml version="1.0"?>
<!DOCTYPE note [
  <!ELEMENT note (to,from,heading,body)>
  <!ELEMENT to      (#PCDATA)>
  <!ELEMENT from    (#PCDATA)>
  <!ELEMENT heading (#PCDATA)>
  <!ELEMENT body    (#PCDATA)>
]>
<note>
  <to>George</to>
  <from>John</from>
  <heading>Reminder</heading>
  <body>Don't forget the meeting!</body>
</note>

!DOCTYPE note (第二行)定义此文档是 note 类型的文档。
!ELEMENT note (第三行)定义 note 元素有四个元素："to、from、heading,、body"
!ELEMENT to (第四行)定义 to 元素为 "#PCDATA" 类型
!ELEMENT from (第五行)定义 from 元素为 "#PCDATA" 类型
!ELEMENT heading (第六行)定义 heading 元素为 "#PCDATA" 类型
!ELEMENT body (第七行)定义 body 元素为 "#PCDATA" 类型
```
###### 外部文档声明
假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中
```
<!DOCTYPE 根元素 SYSTEM "文件名">
```
外部文档声明例子  

.xml
```
<?xml version="1.0"?>
<!DOCTYPE note SYSTEM "note.dtd">
<note>
<to>George</to>
<from>John</from>
<heading>Reminder</heading>
<body>Don't forget the meeting!</body>
</note> 
```

.dtd
```
<!ELEMENT note (to,from,heading,body)>
<!ELEMENT to (#PCDATA)>
<!ELEMENT from (#PCDATA)>
<!ELEMENT heading (#PCDATA)>
<!ELEMENT body (#PCDATA)>
```
###### 使用DTD的优点
- 通过 DTD，每一个 XML 文件均可携带一个有关其自身格式的描述
- 通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据
- 应用程序也可使用某个标准的 DTD 来验证从外部接收到的数据
- 可以使用 DTD 来验证自身的数据

##### XML Schema（XSD）
###### 定义
- XML Schema 是基于 XML 的 DTD 替代者  
- XML Schema 的作用是定义 XML 文档的合法构建模块，类似 DTD  
- XML Schema 语言也称作 XML Schema 定义（XML Schema Definition，XSD）  
###### 内容
- 定义可出现在文档中的元素  
- 定义可出现在文档中的属性  
- 定义哪个元素是子元素  
- 定义子元素的次序  
- 定义子元素的数目  
- 定义元素是否为空，或者是否可包含文本  
- 定义元素和属性的数据类型  
- 定义元素和属性的默认值以及固定值
###### XML Schema对比DTD的优势
- XML Schema 可针对未来的需求进行扩展
- XML Schema 更完善，功能更强大
- XML Schema 基于 XML 编写
- XML Schema 支持数据类型
- XML Schema 支持命名空间
###### 语法格式
```<schema>``` 元素是每一个 XML Schema 的根元素，<schema> 元素可包含属性
```
<?xml version="1.0"?>
 
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
targetNamespace="http://www.w3school.com.cn"
xmlns="http://www.w3school.com.cn"
elementFormDefault="qualified">

...
...
</xs:schema>

xmlns:xs="http://www.w3.org/2001/XMLSchema"
显示 schema 中用到的元素和数据类型来自命名空间 "http://www.w3.org/2001/XMLSchema"。同时它还规定了来自命名空间 "http://www.w3.org/2001/XMLSchema" 的元素和数据类型应该使用前缀 xs：
targetNamespace="http://www.w3school.com.cn" 
显示被此 schema 定义的元素 (note, to, from, heading, body) 来自命名空间： "http://www.w3school.com.cn"

xmlns="http://www.w3school.com.cn" 
```


#### XML的作用和应用场景
- 本质是一种数据格式，可以存储复杂的数据结构和数据关系
- 应用场景：经常用来作为系统的配置文件，或者作为一种特殊的数据结构，在网络中进行传输

#### 解析XML文件
使用程序读取XML文件中的数据  
有很多开源的，好用的解析XML的框架，最知名的是：Dom4j

#### Dom4j框架
##### Dom4j解析XML文件的思想
文档对象模型

通过SAXReader解析器，将XML文件解析为Document，从Document中解析出Element:元素（标签），Attribute:属性，子元素、文本

##### SAXReader
Dom4j提供的解析器，可以认为是代表整个Dom4j框架
###### 构造器
```
public SAXReader()
```
构建Dom4j的解析器对象
###### 提供的方法
```
public Document read(String url)
```
把XML文件读成Document对象
```
public Document read(InputStream is)
```
通过字节输入流读取XML文件

##### Document
###### 提供的方法
```
Element getRootElement()
```
获得根元素对象

##### Element
###### 提供的方法
```
public String getName()
```
得到元素名字
```
public List<Element> elements()
```
得到当前元素下所有子元素
```
public List<Element> elements(String name)
```
得到当前元素下指定名字的子元素返回集合
```
public Element elements(String name)
```
得到当前元素下指定名字的子元素，如果有很多名字相同的，则返回第一个
```
public String attributeValue(String name)
```
通过属性名直接得到属性值
```
public String elementText(子元素名)
```
得到指定名称的子元素的文本
```
public String getText()
```
得到文本

#### 使用程序把数据写出到XML文件中去
一般不使用dom4j，因为步骤繁琐  
通常直接把程序里的数据拼接成XML格式，然后用IO流写出去

#### 约束XML文件的书写
限制XML文件只能按照某种格式进行书写
##### 约束文档
用来限制xml书写格式的文档，比如：限制标签、属性应该怎么写
##### 约束文档的分类
###### DTD文档
DTD文档只能约束XML文件的编写，不能约束具体的数据类型  
编写DTD约束文档，后缀必须是.dtd
```
<!ELEMENT 书架(书+)>
<!ELEMENT 书(书名,作者,售价)>
<!ELEMENT 书名(#PCDATA)>
<!ELEMENT 作者(#PCDATA)>
<!ELEMENT 售价(#PCDATA)>
```
在需要编写的XML文件中导入该DTD约束文档
```
<!DOCTYPE 书架 SYSTEM "data.dtd">
```
然后XML文件必须按照DTD约束文档指定的格式进行编写，否则报错
###### Schema文档
- 可以约束XML文件的编写和具体的数据类型
- 编写schema约束文档，后缀必须是.xsd
- 在需要编写的XML文件中导入该schema约束文档
- 按照约束内容编写XML文件的标签

## 日志技术
把程序运行的信息，记录到文件中，方便程序员定位bug，并了解程序的执行情况等
### 概念
程序中的日志，通常就是一个文件，里面记录的是程序运行过程中的各种信息
#### 输出语句的弊端
- 日志会展示在控制台，项目上线后没有控制台
- 不能更方便的将日志记录到其他的位置（文件，数据库）
- 想取消日志，需要修改源代码才可以完成
#### 日志技术的优势
- 可以将系统执行的信息，方便的记录到指定的位置（控制台、文件、数据库中）
- 可以随时以开关的形式控制日志的启停，无需侵入到源代码中去进行修改

### 日志技术的体系结构
#### 日志框架
第三方公司已经做好的实现代码，可以直接拿来使用
- JUL(java.util.logging)
- Log4j
- Logback
基于slf4j的日志规范实现的框架，性能好，使用方便
#### 日志接口
设计日志框架的一套标准，日志框架需要实现这些接口  
因为对Commons Logging接口不满意，出现了SLF4J;因为对Log4j性能不满意，出现了Logback
- Java提供的Commons Logging(JCL)
- 第三方公司提供的Simple Logging Facade for Java(SLF4J)


### Logback日志框架
#### 模块
##### logback-core模块
基础模块，是其他两个模块依赖的模块（必须有）
##### logback-classic模块
完整实现了slf4j API的模块（必须有）
##### logback-access模块
与Tomcat和Jetty等Servlet容器集成，以提供HTTP访问日志的功能（可选模块）

- 想使用Logback日志框架，至少需要在项目中整合如下3个模块
  - slf4j-api：日志接口
  - Logback-core
  - Logback-classic

#### Logback框架实现步骤
##### 导入Logback框架到项目中去
slf4j-api：日志接口  
Logback-core  
Logback-classic
##### 将Logback框架的核心配置文件logback.xml直接拷贝到src目录下（注意：必须是src目录下）
**注意：对Logback日志框架的控制，都是通过其核心配置文件logback.xml来实现的**
##### 创建Logback框架提供的Logger对象，然后用Logger对象调用其提供的方法就可以记录系统的日志信息
语法格式
```
public static final Logger LOGGER = LoggerFactory.getLogger("类名");
```
#### 核心配置文件logback.xml
对Logback日志框架进行控制
##### 日志的输出位置、输出格式的设置
通常可以设置2个输出日志的位置
控制台
```
<appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
```
系统文件中
```
<appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
```

##### 开启日志（ALL），取消日志（OFF）
```
<root level="ALL">
    <appender-ref ref="CONSOLE"/>
    <appender-ref ref="FILE"/>
</root>
```
### 日志级别
#### 概念
日志级别指的是日志信息的类型，日志都会分级别，常见的级别优先级由低到高有
##### trace
追踪，指明程序运行轨迹
##### debug
调试，实际应用中一般将其作为最低级别，而trace则很少使用
##### info
输出重要的运行信息、数据连接、网络连接、IO操作等等，使用较多
##### warn
警告信息，可能会的发生问题，使用较多
##### error
错误信息，使用较多

#### 设置记录日志级别
##### 语法
```
<root level="info">
    <appender-ref ref="CONSOLE"/>
    <appender-ref ref="FILE"/>
</root>
```
只有日志级别大于或等于核心配置文件配置的日志级别，才会被记录，否则不记录


## 多线程
### 概念
#### 线程
线程（Thread）是一个程序内部的一条执行流程  
程序中如果只有一条执行流程，那这个程序就是单线程的程序
#### 多线程
多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）

### 在程序中创建多条线程的方法
Java是通过```java.lang.Thread```类的对象来代表线程的  
**main方法是由一条默认的主线程负责执行**
#### 方法1
将类声明为```Thread```的子类，并重写类```Thread```的```run```方法
##### 步骤
- 让类```MyThread```继承```Thread```线程类
- 重写```Thread```类的```run```方法
- 创建```MyThread```线程类的对象代表一个线程
- 用```start```方法启动线程
##### 优点
编码简单
##### 缺点
线程类已经继承```Thread```类，无法再继承其他类，不利于功能扩展

#### 方法2
声明一个实现```Runnable```接口的类。并在该类中实现```run```方法
##### 步骤
- 定义一个任务类，实现```Runnable```接口
- 重写```Runnable```的```run```方法
- 创建任务对象
- 把任务对象交给一个线程对象处理（调用线程对象有参构造器）
- 用```start```方法启动线程
##### 优点
任务类只是实现接口，可以继续继承其他类，实现其它接口，扩展性强
##### 缺点
需要多创建一个```Runnable```对象
##### 匿名内部类写法
- 创建```Runnable```的匿名内部类对象
- 再交给```Thread```线程对象
- 调用线程对象的```start()```启动线程

#### 方法3
假如线程执行完毕后有一些数据需要返回，前两种方法重写的```run```方法均不能直接返回结果  

使用JDK5.0提供的```Callable```接口和```FutureTask```类来实现
##### 步骤
- 创建任务对象
- 定义一个类实现Callable接口，重写call方法，封装要做的事情和要返回的数据
- 把Callable类型的对象封装成FutureTask（线程任务对象）
- 把线程任务对象交给Thread对象
- 调用Thread对象的start方法启动线程
- 线程执行完毕后，通过FutureTask对象的get方法去获取任务执行的结果


**注意：如果执行到get方法之前，线程还没有执行完毕，那么代码会暂停，等待现成执行完毕后才会获取结果**

##### 线程任务对象FutureTask的作用
是一个任务对象，实现了Runnable对象
可以在线程执行完毕之后，用未来任务对象调用get方法获取线程执行完毕后的结果
##### FutureTask提供的构造器
```
public FutureTask<>(Callable call)
```
把Callable对象封装成FUtureTask对象
##### FutureTask提供的方法
```
public V get() throws Exception
```
获取线程执行call方法返回的结果

##### 优点
- 最大的优点是可以返回线程执行完毕后的结果
- 线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强
##### 缺点
代码比前两种复杂

### 多线程注意事项
#### 启动线程必须是调用start方法，不是调用run方法
- 直接调用run方法，会当成普通方法执行，此时相当于还是单线程执行
- 只有调用start方法才是启动一个新的线程执行
#### 不要把主线程任务放在启动子线程之前
- 这样主线程一直是先跑完的，相当于是一个单线程的效果

### Thread提供的线程操作相关方法
#### Thread提供的常用方法
```
public void run()
```
线程的任务方法
```
public void start()
```
启动线程
```
public String getName()
```
获取当前线程的名称，线程名称默认是```Thread-索引```
```
public void setName(String name)
```
为线程设置名称
```
public static Thread currentThread() 
```
获取当前执行的线程对象
```
public static void sleep(long time)
```
让当前执行的线程休眠多少毫秒后，再继续执行
```
public final void join()
```
让调用当前这个方法的线程先执行完

#### Thread提供的常见构造器
```
public Thread(String name)
```
可以为当前线程指定名称
```
public Thread(Runnable target)
```
封装Runnable对象成为线程对象
```
public Thread(Runnable target, String name)
```
封装Runnable对象成为线程对象，并指定线程名称

#### Thread提供的其他方法
Thread类还提供了yield、interrupt、守护线程、线程优先级等线程的控制方法，在开发中使用不多

### 线程安全
#### 线程安全问题
多个线程，同时操作同一个共享资源的时候，可能会出现业务安全问题

### 线程同步
解决线程安全问题的方案
#### 线程同步的思想
让多个线程实现先后依次访问共享资源，这样就解决了安全问题
#### 线程同步的常见方案
- 加锁  
每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来
#### 加锁的方式
- 同步代码块
- 同步方法
- Lock锁

#### 方式1--同步代码块
##### 作用
把访问共享资源的核心代码上锁，以此保证线程安全
##### 语法
```
synchronized(同步锁){
    访问共享资源的核心代码
}
```
##### 原理
每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行
##### 注意事项
对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug
- 锁对象使用规范
  - 锁对象不能随便选择一个唯一的对象，因为会影响其他无关线程的执行
  - 建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象
  - 对于静态方法，建议使用字节码 ```类名.class``` 对象作为锁对象

#### 方式2--同步方法
##### 作用
把访问共享资源的核心方法上锁，以此保证线程安全
##### 语法
```
修饰符 synchronized 返回值类型 方法名称(形参列表){
          操作共享资源的代码
}
```
##### 原理
每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行
##### 底层原理
- 同步方法底层也是有隐式锁对象的，只是锁的范围是整个方法代码
- 如果方法是实例方法，同步方法默认用this作为锁的对象
- 如果方法是静态方法，同步方法默认用类名.class作为锁的对象
##### 同步代码块与同步方法比较
- 范围上，同步代码块锁的范围更小，性能更好；同步方法锁的范围更大
- 可读性上，同步方法更好

#### 方式3--Lock锁
##### 概念
Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建出锁对象，进行加锁和解锁，更灵活、更方便、更强大


Lock是接口，不能直接实例化，可以采用它的实现类ReentrantLock来构建Lock锁对象
##### 构造器
```
public ReentrantLock()
```
获得Lock锁的实现类对象
##### 常用方法
```
void lock()
```
获得锁
```
void unlock()
```
释放锁

##### 注意事项
一般把Lock锁定义为final成员变量
即```private final Lock l = new ReentrantLock()```
一般要使用```try/catch/finally```包裹代码
把```unlock()```放到```finally```中，确保代码出现问题也会解锁

### 线程通信
当多个线程共同操作共享的资源时，线程间通过某种方式互相告知自己的状态，以相互协调，并避免无效的资源争夺
#### 线程通信的常见模型
##### 生产者与消费者模型
- 生产者线程负责生产数据  
  - 消费者线程负责消费生产者生产的数据
  - 生产者生产完数据应该等待自己，通知消费者消费；消费者消费完数据也应该等待自己，再通知生产者生产

**线程通信的前提是要保证线程安全**

#### Object类的等待和唤醒方法
```
void wait()
```
让当前线程等待并释放所占锁，直到另一个线程调用```notify()```方法或```notifyAll()```方法
```
void notify()
```
唤醒正在等待的单个线程
```
void notifyAll()
```
唤醒正在等待的所有线程

**注意：上述方法应该使用当前同步锁对象进行调用**

### 线程池
线程池就是一个可以复用线程的技术
#### 不使用线程池的问题
用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了又要创建新线程处理。而创建新线程的开销是很大的，且请求过多时，肯定会产生大量的线程，这样会严重影响系统性能
#### 线程池的工作原理
- 工作线程WorkThread

- 任务队列WorkQueue  
  - 任务需要实现任务接口Runnable或Callable
#### 创建线程池
JDK5.0起，Java提供了代表线程池的接口ExecutorService
创建线程池对象有两种方法
##### 方式一
使用```ExecutorService```的实现类```ThreadPoolExecutor```创建一个线程池对象
##### 方式二
使用```Executors```（线程池的工具类）调用方法返回不同特点的线程池对象

#### ThreadPoolExecutor
##### ThreadPoolExecutor构造器
```
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)
```
参数一：corePoolSize
- 指定线程池的核心线程的数量，核心线程是可以长久复用的
- 行业中，计算密集型任务，一般设置为 核心线程数量 = CPU的核数 + 1
- IO密集型任务，一般设置为 核心线程数量 = CPU的核数 * 2

参数二：maximumPoolSize
- 指定线程池的最大线程数量，数量要超过核心线程，即核心线程数+临时线程数

参数三：keepAliveTime
- 指定临时线程的存活时间

参数四：unit
- 指定临时线程存活时间的时间单位（秒、分、时、天），它是一个枚举值，一般设为秒 TimeUnit.SECONDS

参数五：workQueue
- 指定线程池的任务队列
- 一般是new LinkedBlockingQueue<>()  //它是基于链表实现的，无限大小的
- 或new ArrayBlockingQueue<>()       //它是基于数组实现的，需要设置大小

参数六：threadFactory
- 指定线程池的线程工厂，一般是```Executors.defaultThreadFactory()```

参数七：handler
- 指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理），一般是```new ThreadPoolExecutor.AbortPolicy()```

#### 线程池的注意事项
- 临时线程创建时间  
新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程
- 开始拒绝新任务的时间  
核心线程和临时线程都在忙，任务队列也满了，此时新的任务过来的时候才会开始拒绝任务

#### ExecutorService的常用方法
```
void execute(Runnable command)
```
执行任务/命令，没有返回值，一般用来执行```Runnable```  任务
```
Future<T> submit(Callable<T> task)
```
执行 ```Callable``` 任务，返回未来任务对象，用于获取线程返回的结果
```
void shutdown()
```
等全部任务执行完毕后，再关闭线程池
```
List<Runnable> shutdownNow()
```
立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务

#### 新任务拒绝策略
由参数七中设置
```
ThreadPoolExecutor.AbortPolicy
```
丢弃任务并抛出 ```RejectedExecutionException``` 异常，是默认的策略
```
ThreadPoolExecutor.DiscardPolicy
```
丢弃任务，但是不抛出异常，这是不推荐的做法
```
ThreadPoolExecutor.DiscardOldestPolicy
```
抛弃队列中等待最久的任务，然后把当前任务加入队列中
```
ThreadPoolExecutor.CallerRunsPolicy
```
由主线程负责调用任务的 ```run()``` 方法，从而绕过线程池直接执行


#### Executors工具类
Executors是一个线程池的工具类，提供了很多静态方法，用于返回不同特点的线程池对象

##### Executors常用方法
```
public static ExecutorService newFixedThreadPool(int nThreads)
```
创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它
```
public static ExecutorService newSingleThreadExecutor()
```
创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程
```
public static ExecutorService newCachedThreadPool()
```
线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s，则会被回收掉
```
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
```
创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务

**注意：这些方法的底层，都是通过线程池的实现类ThreadPoolExecutor创建的线程池对象**

###### Executors可能存在的风险
- 大型并发系统环境中，使用 ```Executors``` ，如果不注意，可能会出现系统风险
- ```FixedThreadPool``` 和 ```SingleThreadPool``` 允许的创建线程数量为 ```Integer.MAX_VALUE``` ，可能会堆积大量请求，从而导致OOM（内存溢出）
- ```CachedThreadPool```和 ```ScheduledThreadPool``` 允许的创建线程数量为 ```Integer.MAX_VALUE``` ，可能会创建大量的线程，从而导致OOM（内存溢出）

### 并发和并行
#### 进程和线程
- 正在运行的程序（软件）就是一个独立的进程
- 线程是属于进程的，一个进程中可以同时运行很多个线程
- 进程中的多个线程是并发和并行执行的
#### 并发的含义
进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU的切换速度很快，给我们的感觉就是这些线程在同时执行，这就是并发
#### 并行的含义
在同一个时刻，同时有多个线程在被CPU调度执行
#### 多线程是如何执行的
并发和并行同时进行

### 线程的生命周期
#### 概念
- 线程从生到死的过程中，经历的各种状态及状态转换
- 理解线程的这些状态，有利于提升并发编程的理解能力
#### Java线程的状态
共定义了6种状态，都定义在Thread类的内部枚举类中
##### NEW（新建）
线程刚被创建，但是并未启动
```
start() --> RUNNABLE
```
##### RUNNABLE（可运行）
- 线程已经调用start()，等待CPU调度
- 执行完毕/出现异常 --> TERMINATED
- 未获得锁对象 --> BLOCKED
- 获得锁对象调用了wait()方法 --> WAITING
- sleep(毫秒)/wait(毫秒) --> TIMED_WAITING
##### BLOCKED（锁/阻塞）
线程在执行的时候未竞争到锁对象，则该进程进入Blocked状态
```
获得锁对象 --> RUNNABLE
```
##### WAITING（无限等待）
- 一个线程进入WAITING状态后，另一个线程调用notify或者notifyAll方法才能唤醒
```
被其他线程notify并获得锁对象 --> RUNNABLE
```
```
被其他线程notify，但未获得锁对象 --> BLOCKED
```
##### TIMED_WAITING（计时等待）
同WAITING状态，有几个方法（sleep,wait）有超时参数，调用它们将进入TIMED_WAITING状态
```
sleep时间到 --> RUNNABLE  //sleep()方法不会释放锁，时间到直接可运行
```
```
wait时间到，并得到锁对象 --> RUNNABLE
```
```
wait时间没到，被其他线程notify,并得到锁对象 --> RUNNABLE
```
```
wait时间到，但未得到锁对象 --> BLOCKED
```
```
wait时间没到，被其他线程notify，但未获得锁对象 --> BLOCKED
- TERMINATED（被终止）
```
因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡

### 悲观锁和乐观锁
#### 悲观锁
一上来就加锁，没有安全感，每次只能一个线程进入访问完毕后，再解锁。线程安全，但是性能较差
#### 乐观锁
一开始不上锁，认为是没有问题的，等要出现线程安全问题时才开始控制。线程安全，性能较好
##### 整数修改的乐观锁
###### 原理
在线程结束返回结果时，检查数值是否已被其他线程修改，如果已经被修改，则此线程运算结果作废
###### 实现
CAS算法--使用原子类实现
```
private AtomicInteger count = new AtomicInteger();
```
使用count.incrementAndGet()方法来累加

## 网络编程
网络编程可以让设备中的程序与网络上其他设备中的程序进行数据交互（实现网络通信）
### 基本的通信架构
基本的通信架构有2种形式
#### CS架构（Client客户端--Server服务端）
- Client客户端
  - 需要程序员开发
  - 用户需要安装
- Server服务端
  - 需要程序员开发
#### BS架构（Browser浏览器--Server服务端）
- Browser浏览器
  - 不需要程序员开发
  - 用户需要安装浏览器
  - 浏览器通过 http://服务器IP:服务器端口 和服务端建立连接
- Server服务端
  - 需要程序员开发
### 网络通信三要素
#### IP地址
设备在网络中的地址，是惟一的标识
#### 端口号
应用程序在设备中唯一的标识
#### 协议
连接和数据在网络中传输的规则


### IP地址
设备在网络中的地址，是惟一的标识
#### 概念
IP(Internet Protocol)，全程“互联网协议地址”，是分配给上网设备的唯一标志
#### IP地址有两种形式：IPv4、IPv6
- IPv4
  - 32bit（4字节），每八位编码成一个十进制位表示，数之间用点分开，即点分十进制表示法
- IPv6
  - 共128位，号称可以为地球每一粒沙子编号
I  - PV6分成8段表示，每段每四位编码成一个十六进制位表示，数之间用冒号（:）分开，即冒分十六进制表示法
#### IP域名
##### 公网IP和内网IP
- 公网IP是可以连接互联网的IP地址
- 内网IP也叫局域网IP，只能组织机构内部使用
- 192.168.开头的就是常见的局域网地址，范围即为 ```192.168.0.0-192.168.255.255``` ，专门为组织机构内部使用
##### 特殊IP地址
- ```127.0.0.1`` 、```localhost```，代表本机IP，只会寻找当前所在主机
#### IP常用命令
```
ipconfig
```
查看本机IP地址
```
ping IP地址
```
检查网络是否连通

#### InetAddress
在Java中代表IP地址
##### InetAddress常用方法
```
public static InetAddress getLocalHost()
```
获取本机IP，会以一个InetAddress对象返回
```
public static InetAddress getByName(String host)
```
根据IP地址或域名，返回一个InetAddress对象
```
public String getHostName()
```
获取该IP地址对象对应的主机名
```
public String getHostAddress()
```
获取该IP地址对象中的IP地址信息
```
public boolean isReachable(int timeout)
```
在指定毫秒内，判断主机与该IP对应的主机是否能连通

### 端口
用来标记正在计算机设备上运行的应用程序，被规定为一个16位的二进制数，范围是0-65535
#### 端口分类
##### 周知端口
0-1023，被预先定义的知名应用占用（如HTTP占用80，FTP占用21）
##### 注册端口
1024-49151，分配给用户进程或某些应用程序
##### 动态端口
49152-65535，它一般不固定分配某种进程，而是动态分配

**注意：我们自己开发的程序一般选择使用注册端口，且一个设备中不能出现两个程序的端口相同，否则出错**

### 通信协议
网络上通信的设备，事先规定的连接规则，以及传输数据的规则，被称为网络通信协议
#### 开放式网络互联标准
##### OSI网络参考模型：全球网络互联标准
- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层
##### TCP/IP网络模型：事实上的国际标准
###### 应用层
对应OSI网络参考模型的应用层、表示层和会话层。对应HTTP、FTP、SMTP等协议，面向操作是应用程序需要关注的，例如浏览器、邮箱等，程序员一般在这一层开发
###### 传输层
对应OSI网络参考模型的传输层，对应UDP、TCP等协议，面向操作是选择使用的TCP、UDP协议
###### 网络层
对应OSI网络参考模型的网络层，对应IP等协议，面向操作是封装源和目标IP
###### 数据链路层+物理
对应OSI网络参考模型的数据链路层和物理层，对应比特流，面向操作是物理设备中传输
#### 传输层的2个通信协议
- UDP协议
- TCP协议
#### UDP协议
UDP（User Datagram Protocol）用户数据报协议
- 特点：无连接、不可靠通信，通信效率高
- 不事先建立连接，数据按照包发送，一包数据包含：自己的IP、程序端口，目的地IP、程序端口和数据（限制在64KB内）等
- 发送方不管对方是否在线，不管数据在中间是否丢失，如果接收方收到数据，也不返回进行确认，所以是不可靠的
- 适用于语音通话、视频直播等场景

#### TCP协议
TCP（Transmission Control Protocol）传输控制协议
- 特点
  - 面向连接，可靠通信，通信效率相对不高，适合网页、文件下载、网络支付
- TCP的最终目的
  - 要保证在不可靠的信道上实现可靠的传输
- TCP主要有3个步骤实现可靠传输
  - 三次握手建立连接
  - 传输数据进行确认
  - 四次挥手断开连接
- 可靠连接
  - 确定通信双方，收发消息都是正常无问题的（全双工）
- 三次握手建立连接 

|||
| :---:| :---:|
|客户端发出连接请求|服务端可以确定客户端可以发消息|
|服务端返回一个响应|客户端可以确定服务端可以收消息和发消息|
|客户端再次发出确认信息，建立连接|服务端可以确定客户端可以收消息|
|||
- 传输数据进行确认
传输数据会进行确认，以保证数据传输的可靠性
- 四次挥手断开连接
  - 目的是确保双方数据的收发都已经完成
  - 客户端发出断开连接请求
  - 服务端返回一个响应：稍等
  - 服务端将最后的数据处理完毕后，返回一个响应：确认断开
  - 客户端发出正式确认断开连接

### Java提供的网络编程解决方案
java.net.*包
#### UDP通信
##### 概念
- 特点：无连接、不可靠通信，通信效率高
- 不事先建立连接，数据按照包发送，一包数据包含：自己的IP、程序端口，目的地IP、程序端口和数据（限制在64KB内）等
##### UDP通信解决方案
Java提供了一个```java.net.DatagramSocket```类来实现UDP通信
##### DatagramSocket
用于创建客户端、服务端
###### 构造器
```
public DatagramSocket()
```
创建客户端的Socket对象，系统会随机分配一个端口号
```
public DatagramSocket(int port)
```
创建服务端的Socket对象，并指定端口号
###### 提供的方法
```
public void send(DatagramPacket dp)
```
发送数据包
```
public void receive(DatagramPacket p)
```
使用数据包接收数据

##### DatagramPacket
用于创建数据包
###### 构造器
```
public DatagramPacket(byte[] buf, int length, InetAddress address, int port)
```
创建发出去的数据包对象
- 参数1-----封装要发出去的数据===>使用getBytes()方法封装乘byte数组
- 参数2-----发送出去的数据大小（字节个数）===>使用bytes.length
- 参数3-----服务端的IP地址（找到服务端主机）===>使用InetAddress.提供的方法
- 参数4-----服务端程序的端口===>从注册端口中指定
```public DatagramPacket(byte[] buf, int length)```
创建用来接收数据的数据包
###### 提供的方法
```
public int getLength()
```
获取数据包，实际接收到的字节个数

##### UDP通信====>一发一收步骤
###### 客户端
- 第1步
  - 创建客户端DatagramSocket对象
- 第2步
  - 创建数据包DatagramPacket对象，封装要发送的数据
- 第3步
  - 使用DatagramSocket对象的send方法，开始正式发送数据包的数据
- 第4步
  - 关闭客户端的socket对象，释放资源
###### 服务端
- 第1步
  - 创建服务端DatagramSocket对象，注册端口，端口要与客户端的相同
- 第2步
  - 创建数据包DatagramPacket对象，用于接收数据，为确保能完整接收数据，数据包设成64KB大小，即1024*64
- 第3步
  - 使用DatagramSocket对象的receive方法，开始正式使用数据包来接收客户端发来的数据
- 第4步
  - 使用获取本次数据包接收到了多少数据，接收多少就倒出多少
- 第5步
  - 关闭服务端的socket对象，释放资源

##### UDP通信====>多发多收步骤
###### 客户端
使用while死循环，不断接收用户的数据输入，如果用户输入exit，则退出程序
###### 服务端
不关闭服务端的socket对象，使用while死循环，不断用receive方法接收数据


#### TCP通信
##### 概念
- 特点：面向连接，可靠通信
- 通信双方实现会采用“三次握手”方式建立可靠连接，实现端到端的通信，底层能保证数据成功传给服务端
##### TCP通信解决方案
Java提供了一个java.net.Socket类来实现TCP通信
##### TCP通信--客户端开发
客户端程序就是通过java.net包下的Socket类来实现的
###### 构造器
```
public Socket(String host, int port)
```
根据指定的服务器IP、端口号，请求与服务端建立连接，连接通过，就获得了客户端socket
###### 提供的方法
```
public OutputStream getOutputStream()
```
获得字节输出流对象
```
public InputStream getInputStream()
```
获得字节输入流对象

##### TCP通信--服务端开发
服务端程序就是通过java.net包下的ServerSocket类来实现的
###### 构造器
```
public ServerSocket(int port)
```
为服务端程序注册端口
###### 提供的方法
```
public Socket accept()
```
阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的Socket对象

##### TCP通信====>一发一收步骤
###### 客户端
- 第1步
创建客户端Socket对象，并同时请求与服务端程序的连接
- 第2步
从socket通信管道中调用getOutputStream()方法，得到一个字节输出流，用来发数据给服务端程序
- 第3步
把低级的字节输出流包装成数据输出流DataOutputStream
- 第4步
使用字节输出流完成数据的发送，之后关闭输出流
- 第5步
关闭socket管道
###### 服务端
- 第1步
  - 创建服务端ServerSocket对象，注册服务端端口
- 第2步
  - 调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象
- 第3步
  - 通过Socket对象调用getInputStream()方法得到字节输入流，完成数据的接收
- 第4步
  - 把原始的字节输入流包装成数据输入流DataInputStream，读取客户端发送的消息，还可以通过socket的getRemoteSocketAddress()方法获取客户端的IP地址
- 第5步
  - 释放资源，关闭socket管道

##### TCP通信====>多发多收步骤
###### 客户端
使用死循环，让用户不断输入消息
###### 服务端
也使用死循环，控制服务端收完消息，继续等待接收下一个消息

##### TCP通信====>与多个客户端同时通信
###### 服务端
需要使用多线程，主线程负责接收客户端连线。接收到一个，就创建一个子线程，如果客户端离线，就释放该线程的资源，关闭相应的socket管道

##### TCP通信====>端口转发
可以实现客户端与客户端之间的通信，例如实现群聊功能
###### 服务端
- 主线程
  - 负责接收客户端连接
- 子线程
  - 接收客户端数据
- 集合
  - 存储在线的socket，在收到客户端数据后，转发到所有客户端

#### BS架构通信
实现浏览网站的功能
##### 浏览器
通过 http://服务器IP:服务器端口 来和服务端建立连接
##### 服务端
- 主线程
  - 负责接收到浏览器连接，可以创建线程池供子线程使用，防止并发量过大
- 子线程
  - 接收网站数据给浏览器显示，最好用打印流，自带换行API，非常方便使用HTTP协议的数据格式。注意每次接收完数据都要关闭线程，因为网页显示完后本次通信就结束了

**特别注意：服务器必须给浏览器相应HTTP协议规定的数据格式，否则浏览器不识别返回的数据**

#### HTTP协议的数据格式
HTTP协议规定：响应给浏览器的数据格式必须满足如下格式
```
协议版本 状态码 状态符
头部字段名:值
  ......
头部字段名:值
必须空一行
响应正文（真正给浏览器展示的网页数据）
```

# Java高级
## 单元测试
### 概念
单元测试就是针对最小的功能单元（方法），编写测试代码对其进行正确性测试
#### 原始的测试方法存在的问题
- 只能在main方法中编写测试代码，去调用其他方法进行测试
- 无法实现自动化测试，一个方法测试失败，可能影响其他方法的测试
- 无法得到测试的报告，需要程序员自己去观察测试是否成功

### Junit单元测试框架
可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了Junit框架，比如IDEA）
#### 优点
- 可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立
- 不需要程序员去分析测试的结果，会自动生成测试报告
#### 使用Junit单元测试的具体步骤
- 将Junit框架的jar包导入到项目中（注意：IDEA集成了Junit框架，不需要自己手工导入了）
- 为需要测试的业务类，定义对应的测试类，并为每个业务方法，编写对应的测试方法（必须是公共、无参、无返回值）
- 测试方法上必须声明@Test注解，然后在测试方法中，编写代码调用被测试的业务方法进行测试
- 开始测试：选中测试方法，右键选择“Junit运行”，如果测试通过则是绿色，如果测试失败，则是红色

*可以在项目模块名上右键，运行模块内所有测试*


#### 断言机制
程序员可以通过预测业务方法的结果来判断方法是否有bug
##### 语法格式
```
Assert.assertEquals(String message, T expecteds, T actuals)
// 参数1 设置出现错误的提示信息
// 参数2 预测值
// 参数3 实际值
```
#### Junit单元测试框架的常用注解（Junit 4.xxxx版本）

```
@Test
```
测试类中的方法必须用它修饰才能成为测试方法，才能启动测试
```
@Before
```
用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次
```
@After
```
用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次
```
@BeforeClass
```
用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次
```
@AfterClass
```
用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次

- @Before和@BeforeClass是在测试方法执行前执行的方法，常用于初始化资源
- @After和@AfterClass是在测试方法执行完之后再执行的方法，常用于释放资源

#### Junit单元测试框架的常用注解（Junit 5.xxxx版本）
```
@Test
```
测试类中的方法必须用它修饰才能成为测试方法，才能启动测试
```
@BeforeEach
```
用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次
```
@AfterEach
````
用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次
```
@BeforeAll
```
用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次
```
@AfterAll
```
用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次

- @BeforeEach和@BeforeAll是在测试方法执行前执行的方法，常用于初始化资源
- @AfterEach和@AfterAll是在测试方法执行完之后再执行的方法，常用于释放资源


## 反射
在java.base模块中， ```java.lang.reflect``` 包下
### 概念
#### 反射就是：加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）

### 反射获取类的信息的步骤
#### 第1步
加载类，获取类的字节码：Class对象
-  具体流程  
类名.java --> 类名.class --> 字节码文件 --> 加载到内存 类名.class
#### 第2步
获取类的构造器：Constructor对象
#### 第3步
获取类的成员变量：Field对象
#### 第4步
获取类的成员方法：Method对象

### 获取Class对象
#### 获取Class对象有三种方式
##### 方式1
```
Class c = 类名.class
```
##### 方式2
调用Class提供的方法
···
public static Class forName(String package)
···
传入参数是类的全类名
##### 方式3
Object提供的方法
```
public Class getClass()
Class c = 对象.getClass();
```
### 获取类的构造器
#### Class提供的从类中获取构造器的方法
```
Constructor<?>[] getConstructors()
```
获取全部构造器（只能获取public修饰的）
```
Constructor<?>[] getDeclaredConstructors()
```
获取全部构造器（只要存在就能拿到）
```
Constructor<T> getConstructor(Class<?>... parameterTypes)
```
获取某个构造器（只能获取public修饰的）  
无参构造器不写传入参数，有参构造器写传入参数，格式是数据类型.class
```
Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)
```
获取某个构造器（只要存在就能拿到）

**获取类构造器的作用依然是初始化一个对象返回**

#### Constructor提供的方法
```
T newInstance(Object... initargs)
```
调用此构造器对象表示的构造器，并传入参数，完成对象的初始化并返回
```
public void setAccessible(boolean flag)
```
设置为true，表示禁止检查访问控制（暴力反射）


### 获取类的成员变量
#### Class提供的从类中获取成员变量的方法
```
public Field[] getFields()
```
获取类的全部成员变量（只能获取public修饰的）
```
public Field[] getDeclaredFields()
```
获取类的全部成员变量（只要存在就能拿到）
```
public Field getField(String name)
```
获取类的某个成员变量（只能获取public修饰的）
```
public Field getDeclaredField(String name)
```
获取类的某个成员变量（只要存在就能拿到）

**获取成员变量的作用依然是赋值、取值**
#### Field提供的方法
```
void set(Object obj, Object value)
```
赋值，参数1需要指定一个该类的对象
```
Object get(Object obj)
```
取值
```
public void setAccessible(boolean flag)
```
设置为true，表示禁止检查访问控制（暴力反射）

### 获取类的成员方法
#### Class提供的从类中获取成员方法的方法
```
Method[] getMethods()
```
获取类的全部成员方法（只能获取public修饰的）
```
Method[] getDeclaredMethods()
```
获取类的全部成员方法（只要存在就能拿到）
```
Method getMethod(String name, Class<?>... parameterTypes)
```
获取类的某个成员方法（只能获取public修饰的）
```
Method getDeclaredMethod(String name, Class<?>... parameterTypes)
```
获取类的某个成员方法（只要存在就能拿到）

**获取成员方法的作用依然是执行成员方法

#### Method提供的方法
```
public Object invoke(Object obj, Object... args)
```
触发某个对象的该方法执行
```
public void setAccessible(boolean flag)
```
设置为true，表示禁止检查访问控制（暴力反射）

### 反射的作用
- 基本作用：可以得到一个类的全部成分，然后操作
- 可以破坏封装性
- 最重要的用途：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能


## 注解
### 概念
注解（Annotation）就是Java代码里的特殊标记，例如@Override、@Test等，作用是让其他程序根据注解信息来决定如何执行该程序

注解可以用在类上、构造器上、方法上、成员变量上、参数上等位置

### 自定义注解
#### 创建
新建类时要选择 ```Annotation```
#### 语法格式
```
public @interface 注解名称{
   public 属性类型 属性名() default 默认值;
}
```
#### 特殊属性名：valuse
如果注解中只有一个value属性，使用注解时，value名称可以不写

### 注解的原理
#### 注解本质上是一个接口，Java中所有注解都是继承了Annotation接口的
#### @注解其实就是一个实现类对象，实现了该注解以及Annotation接口

### 元注解
元注解指的是修饰注解的注解

常见的元注解有两个
#### Target
##### 作用
声明被修饰的注解只能在哪些位置使用
##### 格式
```
@Target(ElementType.TYPE)
// TYPE 类，接口
// FIELD 成员变量
// METHOD 成员方法
// PARAMETER 方法参数
// CONSTRUCTOR 构造器
// LOCAL_VARIABLE 局部变量
```
#### Retention
##### 作用
声明注解的保留周期
##### 格式
```
@Retention(RetentionPolicy.RUNTIME)
// SOURCE  只作用在源码阶段，字节码文件中不存在
// CLASS（默认值）  保留到字节码文件阶段，运行阶段不存在
// RUNTIME（开发常用）  一直保留到运行阶段
```

### 注解的解析
判断类上、方法上、成员变量上是否存在注解，并把注解里的内容解析出来
#### 如何解析注解
- 指导思想  
要解析谁上面的注解，就应该先拿到谁
- 解析类上面的注解  
应该先获取该类的Class对象，再通过Class对象解析其上面的注解
- 解析成员方法上面的注解  
应该先获取该成员方法的Method对象，再通过Method对象解析其上面的注解
- Class、Method、Field、Constructor都实现了AnnotatedElement接口，它们都拥有解析注解的能力

#### AnnotatedElement接口
##### AnnotatedElement接口提供的解析注解的方法
```
public Annotation[] getDeclaredAnnotations()
```
获取当前对象上面的注解
```
public T getDeclaredAnnotation(Class<T> annotationClass)
```
获取指定的注解对象
```
public boolean isAnnotationPresent(Class<Annotation> annotationClass)
```
判断当前对象上是否存在某个注解

### 注解的应用场景
配合反射技术制作框架

## 动态代理
### 概念
#### 程序为什么需要代理
- 对象如果职责过多，可以通过代理来转移部分职责
- 对象有什么方法想被代理，代理就一定要有对应的方法
#### 实现代理的途径
Java使用接口来实现代理

### 如何为Java对象创建一个代理对象
#### ```java.lang.reflect.Proxy```类提供了为对象产生代理对象的方法
```
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
// 参数1：ClassLoader loader
// 用于指定用哪个类加载器，去加载生成的代理类，可以用 当前类名.class.getClassLoader()获得
// 参数2：Class<?>[] interfaces
// 指定接口，这些接口用于指定生成的代理长什么样，有哪些方法，需要包装成接口数组
// 参数3：InvocationHandler h
// 用来指定生成的代理对象要干什么事情，一般用匿名对象创建
```








