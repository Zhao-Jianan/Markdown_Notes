# C++基础编程
## 变量
### 变量存在的意义
方便我们管理内存空间
### 变量创建的语法
```
数据类型 变量名 = 变量初始值
```
**{}是域标识符，变量的作用域取决于在哪一个{范围内定义}
同一个作用域范围之内不能出现同名变量**
**当同名变量的作用域重合时，获取最近的作用域的变量（优先级更高）**
**出了{}作用域，变量会被系统释放，不能再次使用**
**for内部也是一个作用域，i是在for内部声明的，所以i出了for之后会被释放**
### 全局变量
在{}作用域外定义的变量，全局变量可以不赋值，会具有默认值0
全局变量特点：
1. 全局变量的编译在全局数据区，如果未初始化，系统自动初始化为0
2. 全局变量的作用域是增加函数之间联系的渠道，非必要时不要使用全局变量，因为①全局变量从开始运行就一直占用内存到运行结束②不方便维护
3. 如果在同一个源文件中，全局变量和局部变量同名，则在局部变量作用域范围内，全局变量被屏蔽，不起作用

### 局部变量
在{}作用域内定义的变量，只在函数内生效，不赋值不能打印
局部变量特点：
1. 局部变量使用前必须完成初始化
2. 不同函数内部可以使用同名变量，互不干扰，一个函数不能使用其他函数内部定义的局部变量
3. 在函数内的复合语句{}中定义的变量，是作用域最小的局部变量
4. 形式参数也是局部变量
5. 局部变量的作用域从其声明位置开始到{}作用域结束


## 常量
### 作用
记录程序中不可更改的数据
### 定义常量的2种方式
#### #define宏常量
 ```#define 常量名 常量值```
通常在文件上方定义，表示一个常量，要注意宏常量没有类型，在使用时它是字符置换

**#define语句结尾不加;**

*如果宏常量定义的是一个数字，用它给整型变量赋值，输出的是数字，用它给字符串变量赋值，输出的是数字对应的ASCii码*

#### const修饰的变量
```
const 数据类型 常量名 = 常量值
```
通常在变量定义前加关键字const，修饰该变量为常量，不可修改

## 作用域
共有4种作用域
- 文件作用域
- 函数作用域
- 块作用域
包括switch分枝
- 函数原型作用域
包括函数声明

其中文件作用域是全局，其他三个是局部

## 注释
### ```//``` 注释单行
### ```/*  */``` 注释多行
Ctrl+KC把选中的部分全部变为注释

## 关键字
系统原本就有的，有实际意义和用途的词语
### sizeof
统计数据类型所占内存大小
#### 语法 
```
sizeof(数据类型/变量)
```
### const
#### 顶层const和底层const
##### 顶层const
顶层const可以表示任意的对象是常量，指针、引用、int、double都可以
比如 ```int* const p=a;``` 本质是一个常量型的指针，指针指向的地址不能改变，该地址存储的数据可以改变

##### 底层const
不是所有的对象都是底层const，只有指针和引用等复合类型可以是
比如 ```const int* p=a``` ;指针所指的对象是常量，即a是一个常量，p指向a的地址空间，a的值不能变，p的指向可以改变

**比较特殊的是：指针既可以是顶层const也可以是底层const**
#### const修饰变量
##### const常量的作用
###### 将变量定义为常量，防止意外的修改，增强程序的健壮性

const常量和宏定义的区别
1. const常量会进行类型检查
编译器可以对const常量进行类型安全检查，而对define只进行字符替换，没有类型安全检查，在字符替换时可能会产生意料不到的错误。
2. const常量更节省空间，避免不必要的内存分配
const常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define宏定义的常量在内存中有若干个拷贝

###### 和static一样，修饰全局变量使其可见范围为当前文件
普通全局变量的作用域是当前文件，但是在其他文件中也是可见的，使用extern声明后就可以使用
而const全局变量在其他文件中是不可见的，这和添加了static关键字的效果类似

##### const和引用
可以把引用绑定到const对象上，就像绑定到其他对象上一样，称为对常量的引用（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象

**常量引用必须指向常量对象，非常量引用无法指向常量对象**

###### 初始化和对const的引用
引用的类型必须与其所引用对象的类型一致，但是有两个例外
- 在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可
- 尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式

###### 对const的引用可能引用一个非const的对象
必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值

##### const和指针
与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针（pointer to const）不能用于改变其所指对象的值
要想存放常量对象的地址，只能使用指向常量的指针

指针的类型必须与其所指对象的类型一致，但也不绝对，因为允许令一个指向常量的指针指向一个非常量对象

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变

**简单来说，所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值**

#### const修饰函数
- const修饰函数参数，表示参数不可变，若参数为引用，可以增加效率(引用传递而不用值拷贝)
- const修饰函数返回值，避免返回值被修改
- const修饰类的成员函数本身(不能修饰全局函数，因为全局函数没有this指针)

该函数不能修改成员变量
不能调用非const成员函数，因为任何非const成员函数会有修改成员变量的企图

默认的this指针是顶层 const，形如 ```A* const this```，是指向类类型非常量版本的常量指针，因为this是隐式的，所以它需要遵循初始化规则，意味着（在默认情况下）我们不能把this绑定到一个常量对象上，这一情况也就使得我们不能在一个常量对象上调用普通的成员函数

如果我们想让this绑定到常量对象上怎么做呢？
- 由于this是隐式的并且不会出现在参数列表中，所以无法显示的将this声明成指向常量的指针
- C++的做法是允许把const关键字放在成员函数的参数列表之后，表示this是一个指向常量的指针
- 像这样使用const的成员函数被称作常量成员函数（常量对象，以及常量对象的引用或指针都只能调用常量成员函数）

现在的this也成了底层const，所以属性值不能改变
形如：```const A* const this```

#### const修饰类成员
##### const修饰类的成员变量
表示成员变量不能被修改，同时只能在初始化列表中赋值

##### const修饰类的成员函数
见上面修饰函数

##### const修饰类对象
对象的任何成员都不能被修改
const类对象只能调用const成员函数


类中的哪些函数不可以声明为const函数？
1. 构造函数不能
因为const修饰的成员函数不能修改成员变量。构造函数也属于类的成员函数，但是构造函数需要修改类的成员变量，所以类的构造函数不能申明成const类型的
2. static静态成员函数不行
static静态成员是属于类的，而不属于某个具体的对象，所有的对象共用static成员。this指针是某个具体对象的地址，因此static成员函数没有this指针。而函数中的const其实就是用来修饰this指针的，表示this指向的内容不可变，static静态成员却没有this指针，所以const不能用来修饰static成员函数


const修饰的变量、函数、对象 分别成为：常变量、常函数、常对象
常函数只能访问常变量，常对象只能访问常变量和常函数


#### constexpr
```
constexpr：constant expression，常量表达式
```
实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式

为什么需要constexpr？
- 常量表达式和非常量表达式的计算时机不同
- 非常量表达式只能在程序运行阶段计算出结果
- 而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，而不再需要每次运行时都计算一次
- 所以，constexpr使常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段

#### const和constexpr对比
- const强调只读
- constexpr强调常量
即凡是表达“只读”语义的场景都使用const，表达“常量”语义的场景都使用constexpr

注意：
1. const关键字让编译器帮助我们发现变量不该被修改却被意外修改的错误
2. const关键字修饰的变量并非真正意义完完全全的只读
3. 对于不该被修改的入参，应该用const修饰，这是const使用的常见姿势
4. const修饰的变量只能正常赋值一次
5. 不要试图将非const数据的地址赋给普通指针
6. 不要忽略编译器的警告，除非你很清楚在做什么
7. 虽然可以通过某种不正规途径修改const修饰的变量，但是永远不要这么做


### static
一看见static关键字，就要本能的想到被static修饰的东西一定的对象无关，C++中把static叫做静态，表示共有的含义
#### C语言和C++共有的三种用法
##### 静态局部变量
用于函数体内部修饰变量，这种变量的生命周期长于该函数。它会在第一次调用函数时初始化，且只会初始化一次。第二次调用会直接跳过初始化
###### 静态局部变量特点
- 静态局部变量在全局数据区分配内存(局部变量在栈区分配内存)
- 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化)
- 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化)
- 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存)

##### 静态全局变量
定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见

静态全局变量特点：
- 静态全局变量不能被其它文件所用(全局变量可以)
- 其它文件中可以定义相同名字的变量，不会发生冲突(因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了)

##### 静态函数
静态函数与静态全局变量作用类似

静态函数特点：
- 静态函数不能被其它文件所用
- 其它文件中可以定义相同名字的函数，不会发生冲突

上面一共说了三种用法，为什么说准确来说是两种呢？
静态全局变量和修饰静态函数的作用是一样的，一般合并为一种

#### C++增加的两种用法
##### 静态成员变量
用于修饰class的数据成员，即所谓“静态成员”。这种数据成员的生存期大于class的对象（实体 instance）。静态数据成员是每个class有一份，普通数据成员是每个instance有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量

**静态成员变量需要在类外初始化**

静态成员变量特点:
- 对于非静态数据成员，每个类对象(实例)都有自己的拷贝。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存
- 静态数据成员存储在全局数据区，不占用类的内存空间。静态数据成员定义时要分配空间，所以不能在类声明中定义

##### 静态成员函数
用于修饰class的成员函数

静态成员函数特点：
- 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数
- 非静态成员函数可以任意地访问静态成员函数和静态数据成员
- 静态成员函数不能访问非静态成员函数和非静态数据成员
- 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数,也可以用类名::函数名调用(因为他本来就是属于类的，用类名调用很正常)

static相关问题
1. Q: 在头文件把一个变量申明为static变量，那么引用该头文件的源文件能够访问到该变量吗？
A: 可以。声明static变量一般是为了在本cpp文件中的static变量不能被其他的cpp文件引用，但是对于头文件，因为cpp文件中包含了头文件，故相当于该static变量在本cpp文件中也可以被见到。当多个cpp文件包含该头文件中，这个static变量将在各个cpp文件中将是独立的，彼此修改不会对相互有影响


2. Q: 为什么静态成员函数不能申明为const？
A: 这是C++的规则，const修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针的类成员函数，函数调用方式为thiscall，而类中的static函数本质上是全局函数，调用规约是__cdecl或__stdcall,不能用const来修饰它。一个静态成员函数访问的值是其参数、静态数据成员和全局变量，而这些数据都不是对象状态的一部分。而对成员函数中使用关键字const是表明：函数不会修改该函数访问的目标对象的数据成员。既然一个静态成员函数根本不访问非静态数据成员，那么就没必要使用const了

3. Q: 为什么不能在类的内部定义以及初始化static成员变量，而必须要放到类的外部定义？
A: 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的

4. Q: static关键字为什么只能出现在类内部的声明语句中，而不能重复出现在类外的定义中？
A: 如果类外定义函数时在函数名前加了static，因为作用域的限制，就只能在当前cpp里用，类本来就是为了给程序里各种地方用的，其他地方使用类是包含类的头文件，而无法包含类的源文件

5. Q: 为什么常量静态成员数据的初始化可以放在类内？（注意：只有静态常量整型数据成员才可以在类中初始化）
A: static数据成员在类外定义和初始化是为了保证只被定义和初始化一次，这样编译器就不必考虑类的函数里面第一个对static变量的'='操作是赋值还是初始化了。 static const int可以在类里面初始化，是因为它既然是const的，那程序就不会再去试图初始化了

（6）为什么静态成员函数只能访问静态成员变量?
静态成员函数只属于类本身，随着类的加载而存在，不属于任何对象，是独立存在的;非静态成员当且仅当实例化对象之后才存在，静态成员函数产生在前，非静态成员函数产生在后，故不能访问;内部访问静态成员用self::，而访问非静态成员要用this指针，静态成员函数没有this指针，故不能访问

（7）静态成员函数与非静态成员函数的区别？
根本区别：静态成员函数不存在this指针，不能访问非静态成员变量

（8）为什么要用静态成员变量和静态成员函数？
为了实现共享。因为静态成员函数和静态成员变量属于类，不属于类的实体，这样可以被多个对象所共享

（9）静态成员的作用、优点？
静态成员函数主要为了调用方便，不需要生成对象就能调用

### extern
extern是一个关键字，它告诉编译器存在着一个变量或者一个函数，如果在当前编译语句的前面中没有找到相应的变量或者函数，也会在当前文件的后面或者其它文件中定义
#### 引用同一个文件中的变量
变量在main函数的后边进行声明和初始化的话，那么在main函数中是不能直接引用这个变量的，因为当编译器编译到这一句话的时候，找不到这个变量的声明

如果不想改变变量的声明的位置，但是想在main函数中直接使用这个变量，可以使用extern这个关键字

利用extern关键字先声明一下变量，告诉编译器这个变量是存在的，但是不是在这之前声明的，你到别的地方找找吧，这样就可以顺利通过编译

#### 引用另一个文件中的变量
extern这个关键字的真正的作用是引用不在同一个文件中的变量或者函数

b.c中定义了一个变量num，如果a.c中想要引用这个变量，那么可以使用extern这个关键字

**注意：只有当一个变量是一个全局变量时，extern变量才会起作用**

**注意：**
1. extern关键字实质上是声明，别的地方必须实现定义
2. extern关键字只需要指明类型和变量名就行了，不能再重新赋值，初始化需要在声明处进行
3. 但是在声明之后就可以使用变量名进行修改了

使用include将另一个文件全部包含进去可以引用另一个文件中的变量，但是这样做的结果就是，被包含的文件中的所有的变量和方法都可以被这个文件使用，这样就变得不安全，如果只是希望一个文件使用另一个文件中的某个变量还是使用extern关键字更好

#### 引用另一个文件中的函数
extern除了引用另一个文件中的变量外，还可以引用另一个文件中的函数，引用方法和引用变量相似

#### extern修饰符可用于指示C或者C++函数的调用规范
比如在C++中调用C库函数，就需要在C++程序中用
```
extern “C”声明要引用的函数
```
这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后在目标代码中命名规则不同

#### extern和static
- extern表明该变量在别的地方已经定义过了，在这里要使用那个变量
- static表示静态的变量，分配内存的时候，存储在静态区，不存储在栈上面

1. static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量
2. static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了
3. static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它

#### extern和const
- C++中const修饰的全局常量具有跟static相同的特性，即它们只能作用于本编译模块中
- 但是const可以与extern连用来声明该常量可以作用于其他编译模块中, 如 ```extern const char g_str[];``` 然后在原文件中别忘了定义: ```const char g_str[] = “123456”;```
所以当const单独使用时它就与static相同，而当与extern一起合作的时候，它的特性就跟extern的一样了


## 标识符命名规则
C++规定，给标识符（变量、常量）命名时，要注意以下规则
1. 标识符不能是关键字
2. 标识符只能由字母、数字、下划线组成
3. 第一个字符必须为字母或下划线
4. 标识符中字母区分大小写
*给标识符命名时，争取做到见名知意的效果，方便自己和他人阅读*

## 数据类型
创建变量或常量时，必须指定相应的数据类型，否则无法给变量分配内存
### 整型
表示整数类型的数据
整型有以下几种

| 数据类型    | 占用字节数                                              |
|:------------|:-------------------------------------------------------|
| `short`      | 2 字节                                                   |
| `int`        | 4 字节                                                   |
| `long`       | Windows 占用 4 字节，Linux 32 位占用 4 字节，Linux 64 位占用 8 字节 |
| `long long`  | 8 字节                                                   |


### 实型（浮点型）
用来表示小数
默认情况下，输出小数会显示6位有效数字
浮点型变量分为以下几种

| 数据类型       | 占用字节数 | 有效数字位数         |
|:----------------|:------------|:--------------------|
| `float`          | 4 字节        | 7 位                   |
| `double`         | 8 字节        | 15 到 16 位             |
| `long double`    | 12 字节       | 18 位                  |


**要注意创建float时，要在最后加个f，否则会自动识别为双精度再转换为单精度**
```
float f1=3.14f
```
### 字符型
char
用于显示单个字符
语法
```
char ch='a';
```
注意：
1. 在显示字符型变量时，用单括号将字符括起来，不要用双引号
2. 单引号内只能有一个字符，不可以是字符串

C和C++中字符型变量只占用1个字节
字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入存储单元
```a-97 A-65```
```
cout<<(int)ch<<endl;
```
#### char字符相关函数
##### std标准库

| 函数名         | 分类         | 作用                         | 返回值             |
|:---------------|:--------------|:------------------------------|:------------------|
| `std::isalnum`  | 字符类型判断    | 判断是否为**字母或数字**         | 非 0 为真            |
| `std::isalpha`  | 字符类型判断    | 判断是否为**字母**               | 非 0 为真            |
| `std::isblank`  | 字符类型判断    | 判断是否为空格（空格或制表符）     | 非 0 为真            |
| `std::isdigit`  | 字符类型判断    | 判断是否为**数字**               | 非 0 为真            |
| `std::islower`  | 字符大小写判断  | 判断是否是**小写字母**           | 非 0 为真            |
| `std::isupper`  | 字符大小写判断  | 判断是否是**大写字母**           | 非 0 为真            |
| `std::tolower`  | 字符大小写转换  | 将字符转换为**小写字母**         | 转换后的字符         |
| `std::toupper`  | 字符大小写转换  | 将字符转换为**大写字母**         | 转换后的字符         |


##### 数据类型所占字节数
| 类型             | 32 位系统 | 64 位系统 |
|:----------------|:-----------|:-----------|
| `char`           | 1 字节      | 1 字节      |
| `short int`      | 2 字节      | 2 字节      |
| `int`            | 4 字节      | 4 字节      |
| `unsigned int`   | 4 字节      | 4 字节      |
| `float`          | 4 字节      | 4 字节      |
| `double`         | 8 字节      | 8 字节      |
| `long`           | 4 字节      | 8 字节      |
| `long long`      | 8 字节      | 8 字节      |
| `unsigned long`  | 4 字节      | 8 字节      |


### 字符串型
用于表示一串字符
两种风格
### C风格字符串(CString)
```
char 变量名[]="字符串值"
```
*注意：C风格的字符串要用双括号括起来*

C语言字符串 ```char*```

字符串本质是一个```char[]``` 而 ```char*``` 是可以看做是一个指向 ```char[]``` 首元素地址的指针
用 ```char[]``` 给 ```char*``` 赋值

*利用指针来创建和操作字符串非常方便*

字符串 ```char[]``` 以 ```\0``` 为结束符，```\0``` 前的都为有效字符，而数组长度为有效长度+1（ ```\0```占一个字符），```\0``` 不用手动输入，```char``` 数组初始化时，编译器会自动添加，但是如果没有初始化数组，在手动添加字符串后需要手动添加 ```\0```来结束字符串

**与普通数组不同，打印时不需要遍历，直接使用**
```
cout<<变量名<<endl;
```
普通数组使用这个语法打印的是首元素地址，字符串打印的是整个字符串内容

#### CString相关函数
##### std标准库

| 函数名                          | 作用                                          | 返回值说明                                            |
|:--------------------------------|:-----------------------------------------------|:------------------------------------------------------|
| `std::strlen`                   | 返回 `char` 数组的有效长度（不包括结尾 `\0`）    | 实际 `char` 数组长度 - 1                              |
| `std::strcmp(字符串1, 字符串2)` | 比较两个字符串的大小                             | 字符串1 > 字符串2 返回 1，字符串1 < 字符串2 返回 -1，若相等返回 0 |


###### 插入字符
| 函数名                                          | 作用                                                        | 说明                                              |
|:------------------------------------------------|:-------------------------------------------------------------|:--------------------------------------------------|
| `std::strcat(目标字符串, 源字符串)`              | 将源字符串追加到目标字符串后面，返回目标字符串指针               | 注意目标字符串长度要预留 `+\0` 空间               |
| `std::strcat_s(目标字符串, 长度, 源字符串)`      | 安全版 `strcat`，追加字符串，防止溢出，返回 0 或错误码           | C++ 推荐使用，需指定目标空间总长度（含 `\0`）    |
| `std::strcpy(目标字符串, 源字符串)`              | 将源字符串拷贝到目标字符串，覆盖原内容，返回目标字符串指针        | 注意目标字符串长度要预留 `+\0` 空间               |
| `std::strcpy_s(目标字符串, 长度, 源字符串)`      | 安全版 `strcpy`，拷贝字符串，防止溢出，返回 0 或错误码           | C++ 推荐使用，需指定目标空间总长度（含 `\0`）    |


###### 查找字符
| 函数名                  | 作用                                                | 返回值说明                        | 使用建议                      |
|:------------------------|:---------------------------------------------------|:----------------------------------|:------------------------------|
| `std::strchr(字符串, 字符)`  | 从**前向后**查找，返回第一次出现该字符的位置指针及其后续内容 | 找不到返回 `NULL`，否则返回指针     | 使用前建议 `if` 判空判断，防止直接打印报错 |
| `std::strrchr(字符串, 字符)` | 从**后向前**查找，返回第一次出现该字符的位置指针及其后续内容 | 找不到返回 `NULL`，否则返回指针     | 使用前建议 `if` 判空判断，防止直接打印报错 |


##### C++风格字符串
```
string 变量名="字符串值"
```
**注意：如果是2019版本以下的，使用String需要添加一个头文件**
```
#include<string>
```
string是标准库的一个类
**VS2019中，在类的构造函数中使用string传参，会报错 没有与参数列表匹配的构造函数。解决方法是在构造函数的形参前加const**



### 布尔型bool
代表真或假的值
| 布尔值  | 含义 | 数值 |
|:---------|:------|:------|
| `true`   | 真    | 1    |
| `false`  | 假    | 0    |

bool类型占1个字节大小
**注意：只要是非0值，都代表真，输出的都是1**

### 自动型auto
编译器根据初始值自动推导数据类型

### 转义字符
用于表示一些不能显示出来的ASCII字符
常用的有```\n```  ```\\```  ```\t```等

| 转义字符 | 含义                        | ASCII码值（10进制） | 说明                          |
|:-----------|:-----------------------------|:---------------------|:-------------------------------|
| `\a`        | 警报                          | 007                   | 发出蜂鸣声                      |
| `\b`        | 退格 (Backspace)              | 008                   | 光标移到前一列                  |
| `\f`        | 换页 (Form Feed)              | 012                   | 光标移到下页开头                |
| `\n`        | 换行 (Line Feed)              | 010                   | 光标移到下一行开头              |
| `\r`        | 回车 (Carriage Return)        | 013                   | 光标移到本行行首                |
| `\t`        | 水平制表 (Horizontal Tab)     | 009                   | 横向跳格，整齐对齐数据           |
| `\v`        | 垂直制表 (Vertical Tab)       | 011                   | 纵向跳格                         |
| `\\`        | 反斜杠字符 `\`               | 092                   | 输出一个 `\` 符号               |
| `\'`        | 单引号字符 `'`               | 039                   | 输出一个单引号                  |
| `\"`        | 双引号字符 `"`               | 034                   | 输出一个双引号                  |
| `\?`        | 问号                          | 063                   | 防止与 `??` 重构含义混淆        |
| `\0`        | 数字 0，字符串结束标志        | 000                   | C 字符串结束符                  |
| `\ddd`      | 8 进制转义字符，`d` 范围 0-7 | 3 位 8 进制数         | 如 `\101` 表示 'A'              |
| `\xhh`      | 16 进制转义字符，`h` 范围 0-9、a-f、A-F | 3 位 16 进制数 | 如 `\x41` 表示 'A'              |



### 变量的初始化
变量的初始化赋值有两种
1. ```数据类型 变量名=值;```
2. ```数据类型 变量名{值};```

### 数据的输入
用于从键盘获取数据
**cin**
语法
```
cin>>变量
```



## 运算符
用于代码的运算
### 位运算
位运算是二进制的基础数学运算，程序中的所有计算，本质上都是二进制的计算
| 符号 | 含义  | 运算规则                                                                 |
|:------|:------|:--------------------------------------------------------------------------|
| `&`   | 与    | 两个位都是 1 时，结果为 1                                                  |
| `|`   | 或    | 有一个位为 1 时，结果为 1                                                  |
| `^`   | 异或  | 0 和 1 或者 1 和 0 时，结果为 1                                           |
| `~`   | 取反  | 0 和 1 全部取反                                                            |
| `<<`  | 左移  | 位全部左移若干位，高位丢弃，低位补 0。`X << Y` 结果是 `X * (2^Y)`       |
| `>>`  | 右移  | 位全部右移若干位，正数高位补 0，负数高位补 1，低位丢弃。`X >> Y` 结果是 `X / (2^Y)`，舍弃小数部分 |


- 10进制数左移要先转为二进制，再左移，```X<<Y```实际结果是```X*(2的Y次方)```
- 10进制数右移要先转为二进制，再右移，```X>>Y``` 实际结果是```X/(2的Y次方)``` 再取整（舍弃小数部分）


一些位运算规律
1. 判断一个数是奇数还是偶数（取决于二进制最低位是0还是1）可以使用方法：
```X&1```  结果是0则X为偶数，结果为1则X为奇数

2. 交换a和b的值
```
a=a^b;
b=a^b;
a=a^b;
```
规律：两个数的异或结果，再异或其中一个数，得另一个数

3. 计算2的X次方
```
1<<X
```
结果是2的(X+1)次方

### 算术运算符
用于处理四则运算
| 符号  | 含义       | 示例           | 结果         |
|:------|:-----------|:---------------|:-------------|
| `+`   | 正号       | `+3`           | `3`          |
| `-`   | 负号       | `-3`           | `-3`         |
| `+`   | 加         | `10 + 5`       | `15`         |
| `-`   | 减         | `10 - 5`       | `5`          |
| `*`   | 乘         | `10 * 5`       | `50`         |
| `/`   | 除         | `10 / 5`       | `2`          |
| `%`   | 取模（取余）| `10 % 3`       | `1`          |
| `++`  | 前置递增   | `a = 2; b = ++a;` | `a = 3; b = 3;` |
| `++`  | 后置递增   | `a = 2; b = a++;` | `a = 3; b = 2;` |
| `--`  | 前置递减   | `a = 2; b = --a;` | `a = 1; b = 1;` |
| `--`  | 后置递减   | `a = 2; b = a--;` | `a = 1; b = 2;` |

注意
1. 两个整数相除，结果依然是整数，小数部分会被去除，10/3=3
2. 小数不能进行取模运算
3. 前置递增先让变量+1，然后进行表达式运算，后置递增先进行表达式运算，再让变量+1

```i++``` 和 ```++i``` 的区别
1. ```i++``` 和 ```++i``` 在赋值的情况下，```i++``` 先赋值，再递增，```++i``` 先递增，后赋值
2. ```i++``` 先保存原对象，然后自增，然后返回原临时对象，需要创建和销毁，```++i``` 返回的是原对象的引用，没有创建和销毁的过程 ```++i``` 返回对象的引用，是左值，而 ```i++``` 返回对象的原值，且非左值

### 赋值运算符
用于将表达式的值赋给变量
| 符号  | 含义       | 示例           | 结果         |
|:------|:-----------|:---------------|:-------------|
| `=`   | 赋值       | `a = 2; b = 3;` | `a = 2; b = 3;` |
| `+=`  | 加等于     | `a = 0; a += 2;` | `a = 2;`     |
| `-=`  | 减等于     | `a = 5; a -= 3;` | `a = 2;`     |
| `*=`  | 乘等于     | `a = 2; a *= 2;` | `a = 4;`     |
| `/=`  | 除等于     | `a = 4; a /= 2;` | `a = 2;`     |
| `%=`  | 模等于     | `a = 3; a %= 2;` | `a = 1;`     |


### 比较运算符
用于表达式的比较，并返回一个真值或假值
| 符号  | 含义         | 示例           | 结果         |
|:------|:-------------|:---------------|:-------------|
| `==`  | 相等于       | `4 == 3`       | `0`          |
| `!=`  | 不等于       | `4 != 3`       | `1`          |
| `<`   | 小于         | `4 < 3`        | `0`          |
| `>`   | 大于         | `4 > 3`        | `1`          |
| `<=`  | 小于等于     | `4 <= 3`       | `0`          |
| `>=`  | 大于等于     | `4 >= 3`       | `1`          |


### 逻辑运算符
用于根据表达式的值返回真值或假值
| 符号 | 含义       | 示例           | 结果                         |
|:-----|:-----------|:---------------|:-----------------------------|
| `!`  | 非         | `!a`           | 如果 `a` 为假，则 `!a` 为真；如果 `a` 为真，则 `!a` 为假 |
| `&&` | 与         | `a && b`       | 如果 `a` 和 `b` 都为真，则结果为真，否则为假        |
| `\|\|` | 或         | `a \|\| b`       | 如果 `a` 和 `b` 有一个为真，则结果为真，二者都为假，则结果为假 |



### 数学函数cmath
需要C++的头文件 ```#include<cmath>``` 或C的头文件```#include<math.h>```
| 函数        | 含义                            | 示例                           |
|:------------|:---------------------------------|:-------------------------------|
| `abs(a)`    | 绝对值                          | `a` 的绝对值                    |
| `max(a, b)` | 最大值                          | `a` 和 `b` 的最大值            |
| `min(a, b)` | 最小值                          | `a` 和 `b` 的最小值            |
| `floor(a)`  | 向下取整                        | 移除 `a` 的小数部分            |
| `round(a)`  | 四舍五入取整                    | 四舍五入取整                   |
| `pow(a, b)` | 开方                            | `a` 的 `b` 次方                |
| `sqrt(a)`   | 开根号                          | 根号 `a`                       |
| `exp(a)`    | 自然常数为底的指数函数          | `e` 的 `a` 次方                |
| `exp2(a)`   | 2 为底的指数函数                | `2` 的 `a` 次方                |
| `log(a)`    | 自然对数                        | 自然常数 `e` 为底数的对数，即 `ln a` |
| `loga(b)`   | 对数                            | `a` 为底 `b` 的对数，即 `loga b` |


#### 随机数
使用以下三个函数生成真随机数
```
rand()
```
能够产生伪随机数的随机函数，产生的值在0~RAND_MAX之间，一般来说RAND_MAX的大小由系统决定。直接调用该函数将返回的模拟的伪随机数，类型为整数（可以是int，也可以是long long，只要是整数即可）
```
srand()
```
伪随机数发生器的初始化函数，原型void srand(unsigned int seed)，rand()可以通过srand()的seed参数值（种子值）产生一系列伪随机数
```
time()
```
该函数可以返回自UNIX纪元起至当前时刻的秒数，使用time(NULL)或time(0)来获取当前系统时间，函数原型 ```time_t time(time_t *t)```

具体代码：
需要添加 ```#include<ctime>``` 头文件
生成1-100的随机数代码：
```
srand((unsigned int)time(NULL));
int num = rand() % 100 + 1;

int num = rand() % 41 + 60; //60-100
```

## 程序流程结构（控制流）
C/C++支持最基本的3种程序运行结构：顺序结构、选择结构、循环结构
### 顺序结构
程序按顺序执行，不发生跳转
### 选择结构
依据条件是否满足，有选择的执行相应功能
#### if语句
执行满足条件的语句
if语句三种形式
##### 单行格式if语句
```
if(条件){条件满足执行的语句}
```
要注意if条件后面不要加分号
##### 多行格式if语句
```
if(条件){条件满足执行的语句}else{条件不满足执行的语句}
```
##### 多条件if语句
```
if(条件1){条件1满足执行的语句}else if(条件2){条件2满足执行的语句}...else{条件都不满足执行的语句}
```
##### 嵌套if语句
在if语句中，可以嵌套使用if语句，达到更精确的条件判断
#### 三目运算符（又称三元表达式）
通过三目运算符实现简单的判断
语法：表达式1?表达式2:表达式3
如果表达式1的值为真，执行表达式2，并返回表达式2的结果；如果表达式1的值为假，执行表达式3，并返回表达式3的结果
在C++中，三目运算符返回的是变量，可以继续赋值
#### switch语句
执行多条件分支语句
- switch语句优点：结构清晰，运行效率比if高
- switch语句缺点：判断时只能整数或字符型，不能是区间

语法：
```
switch(表达式--只能放整数或字符型，不能放判断条件)
{
case结果1:执行语句;break;
case结果2:执行语句;break;
...
default:执行语句;break;
}
```
注意如果有几个不同结果执行相同语句，可以写成
```
switch(表达式)
{
case结果1:
case结果2:
  执行语句A;break;
case结果3:
case结果4:
  执行语句B;break;
...
default:执行语句;break;
}
```

### 循环结构
依据条件是否满足，循环多次执行某段代码
#### while循环语句
满足循环条件，执行循环语句
语法
```
while(循环条件){循环语句}
```
只要循环条件结果为真，就执行循环语句
**注意：在执行循环语句时，程序必须提供跳出循环的出口，否则出现死循环**
在循环中，可以利用break关键字退出当前循环
#### Do While循环语句
满足循环条件，执行循环语句
语法
```
do{循环语句;}while(循环条件);
```
注意：与 ```while``` 的区别在于 ```do...while``` 会先执行一次循环语句，再判断循环条件
#### for循环语句
满足循环条件，执行循环语句
语法：
```
for(起始表达式;条件表达式;末尾循环体){循环语句;}
```

| 表达式         | 含义                           | 示例                               |
|:--------------|:--------------------------------|:-----------------------------------|
| 起始表达式     | 不参加循环，做变量的初始赋值或变量声明 | `int i = 0;`                       |
| 条件表达式     | 循环条件                       | `i < 10`                           |
| 末尾循环体     | 当循环结束之后可能运行的额外代码 | `i++`                               |

#### 嵌套循环
作用：在循环体中再嵌套一层循环，解决一些实际问题

### 跳转语句
#### break语句
##### 作用
用于跳出选择结构或者循环结构
##### break使用时机
1. 出现在switch条件语句中，作用是终止case并跳出switch
2. 出现在循环语句中，作用是跳出当前的循环语句
3. 出现在嵌套语句中，跳出最近的内层循环语句
#### continue语句
##### 作用
在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环
##### continue和break的区别
循环遇到continue，会跳过continue后面的语句，执行下一次循环，break是直接跳出循环
#### goto语句
##### 作用
可以无条件跳转语句
##### 语法
```
goto标记（标记一般用大写字母的单词）
```
##### 标记
如果标记的名称存在，执行到goto语句时，会跳转到标记的位置
功能过于强大，一般不使用，会让代码逻辑混乱不方便阅读


## 数组
数组就是一个集合，里面存放了相同类型的数据元素
### 特点
1. 数组中的每个数据元素都是相同的数据类型
2. 数组是由连续的内存位置组成的

**数组本质上是多个相同的数据类型在内存中连续排列的一种形式。作为数组元素的各个数据，会通过下标编号来区分，这个编号也叫作索引，这样就可以对指定索引的元素进行读写操作**

**注意：数组是一个常量，不能作为左值，赋值之后无法修改数组本身，只能修改数组元素**


### 一维数组
三种定义方式：
```
数据类型 数组名[数组长度];
```
```
数据类型 数组名[数组长度] = {值1,值2,...};
```
```
数据类型 数组名[ ]={值1,值2,...};
```
**以第2种方式定义的时候，如果值的数量少于数组长度，会自动用0填充**

一维数组名称用途：
#### 可以统计整个数组在内存中的长度
统计整个数组在内存中的长度
```
sizeof(数组名)
``` 
统计数组中的值i在内存中的长度
```
sizeof(数组名[值i])
```
获得数组中值的个数
```
sizeof(数组名)/sizeof(数组名[值i])
```

#### 可以统计数组在内存中的首地址
查看数组首地址
```
cout<<arr<<endl<<endl;
```
查看数组中第一个元素地址
```
cout<<&arr[0]<<endl;
```

遍历数组的for循环写法：
1.常用写法
```
for(int i=0;i<size(arr);i++){};
```
2.C++11新写法
```
for(auto i:arr){};
```


*利用循环给员工命名*
```
string nameSeed="ABCDEFGHIJ";
string arrWorker[10];
for(int i=0;i<10;i++)
{
   arrWorker[i]="员工";
   arrWorker[i]+=nameSeed[i];
}
```

#### 冒泡排序
##### 作用
最常用的排序算法，对数组内元素进行排序，例如将数组元素从小到大排列
1. 比较相邻元素，如果第一个比第二个大，就交换它们两个
2. 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值
3. 重复以上步骤，每次比较次数-1，直到不需要比较

### 二维数组
在一维数组上，多加一个维度
四种定义方式：
定义二维数组的标准方式
```
数据类型 数组名[行数][列数];
```
定义并初始化二维数组（给定每行的值）
```
数据类型 数组名[行数][列数] = {
  {数据1,数据2},{数据3,数据4}
  };
```
定义并初始化二维数组（使用一维的方式初始化）
```
数据类型 数组名[行数][列数] = {数据1,数据2,数据3,数据4};
```
定义并初始化二维数组（省略行数）
```
数据类型 数组名[ ][列数] = {数据1,数据2,数据3,数据4};
```

第2种定义方式更加直观，提高代码的可读性

二维数组即一个矩阵，使用嵌套循环来打印
如果定义了二维数组的初始值，那么定义的时候可以省略行数，但是不能省略列数

二维数组名称用途：
- 可以查看二维数组所占内存空间
  - 使用```sizeof(数组名)```可以统计整个数组在内存中的长度
  - 使用 ```sizeof(数组名[值i])``` 可以统计数组中第i行在内存中的长度
  - 使用 ```sizeof(数组名[值i][值j])``` 可以统计数组中的值[i][j]在内存中的长度
  - ```sizeof(数组名)/sizeof(数组名[值i])``` 可以获得数组中值的个数
```
二维数组行数==sizeof(数组名)/sizeof(数组名[值i])
二维数组列数==sizeof(数组名[值i])/sizeof(数组名[值i][值j])
```
- 获取二维数组首地址

### 数组相关函数
C++17的std库新增了一个函数 ```size()``` 可以直接获取数组的元素个数
```
size(数组名)
```

### 数组与指针的关系
- 数组下标运算实际上都是通过指针进行的
- 数组名代表着指向该数组中下标为0的元素的指针，但有例外；sizeof(数组名)返回整个数组的大小，而非指针大小；&数组名返回一个指向数组的指针，而不是指向该数组中下标为0的元素的指针的指针
- 数组名作为参数时，数组名会被转换成指向该数组下标为0的元素的指针
- 指针操作可能比下标操作效率高，但可维护性却不一定有下标操作好
- 数组和指针不相等

**要特别注意arr和&arr的不同**
arr代表指向 ```arr[0]``` 的指针，```&arr``` 返回指向数组的指针，
```
int* p=arr;
int* q=&arr;
```
则```*(p+1)=arr[1]```   ```q+1``` 指向数组最后一个元素的下一个地址



## 函数
将一段经常使用的代码封装起来，减少重复代码
一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能

### 函数的定义
一般主要有5个步骤：
1. 声明返回值类型
2. 函数名
3. 参数表列
4. 函数体语句
5. ```return```表达式

### 语法
```
返回值类型 函数名(参数列表)
{
      函数体语句
      return表达式
}
```
**注意：要把函数写在Main函数的前面才能调用**

如果函数不需要返回值，声明的时候，返回值类型可以写void。return可以写，也可以不写
注意void是无类型，它不能创建变量，原因是无法分配内存


### 函数的调用
使用定义好的函数
语法
```
函数名（参数）
```

### 形参和实参
函数定义的时候，参数没有真实数据，只是一个形式上的参数，简称形参，形参变量在被调用时分配内存，在调用结束时释放内存
在调用函数之前，要定义实际的参数，简称实参，实参出现在主调函数
*形参和实参命名可以相同*

### 值传递（pass by value）
在调用函数的时候，实参的值会传递给形参，这个过程叫值传递
值传递时，如果形参发生变化，并不会影响实参
**要特别注意，这里的逻辑与惯性思维不同**
例如，函数中定义两个参数X和Y，进行交换，X和Y是形参，要调用函数时，定义两个参数a和b，想调用函数让a和b互换，a和b是实参，调用过函数后形参X和Y的数值进行了互换，但是a和b的数值没有互换

如果想要得到一个变化的值
- 可以返回一个新的值
- 如果想改变源值
  - 引用（推荐的方式）
  - 指针

### 函数常见样式
常见的函数样式有4种
1. 无参无返
2. 有参无返
3. 无参有返
4. 有参有返

### 函数的声明
#### 作用
告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义

函数的声明可以多次，但是函数的定义只能有1次

声明用来提前告诉编译器函数的存在，可以使用函数
可以在```main()``` 函数前加一个函数声明，函数就可以不用放在main函数前面
声明格式
```
返回值类型 函数名(参数列表)；
```
声明的参数列表也可以只写参数的数据类型

### 函数的分文件编写
#### 作用
让代码结构更加清晰
函数分文件编写一般有4个步骤
1. 创建后缀名为.h的头文件
2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义
5. 关联头文件和源文件
```
#include "头文件名.h"
```

### 函数默认参数
在C++中，函数的形参列表中的形参是可以有默认值的
#### 语法
```
返回值类型  函数名 (参数=默认值){}
```
#### 注意
1. 如果某个位置已经有了默认参数，那么从这个位置往后，从左到右，之后所有参数都必须有默认值
2. 函数声明和函数实现只能有一个有默认参数，如果函数声明中有默认参数，那么函数实现中就不能有默认参数

### 函数占位参数
C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置
语法
```
返回值类型 函数名(数据类型){}
```

### 函数重载（overload）
函数重载是指在同一作用域内有一组具有相同函数名且有不同参数列表的函数，这些函数被称为重载函数
函数的重载不便于阅读，最好还是用函数名区分
#### 作用
函数名可以相同，提高复用性

函数重载必须同时满足3个条件：
1. 同一个作用域下
2. 函数名称相同
3. 函数参数类型不同或者个数不同或者顺序不同

**注意：函数的返回值不可以作为函数重载的条件**

**函数重载注意事项：**
1. 引用作为重载条件时
2. 函数重载碰到函数默认参数时，可能会出现二义性，报错

**特别注意：**
- C语言不支持函数重载，只有C++支持
- C语言识别函数的方式，是通过函数名来识别，重载函数的函数名是相同的，因为区分符号的方式相同，会导致链接错误
- C++的文件符号表不是直接通过函数名来表示函数，而是与参数相关，只要参数不同 .o符号表里的重载函数就不存在冲突

##### 函数重载的原理：
程序编译流程：
- 第1步：预处理
头文件展开、宏替代、条件编译、去注释等。生成.i文件
- 第2步：编译
检查语法、生成汇编代码。生成.s文件
- 第3步：汇编
把汇编代码转换为二进制的机器码。生成.o文件
- 第4步：链接
把机器码合并在一起。生成.out文件

通过反汇编可以查看函数的定位方式
每一个函数的重载都会定位到不同的内存地址 也就是jmp指令（汇编语言指令）
调用函数首先要拿到一个jmp指令的地址（call地址） 然后再通过jmp定位到函数上的地址（jmp地址）


### 函数的递归调用
递归是一种编程思想，函数的递归就是自己调用自己，在函数的定义中调用了自己
#### 递归算法
一种直接或者间接调用自身函数的算法
#### 递归条件
每一步操作基本相同 并问题的规模会逐渐减少的情况
#### 递归过程
有去有回
- 递归调用要特别注意结束条件，否则会出现死循环
- 递归可以极大地减少代码量，所有的循环逻辑都可以用递归实现

#### 递归的缺点
1. 栈溢出的危险，递归会把所有的数据都先加载到栈上，然后再一点点释放，如果数据量大，可能会溢出
2. 时间和空间的消耗比较大
3. 需要尽量避免重复运算

### 内联函数
关键字 ```inline```
inline函数用来优化频繁被调用的函数
#### 语法
```
inline 返回类型 函数名(参数列表){函数主体}
```
内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方
#### 内联函数的缺点
1. 不能分文件编写
2. 内联函数的函数体语句不适合过多 空间换时间
3. 内联函数的函数体不能有循环语句、if语句或者switch语句，否则编译器会把该函数当做是普通函数来处理
#### 注意
1. 对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数
2. 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略inline 限定符
3. 关键字inline必须与函数定义体放在一起才能使函数成为内联，仅将inline放在函数声明前面不起任何作用
4. 定义在类声明之中的成员函数将自动地成为内联函数
5. 只有当函数只有10行甚至更少时才将其定义为内联函数


### lambda函数
lambda函数又称匿名函数
lambda函数是匿名的，函数没有名字
具有输入输出，表达式的参数就是其输入，表达式结果为函数的输出
#### 语法
##### 值捕获
单一值
```
auto 函数名=[a](){};
```
多个值
```
auto 函数名=[=](){};
```
##### 引用捕获
```
auto 函数名=[&a](){};
```
```
auto 函数名=[&](){};
```


## 指针
### 指针的作用
可以通过指针间接访问内存

内存编号是从0开始记录的，一般用十六进制数字表示
可以利用指针变量保存地址

### 指针变量定义语法
```
数据类型 * 指针变量名（一般用p--point）；
```

**指针本质上就是一个指向地址的变量，通过指针来保存内存地址**

不管什么类型的指针，在32位系统中，都占4个字节空间；在64位系统中，都占8个字节空间

*因为指针是记录地址的变量，存储了一个十六进制整数，所以占4个字节*
```
int a=10;
int * p=&a;
```
- ```&a``` 的运算结果是一个指针，指针的类型是a的类型加个*，指针所指向的类型是a的类型，指针所指向的地址就是a的地址
- ```*p``` 的运算结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址

**指针最好声明的时候就赋值，如果声明的时候不知道赋什么值，就赋值nullptr**

注意事项：
1. 指针可以改变指向
2. 必须通过解引用*来读取或写入数据
3. 可以不初始化，即没有指向，但是是不安全的

### 指针的两大操作空间
- 一个是重新指向
- 一个是变换当前值

### 解引用
使用指针时可以通过解引用的方式来找到指针指向的内存
指针前加```*``` 表示解引用，代表找到指针指向的内存中的数据
指针p的解引用为 ```*p```

不管什么类型的指针，在32位系统中，都占4个字节空间；在64位系统中，都占8个字节空间

### 空指针
指针变量指向内存中编号为0的空间
#### 用途
初始化指针变量
#### 语法
```
数据类型 *p=NULL;
```
```
数据类型 *p=0；
```
```
数据类型 *p=nullptr;
```
**在C++中，NULL关键字是cstdlib标准库中的一个宏，与0完全等价，即C++中用=0代表空指针，但是会存在二义性，因此C++11标准新增了nullptr代表空指针，尽量使用nullptr**

**注意：空指针指向的内存是不可以访问的，因为0-255之间的内存编号是系统占用的**

**自定义数据类型出现空指针几率比较大，要进行空指针判定，如果不判定，可能会出现严重错误，windows会显示错误，IOS会直接杀掉进程**


### 野指针
指针变量指向非法的内存空间
野指针会报错，要避免出现野指针
空指针和野指针都不是我们申请的空间，因此不要访问

#### 如何避免野指针
1. 指针初始化
当指针明确知道要存放某一变量地址时，在创建指针变量时就存放该变量地址
当不知道指针将要用于存放哪一变量地址时，在创建指针变量时应置为空指针（NULL）
2. 小心指针越界
3. 指针指向的空间被释放后及时置为NULL
4. 使用指针之前检查有效性
在使用指针之前需确保其不是空指针，因为空指针指向的空间是无法访问的


### const修饰指针
const修饰指针有3种情况
#### const修饰指针-------常量指针
```
int a=10;
const int * p=&a;
```
常量指针特点：指针的指向可以修改，但是指针指向的值不可以修改
例如上述代码，*p指向了a，*p的值不能修改，但是*p可以修改为指向b
*如果指针指向是常量，必须要设定为常量指针*

#### const修饰常量-------指针常量
```
int * const p=&a;
```
##### 特点
指针的指向不可以改，指针指向的值可以改


#### const既修饰指针，又修饰常量
```
const int * const p=&a;
```
##### 特点
指针的指向和指针指向的值都不可以改

### 指针和数组的配合使用
#### 数组指针
指向数组的指针，本质上是指针
利用指针访问数组中的元素

在创建数组时可以直接用指针创建
```
数据类型 * p=new 数据类型[]{};
```
p++可以获取数组的元素

*==用在数组或者指针，比较的是地址是否一致，不是判断值是否一样*

#### 指针数组
存放指针的数组，本质上是个数组

### 指针和函数的配合使用
#### 指针作为函数参数
- 利用指针作函数参数，可以修改实参的值
- 不使用指针的时候，函数值传递只会改变形参，不会改变实参
- 使用指针，是函数地址传递，可以改变实参
- 一般不使用指针作为函数参数，容易出问题，更方便的是用引用进行地址传递
#### 函数指针
- 每一个函数都占用一段内存单元，存储在内存的代码区
- 每一个函数都会拥有一个起始地址，指向函数入口地址的指针被称为函数指针
- 获取函数的地址并将其存储在函数指针中
- 通过函数指针可以完成很多操作，比如回调(callback)
*函数指针在游戏开发中很常用，因为有很多不确定具体运行时间的逻辑，例如关卡流送、网络复制等，需要使用回调函数*
*UE蓝图中的事件分发器就是用函数指针实现的*
##### 语法
```
返回类型 （*指针变量名）(参数表)；
```
##### 函数指针使用注意事项
- 函数指针和指针函数不是同一个东西
- 函数指针可指向任意其返回类型和参数列表相同的函数
- 函数指针不支持```++``` ```--``` ```+1```等操作
- 函数指针最终的目的是为了实现回调（将函数作为参数来传递）
- 函数指针只能指向函数的入口处，不能指向函数中某一条指令
- 函数指针指向函数后，函数的调用可以通过函数指针调用也可以通过获取函数调用
##### 函数指针作为函数参数
- 把一个函数的地址存储在函数指针中，作为另一个函数的参数
- 函数指针的最常用的用途就是把函数当做参数传递给另一个函数
用法举例：
```
char lock(char& ch)//加密时的回调函数
{
	return ch - 15;
}
char unlock(char& ch)//解密时的回调函数
{
	return ch + 15;
}

void change(string &str, char(*func)(char &))//加密和解密的执行逻辑
{
	for (int i = 0; i < str.size(); i++)
	{
		str[i]=(*func)(str[i]);
	}
}

int main()
{
	string msg = "yyds";
	change(msg, lock);
	cout << msg << endl;
	change(msg, unlock);
	cout << msg << endl;
}
```

##### 函数指针作为函数返回值
##### typedef创建函数指针别名
当需要创建多个指针时，为函数指针创建一个别名，相当于定义了一种新类型
#### 函数指针数组
存放函数指针的数组，本质上是数组，可以实现事件分发的功能
但是函数指针数组有较大的局限性，函数指针的类型，函数参数类型，函数参数的传入顺序，函数返回值之类都要一致



### 地址传递
地址传递可以修饰实参，即把指针作为函数内定义的参数
*如果不想修改实参，就用值传递；如果想修改实参，就用地址传递*

## 智能指针
### 动态内存管理可能出现的问题
#### 忘记释放内存 导致内存泄露
#### 在有指针引用的情况下 主动释放了 导致非法内存的指针
### 智能指针概念
在C++中引入智能指针的概念，智能指针在常规指针的基础上，添加了内存管理机制（引用计数管理） 可以帮助开发者自动释放所指向的对象，使C++程序员不需要手动释放内存
### 智能指针的种类
``` 
std::unique_ptr
```
```
std::shared_ptr
```
```
std::weak_ptr
```
注意： ```std::auto_ptr``` 已被废弃

### 概念
C++的指针包括两种
- 原始指针(raw pointer)，又叫裸指针
- 智能指针
智能指针是原始指针的封装，其优点是会自动分配内存，自动释放，不用担心潜在的内存泄露
#### 智能指针与原始指针
并不是所有的指针都可以封装成智能指针，很多时候原始指针更方便
各种指针中，最常用的是裸指针，其次是 ```unique_ptr```（独占指针）和 ```shared_ptr```（共享指针）
weak_ptr是shared_ptr的一个补充，应用场景较少
#### 智能指针与Rust的内存安全
智能指针只解决一部分问题，即独占/共享所有权指针的释放、传输
智能指针没有从根本上解决C++内存安全问题，不加以注意依然会造成内存安全问题

### unique_ptr/独占指针
```unique_ptr``` 在任何给定的时刻，只能有一个指针管理内存
当指针超出作用域时，内存将自动释放
在任意时刻只能给ptr指向一个给定对象 所以不支持普通的拷贝或复制
该类型指针不可Copy，只可以Move
#### 语法
使用智能指针要加memory头文件
```
#include<memory>
```

**3种创建方式**
##### 1. 通过已有裸指针创建
###### 语法
```
类型名* 裸指针名=new 类型名(赋值);
unique_ptr<类型名>独占指针名{裸指针名};
delete 裸指针;
裸指针=nullptr;
```
**特别注意**
这种方法并不好，没有体现出独占指针的独占特性。创建独占指针后，原来的裸指针依然能使用，而且和独占指针指向的是同一块内存，使用原来的裸指针改变值，独占指针中的值也会改变，但是销毁原来的裸指针，内存会被释放，独占指针也无法使用了

##### 2. 通过new创建
###### 语法
```
unique_ptr<类型名>独占指针名{new 类型名(赋值)};
```

##### 3. 通过 ```std::make_unique``` 创建（官方推荐）
###### 语法
```
unique_ptr<类型名>独占指针名=make_unique<类型名>(赋值);
```
```unique_ptr```可以通过```.get()```获取地址

unique_ptr实现了->与*
可以通过->调用成员函数
可以通过*调用dereferencing（解引用）
#### release
移交所有权
```
unique_ptr<string> p2(p1.release());
```
release会把p1置空，把p1原本指向的内存由p2来管理

#### unique_ptr与函数调用
unique_ptr是不可Copy的，只可以Move
在做函数参数或返回值中时一定要注意所有权
##### Passing by value
###### 默认的值传递方式
需要用 ```std::move```来转移内存拥有权
语法
```
函数声明：
返回类型 函数名(unique_ptr<类型名>变量名)

函数调用：
函数名(std::move(变量名));
```
**需要注意的是，调用完函数后，智能指针会被置空**

###### 传入std::make_unique语句
如果参数直接传入std::make_unique语句，自动转换为move
语法
```
函数调用：
函数名(make_unique<类型名>(赋值));
```

##### Passing by reference
###### 默认的引用传递方式
引用方式传递参数，调用完函数后，智能指针不会被置空，可以在函数中使用reset()置空
语法
```
函数声明：
返回类型 函数名(unique_ptr<类型名>& 变量名)
函数调用：
函数名(变量名);
```
###### 加const的引用传递方式
如果设置参数为const，则不能改变指向，例如reset()
reset()是智能指针清空方法，将智能指针置空

语法
```
函数声明：
返回类型 函数名(const unique_ptr<类型名>& 变量名)
函数调用：
函数名(变量名);
```
*这里加的const并不限制智能指针指向的内容，可以在函数中修改*


##### Return by value
指向一个local object
可以用作链式函数，进行链式编程
###### 语法
- 函数定义
```
unique_ptr<类型名> 函数名()
{
    unique_ptr<类型名> 变量名=make_unique<类型名>(赋值);
    return 变量名;
}
```
- 函数调用
```
函数名()->类的方法;
```

### shared_ptr/计数指针
计数指针又称共享指针
与unique_ptr不同的是它是可以共享数据的
允许多个指针指向同一个对象

#### 引用计数
- 每一个shared_ptr指针都有一个关联计数器，无论何时何地，当拷贝一个指针，计数器会+1
- 当对shared_ptr进行赋新值的操作时或shared_ptr被销毁（离开作用域），计数器-1
- 一旦一个智能计数器变为0，就会自动释放自己所管理的对象内存

shared_ptr创建了一个计数器，与类对象所指的内存相关联
Copy则计数器加一，销毁则计数器减一
查看计数器api为use_count()

**注意：**
如果把其中一个共享指针置空，那么它的计数也会归零，但是其他共享指针的计数不会归零

**注意：**
无论有多少个计数指针，它们指向的都是同一块内存，所以销毁时只销毁一次，当所有的计数指针都不指向这块内存，它才会被销毁



#### shared_ptr与函数调用
###### Passing by value
```copy```
在函数内部调用use_count计数器加一，在函数外部调用，计数器不变
 
###### Passing by reference
```const```表示不可改变指向

###### Return by value
链式调用
### shared_ptr与unique_ptr
#### 两者关系
不能将shared_ptr转换为unique_ptr
```unique_ptr``` 可以通过 ```std::move``` 转换为 ```shared_ptr```
#### 转换语法
```
	unique_ptr<类型名>独占指针名 = make_unique<类型名>(赋值);
	shared_ptr<类型名>计数指针名 = move(独占指针名);
```
使用了move之后，原来的独占指针就会自动置空
#### 常见的设计
将函数返回unique_ptr是一种常见的设计模式，可以提高代码的复用度，可以随时改变为shared_ptr

### weak_ptr/弱引用
它是管理shared_ptr的对象的智能指针，不控制所指向对象生存期的智能指针，weak_ptr并不拥有所有权时
#### weak_ptr的特点
- weak_ptr不能调用->和解引用*
- weak_ptr不能单独存在，一般是和shared_ptr一块存在，先创建一个shared_ptr，再创建weak_ptr
- weak_ptr可以调用use_count()函数查看计数器，但是计数器不会加一
#### weak_ptr的用途
- A类中有一个需求，需要存储其他A类对象的信息。如果使用shared_ptr，那么在销毁时会遇到循环依赖问题(Cyclic Dependency Problem)。所以我们这里需要用一个不拥有所有权的指针来标记该同类对象
- weak_ptr可以通过lock()函数来提升为shared_ptr（类型转换）
 

## 结构体/struct
结构体属于用户自定义的数据类型，允许用户存储不同的数据类型，把这些数据整合成一个整体进行处理
主要作用是封装，封装好处就是便于再次使用
结构体是C语言原本就有的功能
语法
```
struct 结构体名{结构体成员列表};
```

### 通过结构体创建变量的方式有3种：
1.
```
struct 结构体名 变量名;
  变量名.成员1值=  ;
  变量名.成员2值=  ;
```
2.
```
struct 结构体名 变量名={成员1值,成员2值...}
```
3. 定义结构体时顺便创建变量---这种方式不常用，不方便阅读和维护


### 结构体占用内存大小
结构体所占内存大小是最大数据类型大小的倍数
#### 当在计算结构所占内存大小时
首先按照struct中最大的数据类型进行单个分配，如果当前数据占用不了所有内存，同时剩下空间足有容纳下一个数据，则第二个数据不需要另外分配空间，否则重新分配一个最大类型的内存，以此类推

**空的struct默认大小1个字节**

例如：
```
struct MyStruct
{
    double x; //8
    int c;    //4
    char b;   //1
    float y;  //4
}
```
占用内存大小是24字节

#### 可以手动指定内存布局值
在结构体前加宏
```
#prama pack(push,x)//x是2的倍数
```
之后的所有结构体占用内存为x的倍数
上述结构体
如果添加 ```#prama pack(push,4)```，占用内存为20字节
如果添加 ```#prama pack(push,2)```，占用内存为18字节
如果添加 ```#prama pack(push,1)```，占用内存为17字节
**但是要注意，手动指定的内存布局值不宜过小**

在结构体后加
```
#prama pack(pop)
```
恢复默认对齐状态，之后结构体占用内存恢复为最大数据类型大小的倍数


### 结构体数组
将自定义的结构体放入数组中，方便维护
先定义结构体，再创建数组
语法
```
struct 结构体名 数组名[元素个数]={
  {结构体成员1值},{成员1值},{},...{}
  };
```
### 结构体指针
通过指针访问结构体中的成员
#### 语法
```
结构体名 * p=&结构体名
```
利用操作符->可以通过结构体指针访问结构体属性

### 结构体嵌套结构体
#### 作用
结构体中的成员可以是另一个结构体

### 结构体做函数参数
#### 作用
将结构体作为参数向函数中传递
#### 传递方式有两种
- 值传递
- 地址传递

### 结构体中const使用场景
#### 作用
用const来防止误操作

### typedef关键字定义别名
```
typedef struct PlayerData
{
   int x;
}PD;
//PD是PlayerData的别名，可以直接使用PD来代表PlayerData

typedef int* intptr;
//intptr是int*的别名
```

### C与C++中struct的区别
#### C语言中
- Struct是用户自定义数据类型（UDT）
- C语言中的struct是没有权限设置的
- C语言中的struct只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数
- struct中间的某个类型（例如int）不可以直接初始化
#### C++语言中
- Struct是抽象数据类型（ADT），支持成员函数的定义
- C++中struct增加了访问权限，且可以和类一样有成员函数。 C++中的struct等同于class,只是class默认成员权限是private，而struct默认成员权限是public
- C++中struct支持继承，可以继承结构体或类
- C++ struct里面成员初始化的形式和类是相同的，不可以直接初始化，就是不可以定义成员的时候同时初始化

### C++中struct和class的区别
- 使用struct和class定义类唯一的区别就是默认的访问权限不同。struct默认的访问权限是public,而class默认的访问权限是private



*如果没有多态和虚拟继承，在C++中，struct和class的存取效率完全相同*

*如果不是为了和C兼容，C++中就不会有struct关键字。因此，如果不需要与C兼容或传递参数给C程序，不要在C++中用struct*


## 联合体 ```union```
### 定义
union是一种“类似”于struct的联合体，联合的所有成员引用的是内存中的相同位置，以最大的成员的内存长度作为union的内存大小。union主要用来节省空间，默认的访问权限是公有的
### 注意点
- 同一个内存段可以用来存放几种不同类型的成员，但在每一个时刻只能存在其中一种，而不能同时存放几种，即每一瞬间只有一个成员起作用，其它的成员不起作用，不能同时都存在和起作用
- 共用体变量中起作用的成员是最后一个存放的成员，在存入一个新的成员后，原有的成员就会失去作用，即所有的数据成员具有相同的起始地址
### union的内存分配
union内存大小以最大成员的内存大小作为自己的内存大小，因为并且各成员共享内存，变量都是从相同的首地址开始存储的
### union和struct的区别
- union和struct都是由多个不同的数据成员组成，但是union所有成员共享一段内存地址，只存放最后一次赋值的成员值，而struct可以存放所以有成员的值
- union的大小是所有成员中所占内存最大的成员的大小，struct是所有成员的大小的和

## system
```
system("pause");
```
按任意键继续
```
system("cls");
```
清屏

## 大端和小端
计算机中以字节为单位 每个地址对应一个字节 一个字节8bit
如果存储空间大于1个字节 就需要区分字节顺序（大端顺序 小端顺序）
### 定义
- 大端模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中
- 小端模式，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中
### 有大小端的原因
因为在计算机系统中，是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式

**网络字节序一般是大端，主机字节序一般是小端**

### 高字节和低字节


# C++核心编程
面向对象
面向对象编程的核心活动：**确定职责**
## 左值与右值
### 左值
左边的值
- 值是可以获取地址并在以后使用的东西
### 右值
右边的值
- 右值本质上是暂时的或临时的值，无法获取地址

左值可以获取地址，可以不需要copy

右值都是临时的，&&可以存储右值，这种方式不执行copy，性能会更好
### 语法
```
int a = 1;
int b = 2;
int x = a + b;
int && y = a + b;
```
x和y的结果都是3，但是y的运算速度更快，因为不用执行copy

## 内存分区模型
C++程序在执行时，将内存大方向划分为4个区域
| 区域    | 说明                                                             |
|:---------|:-----------------------------------------------------------------|
| 代码区   | 存放函数体的二进制代码，由操作系统进行管理                     |
| 全局区   | 存放全局变量、静态变量以及常量                                  |
| 栈区     | 由编译器自动分配和释放，存放函数的参数值、局部变量等            |
| 堆区     | 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收    |

### 内存四区意义
不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活性

### 程序运行前
在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域
##### 程序代码区
存放CPU执行的机器指令，存放函数体的二进制代码，Code区
代码区两个特点
1. 代码区是共享的，目的是对于频繁被执行的程序，只需要在内存中有一份代码即可，减少系统运算量
2. 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令
##### 静态/全局区
数据区，全局变量和静态变量存放在此，该区域的数据在程序结束后由操作系统释放，未初始化的数据存放在.bss段，初始化的会放在.data段
##### 字符/常量区
全局区还包含了字符/常量区，字符串常量和其他常量也存放于此

###### 📂 放在全局区的

| 类型                  | 说明                                                             |
|:----------------------|:-----------------------------------------------------------------|
| 全局变量               | 定义在 `main` 函数或其他函数之外的变量                           |
| 静态变量               | 使用 `static` 关键字修饰的变量                                   |
| 常量（存放在常量区）   | 包含以下两类：                                                   |
| ├─ 字符串常量          | 由双引号括起来的字符串                                           |
| └─ const 全局变量      | 定义在 `main` 函数或其他函数之外，使用 `const` 修饰的变量（全局常量） |

---

###### 📂 不放在全局区的

| 类型                  | 说明                                                             |
|:----------------------|:-----------------------------------------------------------------|
| 局部变量               | 定义在 `main` 函数或其他函数内的变量                             |
| const 局部变量         | 定义在 `main` 函数或其他函数内，使用 `const` 修饰的变量（局部常量） |


### 程序运行后
#### 栈区
由编译器自动分配释放，存放函数的参数值、局部变量等
**注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放**
编译器为了防止误删，会将数据保留一次，之后就不会再保留了
函数的局部变量和形参都会在函数运行结束后自动释放
指针本质上也是个局部变量，也是放在栈区
变量的生命周期由scope（作用域）决定
#### 堆区
由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
在C++中主要利用new关键字在堆区开辟内存数据
##### 语法
```
new 数据类型（数据），它的返回值是一个地址，需要用指针接收
```
例如：
```
int * p = new int(10);
```
变量的生命周期完全由开发者决定，与scope（作用域）无关
**栈区在内存中是一块很小的空间，而堆区是一块非常大的空间，所以在使用类实例化对象时，为防止内存溢出，一般都是在堆区开辟内存空间**
```
高位
        ┌────────────────────┐
高地址  |        内核         |
        ├────────────────────┤     -
        |                    |     |
        |  栈区（从高到低）   |     |
        |                    |     |
        ├────────────────────┤     |进程结构
        |       缓冲区       |     |
        ├────────────────────┤     |
        |                    |     |
        |                    |     |
        |  堆区（从低到高）   |     |
        |                    |    |
        |                    |    |
        ├────────────────────┤    |     -
        |       .BSS段       |    |     |
        ├────────────────────┤    |     |可执行文件结构
        |全局区（静态Static） |    |     |
        ├────────────────────┤    |     |
        |只读常量区（const）  |    |     |
        ├────────────────────┤    |     |
低地址  |       代码段        |    |     |
        └────────────────────┘    -     -
                                低位
```

### 堆区开辟内存
#### new操作符
C++中利用new关键字在堆区开辟内存
堆区由程序员手动开辟、分配和释放，手动释放使用delete关键字
##### 语法
```
new 数据类型（数据）;
```
它的返回值是一个地址，需要用指针接收

例如：
```
int a=10;
int * p = new int(a);
或
int * p = new int(10);
或
int * p{ new int { 10 } };
```
**注意new操作符开辟的内存会自动初始化，如果没有赋值，会赋默认值**

#### 释放语法
```
delete p;
p=nullptr;
```
**注意delete后建议直接赋值nullptr**
**注意多次delete会使程序崩溃**
**可以重新对已经销毁的指针进行赋值，不用声明**

可以用 ```!p==nullptr``` 来判断指针是否销毁


**堆区开辟内存容易出现的内存泄漏错误**
1. 忘记delete
2. 重新指向导致内存泄漏--在指针重新指向之前，也要先释放指针

正确做法：
```
int *p=new int(10);
delete p;
p=nullptr;
p=new int(20);
```

#### 堆上数组
##### 语法
```
new 数据类型[数组长度];
```
例如：
```
int * pArray = new int[10];        //数组无初始值
或
int * pArray = new int[10]{1,2};   //数组有初始值
或
int * pArray { new int[10] };      //数组无初始值
或
int * pArray { new int[10]{1,2} }; //数组有初始值
```
访问数组可以使用 ```p[i]``` 或 ```*p``` ```*(p+1)```

###### 释放语法
```
delete [] pArray;
pArray=nullptr;
```
**注意：```sizeof(pArray)``` 的返回值是指针的长度**

堆上的数组不支持很多数组操作
1. 不支持 ```std::size``` 函数
2. 不支持 ```auto```

**在堆上使用数组，需要手动控制很多东西，不小心就会出安全问题，最好的方式是用vector动态数组来替代**

##### 栈和堆的比较
- 申请方式
  - 栈由系统自动分配
  - 堆是由开发者申请
- 申请效率
  - 栈的分配速度较快
  - 堆是由new分配，速度较慢且容易产生内存碎片，使用方便
- 申请大小限制
  - 栈在windows下，是由高地址向低地址扩展的数据结构，是一块连续内存。能从栈中获取的空间总量较小（1M-2M）如果空间不足提示Overflow
  - 堆是从低地址到高地址扩展的数据结构，是不连续的内存区域。堆的大小受限于操作系统中有效的虚拟内存。灵活，可以获取的空间足够大
- 系统响应
  - 栈：只要系统剩余空间大于申请的空间，就一定可以申请成功，否则报错：栈溢出
  - 堆：当堆有申请空间的请求，首先遍历空闲地址链表。寻找第一个空间大于申请空间的堆节点。把节点从链表中删除，把空间分配给程序

### 动态内存分配（C语言）
#### 开辟内存
```
malloc(memory allocation)
```
用户分配size个字节的内存，并返回内存分配后的地址，如果分配失败，返回0
**注意：返回的地址是void*类型，获取时需要进行类型转换**
**注意：malloc与new不同，如果开辟内存时没有赋值，不会进行初始化**
```
calloc
```
在内存中分配n个长度为size的连续空间，返回一个指向分配后首地址的指针，如果不成功则返回0
```
realloc
```
重新分配内存
先判断当前指针是否有足够的连续空间，如果有，就扩大地址，将原地址返回
如果空间不足够，会按照新的大小重新开辟新的内存空间，将原有数据进行拷贝到新内存，而
后释放原有地址的内存（自动释放）
#### 释放内存
##### free
释放内存，与delete相同，delete的内部实现原理就是free
###### 语法1
```
free(指针名);
指针名=0;
```
###### 语法2
```
free(指针名);
指针名=nullptr;
```
###### 语法3
```
free(指针名);
指针名=NULL;
```
###### 语法4
```
free(指针名);
指针名=0x00000000;
```
#### memset
初始化内存
##### 语法
```
memset(指向堆区内存的指针名,字节赋值,该块内存的字节数);
```
例如
```
int* p = new int[100];
memset(p, 0, 400);//100个int值占400字节，赋值0
```
**注意，memset初始化内存，是按字节赋值**
```memset(p, 1, 400)``` 是对p指向的400个字节依次赋值
1Byte=8bit 赋值为0000 0001
int占用4Byte，赋值为0000 0001 0000 0001 0000 0001 0000 0001
赋值结果并不是1
#### memcpy
内存复制

例如
```
int a[5]{ 100,101,102,103,104 };
int*p = new int[5];
memcpy(p, a,5* sizeof(4));
```
### malloc/free和new/delete的区别
#### 共同点
- 都是从堆上申请空间，并且需要用户手动释放。
#### 不同点
- malloc和free是函数，new和delete是操作符
- malloc申请的空间不会初始化，new可以初始化
- malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可
- malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型
- malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常（底层区别）
- 申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理（底层区别）

### 内存泄漏
#### 什么是内存泄漏
内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费（内存泄漏是指针丢了）
#### 内存泄漏的危害
长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死
#### 内存泄漏分类
C/C++程序中一般我们关心两种方面的内存泄漏：
###### 堆内存泄漏(Heap leak)
堆内存指的是程序执行中依据须要分配通过 ```malloc/calloc/realloc/new``` 等从堆中分配的一块内存，用完后必须通过调用相应的free或者delete删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak
###### 系统资源泄漏
指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定
#### 如何避免内存泄漏
- 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。这是理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要智能指针来管理才有保证
- 采用RAII思想或者智能指针来管理资源
- 有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项
- 出问题了使用内存泄漏工具检测。但是很多工具都不够靠谱，或者收费昂贵
#### 总结
内存泄漏非常常见，解决方案分为两种
- 事前预防型。如智能指针等
- 事后查错型。如泄漏检测工具



## 引用（reference）
引用变量是别名，是某个已存在变量的另一个名字
### 作用
给变量起别名
### 语法
```
数据类型 &别名=原名
```
### 注意事项
1. 引用必须初始化，即必须要给初始值，引用的初始值必须是一个与它类型相同的对象
2. 引用在初始化后，不可以改变，可以重新赋值，但是不能更改引用，即原名和别名会同步变化
3. 引用必须引一块合法的内存空间
4. 不需要解引用*，就可以读取和写入数据

### 引用的优缺点
#### 优点
1. 因为必须初始化，所以比指针安全
2. 因为不需要解引用，所以比指针更好理解
#### 缺点
不如指针强大灵活

### 引用做函数参数
#### 作用
函数传参时，可以利用引用的技术让形参修饰实参
#### 优点
可以简化指针修改实参

### 引用做函数的返回值
引用可以作为函数的返回值存在
#### 用法
函数调用作为左值
#### 注意
1. 不能返回局部变量的引用
2. 如果函数做左值，那么必须返回引用

### 引用的本质
引用的本质在C++内部实现是一个指针常量，它的指针相关操作，编译器自动做好了
C++推荐用引用技术，因为语法方便
引用就是固定指向的指针
引用就是 ```*const```

### 常量引用
#### 作用
常量引用主要用来修饰形参，防止误操作
在函数形参列表中，可以加const修饰形参，防止形参改变实参
```int &ref=10``` 是非法操作，因为10在常量区，不在栈区或堆区
加上const后
```const int &ref=10``` 是可以的，
编译器会自动将代码修改为
```
int temp=10;
const int & ref=temp;
```
相当于指针的 ```const int const*```


### 总结
1. 在引用的使用中，单纯给某个变量起别名是毫无意思的，引用的目的主要用于函数参数的传递中，解决大块数据或对象的传递效率和空间不如意的问题
2. 用引用传递函数的参数，能保证参数在传递的过程中不产生副本，从而提高传递效率，同时通过const的使用，还可以保证参数在传递过程中的安全性
3. 引用本身是目标变量或对象的别名，对引用的操作本质上就是对目标变量或对象的操作。因此能使用引用时尽量使用引用而非指针
4. 没有void类型的引用



# 类和对象
C++面向对象的三大特性
- 封装(Encapsulation)
- 继承(Inheritance)
- 多态(Polymorphism)

C++认为万事万物皆为对象，对象上有其属性和行为
例如：
- 人可以作为对象，属性有姓名、年龄、身高、体重等，行为有走、跑、跳跃、吃饭、唱歌等
- 车也可以作为对象，属性有轮胎、方向盘、车灯等，行为有载人、放音乐、开窗等
- 具有相同性质的对象，我们可以抽象成为类，人属于人类，车属于车类

## 面向过程和面向对象
是两种编程思想
### 面向过程PO(Procedure Oriented)
根据程序执行的顺序来设计软件的模块或细节
解决一个问题的时候，面向过程会把事情拆分成一个个的过程（方法）和数据（传入方法的参数），然后依次执行过程（方法），直到结束
#### 优点
比面向对象性能好
#### 缺点
易读性差，代码扩展性差，维护和更新的成本比较大
### 面向对象OO(Object Oriented)
用计算机来描述客观事实
当解决一个问题时，面向对象会把问题里的事物抽象成对象的概念
首先创建这个问题里面的所有对象
然后给这些对象赋予一些属性和方法
然后执行每个对象的方法，去解决问题
#### 优点
易读性、扩展性较好
#### 缺点
性能有一定损失，但是C++的面向对象性能和C几乎完全一样，同时也有很多性能优化技巧

## 类（class）和结构体（struct）的不同
```struct``` 的属性是 ```public```
```class``` 的属性是 ```private```

## 面向对象编程的特性
抽象 封装 继承 多态

## 抽象
抽象是面向对象编程的第一步，从单细胞到高等生物进化的过程
C++的基本数据类型不足以描述事物的全部特点，所以需要做自定义类型
### struct和class
class是对struct进行了扩展，class比struct更加适用于面向对象

抽象是事物抽象出有限个特性，并使用类来进行描述，抽象就是用来描述数据的

## 封装/Encapsulation
封装是C++面向对象三大特性之一
把事物封装成类，类可以把自己的数据和方法只对特定的类或方法开放（友元、限定符）
### 定义
- 隐藏对象的属性和实现细节，仅仅对外部提供公开的接口来与对象进行交互，将数据和操作数据的方法进行有机结合
- 数据隐藏：将数据放到类的私有或者保护部分
- 私有成员函数：将实现的细节隐藏在私有或者保护部分
- 封装的另一个表现就是将函数定义和声明分别放在不同的文件中.h .cpp
- 数据隐藏不仅可以防止直接访问数据，同时保证数据的安全性
- 使用者无需关心数据是如何表示的，只需要知道各种public成员函数的功能即可
- 当类的内部实现细节发生变化时，不会影响到使用者
- 封装利用访问权限划分出来类的外观和内脏，让数据和方法有机结合，并为后续的继承和多态提供基础
### 目的
目的是减少依赖，提高可维护性
 
### 封装的意义
#### 封装的意义1：
1. 将属性和行为作为一个整体，表现生活中的事物
2. 将属性和行为加以权限控制

##### 语法
```
class 类名{  访问权限:属性（通常使用变量）/行为（通常使用函数）};
```
类中的属性和行为统称为成员
| 分类 | 名称       |
|:------|:------------|
| 属性 | 成员属性     |
| 属性 | 成员变量     |
| 行为 | 成员函数     |
| 行为 | 成员方法     |

#### 封装的意义2：
类在设计时，可以把属性和行为放在不同的权限下，加以控制
访问权限有3种：
| 权限级别 | 访问权限  | 权限说明                                           |
|:------------|:------------|:--------------------------------------------------|
| 公共权限     | public      | 类内可以访问，类外也可以访问                          |
| 保护权限     | protected   | 类内可以访问，类外不可以访问，子类可以访问父类的保护权限内容 |
| 私有权限     | private     | 类内可以访问，类外不可以访问，子类不可以访问父类的私有权限内容 |


### 类的规范书写方法
一个类由一个头文件和一个源文件组成（.h文件 .cpp文件）
- ```.h``` 头文件中包含变量的声明、函数的声明、宏定义
头文件中要书写宏 ```#pragma once```，防止头文件重复包含
- ```.cpp``` 源文件中函数的具体实现.

成员变量一般都要设为私有，利用Getter和Setter来访问，函数一般都设为共有，供外部访问


### struct和class的区别
在C++中，struct和class唯一的区别在于默认的访问权限不同
- struct默认权限为共有
- class默认权限为私有

### 成员属性设置为私有
#### 优点1
将所有成员属性设置为私有，可以自己控制读写权限
#### 优点2
对于写权限，可以检测数据的有效性


*在类中，可以让另一个类作为本类的成员*

**如果调用别的头文件或源文件中的类的成员函数，在成员函数前加 
```类名::```  即作用域**


## 对象的初始化和清理
相当于出厂设置和恢复出厂设置
C++中的面向对象来源于生活，每个对象都会有初始设置和对象销毁前清理数据的设置

### 实例化对象的基础方法
#### 方法1--在栈区实例化
```
类名 对象名;  //已经开辟内存，对象存储在栈区，数据由编译器开辟和释放内存
```
#### 方法2--在堆区实例化
```
类名 *p =NULL;  //声明一个类名类型的指针指向NULL，未开辟内存，p存储在栈区
p=new 类名();   //开辟内存，实例化对象，程序员自己申请的内存，存储在堆区，需手动释放内存

delete p;       //释放内存
p=nullprt;      //指针置空
```
或者
```
类名 *p =new 类名();

delete p; 
p=nullprt;  
```

## 构造函数（constructor）和析构函数
对象的初始化和清理也是两个非常重要的安全问题

一个对象或变量没有初始状态，对其使用后果是未知的

同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供。但是编译器提供的构造函数和析构函数是空实现

### 构造函数
主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用

#### 构造函数语法
```
类名(){}
```
如果保持系统默认的构造函数，可以写成 ```类名()=default```
1. 构造函数，没有返回值，也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时会自动调用构造，无需手动调用，而且只会调用一次
5. 一般用于初始化实例属性

### 析构函数
主要作用在于对象销毁前系统自动调用，执行一些清理工作

#### 析构函数语法
```
~类名(){}
```
1. 析构函数，没有返回值，也不写void
2. 函数名称与类名相同，在名称前加符号~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次

### 构造函数的分类及调用
两种分类方式
#### 按参数分为：有参构造和无参构造(默认构造)
- 无参构造(默认构造)
```
person(){}
```
- 有参构造
```
person(int a){}
```
或
```
person(const int & a){}
```
#### 按类型分为：普通构造和拷贝构造
- 拷贝构造
```
person(const person & p){}
```

### 构造函数的另一种写法
例如：类person有两个属性name和age
```
person(string &name,int &age):name(name),age(age){}
```
类person有两个属性name和*age（这种方式要记得在析构函数中释放堆区数据）
```
person(string &name,int age):name(name),age(new int(age)){}
```
还可以分成传入不同数量的参数
例如：类person有3个属性：p_name、p_age、p_height
```
person(string &name,int &age,int &height):p_name(name),p_age(age),p_height(height){}
person(string &name,int &age):person(name,age,0){}
person(string &name):person(name,0){}
```
### 三种调用方式：
#### 1.括号法
小括号传需要的参数类型
| 构造函数类型     | 示例                   | 说明                       |
|:-----------------|:-----------------------|:---------------------------|
| 默认构造函数     | `person p1;`           | 不带参数的构造函数，创建对象时不初始化任何成员变量  |
| 有参构造函数     | `person p2(10);`       | 带有参数的构造函数，用指定的参数初始化对象成员  |
| 拷贝构造函数     | `person p3(p2);`       | 使用另一个相同类型的对象来初始化一个新对象  |


#### 2.显示法：
| 构造函数类型     | 示例                        | 说明                                      |
|:-----------------|:----------------------------|:------------------------------------------|
| 默认构造函数     | `person p1;`                | 不带参数的构造函数，创建对象时不初始化任何成员变量 |
| 有参构造函数     | `person p2 = person(10);`   | 带有参数的构造函数，用指定的参数初始化对象成员 |
| 拷贝构造函数     | `person p3 = person(p2);`   | 使用另一个相同类型的对象来初始化一个新对象 |

**注意：```person(10)``` 单独写就是匿名对象，匿名对象在当前行结束之后，马上析构**

#### 3.隐式转换法
直接写传参的数据，编译器会转成显示法
| 构造函数类型     | 示例                  | 说明                                      |
|:-----------------|:----------------------|:------------------------------------------|
| 默认构造函数     | `person p1;`          | 不带参数的构造函数，创建对象时不初始化任何成员变量 |
| 有参构造函数     | `person p2 = 10;`     | 带有参数的构造函数，用指定的参数初始化对象成员 |
| 拷贝构造函数     | `person p3 = p2;`     | 使用另一个相同类型的对象来初始化一个新对象 |


**注意：C++中的隐式转换是非常容易犯错误的地方**
C++默认开启了隐式转换
其他类型很容易就会转换成自定义的类
*在构造函数前加explicit，可以关闭隐式转换*


**注意：**
1. 调用默认构造函数时，不要加()，因为加了(),编译器会认为是一个函数声明，不会认为是在创建对象
2. 不要用拷贝函数初始化匿名对象，编译器会认为 ```Person(p3)===Person p3```
3. 如果构造函数中分配了堆空间，在析构函数中需要销毁

### 默认构造函数 ```Default Constructor```
```default``` 是C++11添加的新的关键字
在已经定义了有参构造函数后，系统的默认构造函数会被屏蔽
```default``` 关键字就是可以让系统默认的构造函数恢复
#### 语法
```
person()=default;
```

### 拷贝构造函数 ```Copy Constructor```
特殊的构造函数，创建对象时，使用同一个类型之前创建的对象来初始化新对象
如果类中没有定义拷贝构造，编译器会自动定义一个
拷贝构造函数在创建对象时，是同一类中创建的对象来初始化新创建的对象
#### 用处
1. 创建新对象
2. 函数传参
3. 复制对象

**特别要注意的是：拷贝构造函数传入参数一定要是引用传递，不能用值传递，因为如果是值传递，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。如此循环，无法完成拷贝，栈也会满**

#### 拷贝构造函数调用时机
C++中拷贝构造函数调用时机通常有3种情况：
1. 使用一个已经创建完毕的对象来初始化一个新对象
2. 值传递的方式给函数参数传值
3. 以值方式返回局部对象

### 构造函数调用规则
默认情况下，C++编译器至少给一个类添加3个函数
1. 默认构造函数（无参，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：
- 如果用户定义有参构造函数，C++不再提供默认无参构造，但会提供默认拷贝构造
- 如果用户定义拷贝构造函数，C++不会再提供其他构造函数

### 深拷贝和浅拷贝
深浅拷贝是面试经典问题，也是常见的坑
堆区数据会受影响，栈区不受影响
当数据成员中有指针时，必须要用深拷贝
- 浅拷贝
简单的赋值拷贝操作，即等号赋值操作
- 深拷贝
在堆区重新申请空间，进行拷贝操作

堆区数据浅拷贝时拷贝的是地址，即两个类的数据地址相同，会同时改变，手动释放时会同时释放，如果两个都手动释放，就会出现内存重复释放
深拷贝就是重新在堆区申请内存，把数据拷贝到新的地址上

析构函数主要用来将堆区开辟的数据手动进行释放

浅拷贝带来的问题就是堆区的内存重复释放

**如果属性有在堆区开辟的，一定要自己提供拷贝构造函数进行深拷贝，防止浅拷贝带来的堆区的内存重复释放的问题**

### 初始化列表
#### 作用
C++提供了初始化列表语法，用来初始化属性
#### 语法
```
构造函数():属性1(值1),属性2(值2),...{}
```
如果初始化时在外部赋值，可以
```
构造函数(值1类型 a,值2类型 b，...):属性1(值1),属性2(值2),...{}
```
在创建类成员时可以直接赋值

### 类对象作为类成员
C++类中的成员可以是另一个类的对象，称该成员为对象成员
*当其他类对象作为本类成员，构造时先构造类对象，再构造自身；析构顺序与构造顺序相反*

### ```Move Constructor/move```构造函数
可以提升性能，但是比较复杂，使用不多
Move Constructor从一些临时值获取数据
在构造函数中用&&修饰，即右值引用
调用时用 ```srd::move``` 来表示调用Move Constructor


## 方法与属性
程序=算法+数据结构
### 属性
- 对象相关的属性
- 类相关的属性，即类属性，类属性必须在主函数之外初始化
### 方法
- 构造函数，一般会在构造函数中给属性赋值
- Getter和Setter
- 普通方法

## 静态成员
静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员
### 静态成员特点
1. 静态属于类，不属于对象
2. 静态成员可以通过对象访问，也可以通过类名::进行访问
3. 静态存储在内存的静态全局区域
4. 静态函数只能访问静态成员变量，不能访问实例成员变量
5. 静态数据所有的对象共享

静态成员分为静态成员变量和静态成员函数

### 静态成员变量
静态成员变量不属于某个对象上，而是所有对象共享同一份数据
在编译阶段分配内存，分配在静态全局区
#### 初始化
类内声明，类外初始化
静态成员的初始化，不能放在类的内部定义
必须在外部使用范围解析运算符 ```::``` 来进行初始化

类外初始化格式是
```
变量类型名 类名::变量名=值;
```
#### 访问
静态成员变量有3种访问方式：
1. 通过对象进行访问
```
类名 p;
p.静态变量
```
2. 通过对象指针进行访问
```
p->静态变量
```
3. 通过类名进行访问
```
类名::静态变量
```
要注意静态成员变量是有访问权限的

区分以下四种成员变量
| 成员类型          | 示例                    | 说明                                           | 存储位置      |
|:------------------|:------------------------|:-----------------------------------------------|:-------------|
| 实例变量          | `int a;`                | 普通的成员变量，跟随类实例化后的对象            | 栈区或堆区    |
| 静态变量          | `static int b;`         | 静态变量，所有实例化后的对象共享一份副本        | 静态全局区    |
| 实例常量          | `const float c = 0.5f;`| 常量，值无法修改，跟随类实例化后的对象          | 栈区或堆区    |
| 静态常量          | `static const int d = 99;`| 静态常量，只有一份副本且无法修改                | 静态全局区    |


### 静态成员函数
所有成员共享同一个函数
静态成员函数只能访问静态成员变量，因为如果不是静态成员变量，那么静态成员函数无法区分它是哪个成员的变量
静态成员函数有3种访问方式：
1. 通过对象进行访问
```
类名 p;
p.静态成员函数
```
2. 通过对象指针进行访问
```
p->静态成员函数
```
3. 通过类名进行访问
```
类名::静态成员函数
```
要注意静态成员函数是有访问权限的


## C++对象模型和this指针
### 成员变量和成员函数分开存储
在C++中，类内的成员变量和成员函数分开存储
只有非静态成员变量才属于类的对象上

空对象占用内存空间为1
C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置
每个空对象也应该有一个独一无二的内存地址

| 类型               | 描述                               | 归属                                  |
|:-------------------|:-----------------------------------|:--------------------------------------|
| 非静态成员变量     | 属于类的实例对象                   | 每个对象有自己的副本                  |
| 静态成员变量       | 不属于类的实例对象                 | 所有对象共享一份静态成员变量的副本    |
| 非静态成员函数     | 属于类的实例对象                   | 每个对象有自己的副本                  |
| 静态成员函数       | 不属于类的实例对象                 | 所有对象共享一份静态成员函数的副本    |


#### 类占用内存空间大小的原则
- 空类隐含1个字节，因为每一个对象实例化都需要在内存中分配一个独一无二的地址
- 普通成员函数与大小无关，仅成员变量和大小有关
- 普通数据成员，const数据成员占空间，普通函数，静态数据成员，静态函数不占空间
- 类的总大小也遵循内存字节对齐原则，和Struct同理
- 当类中存在虚函数，则需要一个虚函数指针管理维护虚函数表，所以占据一个指针大小 即4字节
- 无论有多少个虚函数存在，都只需要一个虚函数指针，所以说虚函数指针是独一无二的
- 当有继承关系存在时，子类大小是所有基类成员和子类成员的总和

### this指针
#### 概念
- C++中成员变量和成员函数是分开存储的
- 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会公用一块代码
- 每一个类成员函数都包含一个名为this的隐藏指针（包括构造和析构）
- 该指针即为当前对象的地址


这一块代码是如何区分哪个对象调用自己的？
- C++通过提供特殊的对象指针，this指针，解决上述问题，this指针指向被调用的成员函数所属的对象
- this指针不需要定义，直接使用即可
- this指针的本质是指针常量，指针的指向是不可修改的，但是指向的值是可以修改的

#### this指针的用途
1. 当形参和成员变量同名时，可用this指针来区分，解决命名冲突
2. 打印对象地址
3. 链式调用可以返回引用，也可以返回指针
在类的非静态成员函数中返回对象本身，可使用 ```return *this```

#### 空指针访问成员函数
C++中空指针也是可以调用成员函数的，但是要注意有没有用到this指针
如果用到this指针，需要加以判断保证代码的健壮性


## const修饰成员函数
### 常函数
成员函数后加const，我们称这个函数为常函数
常函数内不可以修改成员属性
成员属性声明时加关键字mutable后，在常函数中依然可以修改
```
class person
{
void func()const
  {
   }
}
```
相当于 ```const person * const this```
this指针的指向和指向的值均不能修改
特殊变量，在声明前加 ```mutable```，即使在常函数中，也可以修改变量值


### 常对象
声明对象前加const，我们称这个对象为常对象
常对象只能调用常函数
成员属性声明时加关键字 ```mutable``` 后，在常对象中依然可以修改

### Getter和Setter
Getter返回属性值，类型为属性的类型
Setter修改属性值，类型为void

一般为了安全，需要把成员属性设为私有，然后添加Getter和Setter两个函数来获取和设置成员属性

一般Getter返回相应属性类型，Setter返回void
```
类型名 get_属性1()
{
   return this->属性1;
}

void set_属性1(类型名 变量)
{
   this->属性1=变量;
}
```

### Const Object
#### 不可变对象Const Object
在C++中，如果需要值保持不变，就应该使用const，这样可以用编译器来强制约束这个值
const也会给代码的编写带来难度
Const Object有三种形式
- 值
- 引用
- 指针

#### 不可变成员方法Const Method
- const实例不能调用不加const修饰的成员方法
- 必须限定方法为const，表示方法不会修改对象
如：
```
void get_name const()
```
#### const实例作为函数参数
Const Object作为形参的函数
- 在函数体中不能调用对象的非const方法

#### 可变对象与不可变对象
- 可变对象可以调用const值、引用、指针作为参数函数
- 不可变对象调用非const函数规则
- 不可变对象值可以调用非const函数
- 不可变对象引用不可以调用非const引用函数
- 不可变对象指针不可以调用非const指针函数
- 类设计时尽量使用const

#### 可变引用与不可变引用的动态返回
让函数可变对象返回可修改的引用，不可变的对象返回不可修改的引用，使代码更加具有扩展性

有一种写法是将Getter和Setter返回属性引用，即把Getter和Setter都写成两个同名函数，分别用来传入const和非const
```
  const Getter const
```
  Setter不设为void类型，而是返回引用直接修改

### mutable关键字
被mutable关键字标识的属性可以在const方法中进行修改
一般用于记录调用次数


## 友元
在C++的知识体系中有很多加锁和解锁的知识，友元就是一种解锁，是对封装的解锁
在程序里，有些私有属性，也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术
友元的目的就是让一个函数或类，访问另一个类中的私有成员
友元的关键字为 ```friend```
**友元可以提升类的访问权限，但是会导致数据的暴露，有安全性的隐患**
### 友元的三种实现
1. 全局函数做友元
2. 类做友元
3. 成员函数做友元

### 语法
把全局函数、类或类的成员函数的声明复制到另一个类中，前面加 ```friend```


### 友元函数
类的友元函数是定义在类的外部的函数，它不属于任何类，但是却有访问类的private和protected的成员的权限。它需要在类中定义加以声明，声明时只需要在友元的名称前加上关键字friend
#### 语法
```
friend 返回类型 函数名(参数);
```

### 友元类
友元类中的所有成员函数都是另一个类的友元函数
#### 注意
1. 友元是单向的
2. 友元关系不会被继承
#### 语法
```
friend class 类名;
```
### 打印类信息
#### ```std::ostream```表示输出流
打印类的信息只需要将```&operator<<函数（将ostream返回）```设为友元即可

注意：重载<<函数必须是全局函数，不能是成员函数，因为成员函数重载运算符只能传入一个参数，但是重载<<需要两个参数ostream和类

## 运算符重载
### 概念
对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型
### 特点
本质也是函数重载 遵循一些特定的规则
1. 重载运算符后 运算符的运算顺序和优先级不变
2.  不能创造新的运算符 6个运算符不能重载

| 运算符       | 说明                                         |
|:-------------|:---------------------------------------------|
| `?:`         | 条件运算符，基于条件表达式的值选择两个结果之一 |
| `.`          | 成员访问运算符，用于访问类的成员               |
| `::`         | 域运算符，访问类的静态成员或命名空间中的成员   |
| `sizeof`     | 长度运算符，返回数据类型或变量的字节大小       |
| `.*`         | 成员指针访问运算符，用于通过成员指针访问类的成员 |
| `#`          | 构串操作符，用于宏定义和预处理指令中的连接      |

3. 运算符重载是针对原有的符号进行适当的调整 一般不会修改运算符本来的意义


### 加号运算符重载
```
operator+
```
- 方法1：成员函数重载+号
- 方法2：全局函数重载+号

### 总结
1. 对于内置的数据类型的表达式的运算符是不可能改变的
2. 不要滥用运算符重载

### 左移运算符重载
#### 作用
可以输出自定义数据类型

左移运算符重载只能在全局函数中重载，因为成员函数中cout没法放在左边

cout是ostream类型的参数
```
ostream & operator<<(ostream &cout,person p)
{
	cout << "p_a=" << p.p_a;
	cout << "p_b=" << p.p_b;
	return  cout;
}
```
重载<<要返回一个cout,才能继续在后面链式赋值

### 递增运算符重载
#### 作用
通过重载递增运算符，实现自己的整型数据

重置前置++运算符  operator++()

```
	person & operator++()
	{
		age++;
		return *this;
	}
```

重置后置++运算符  operator++(int)
int代表占位参数，可以用于区分前置和后置递增
```
	person operator++(int)
	{
		person temp = *this;
		age++;
		return temp;
	}
```
**注意：前置递增要返回引用，后置递增要返回值**

### 赋值运算符重载
C++编译器至少给一个类添加4个函数
1. 默认构造函数（无参，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符operator=，对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题
因此如果数据在堆区，赋值操作需要做赋值运算符重载，使用深拷贝

### 关系运算符重载
#### 作用
重载关系运算符，可以让两个自定义类型对象进行对比操作

### 函数调用运算符()也可以重载
由于重载后使用的方式非常像函数的调用，因此称为仿函数
仿函数没有固定写法，非常灵活

### 匿名函数对象



## 继承 Inheritance
### 概念
继承是面向对象三大特性之一
- 让一个类拥有另一个类的状态和行为，前者可以不加修改地完全复用后者的实现，也可以对某些行为做出自己的实现
- 继承使子类除了拥有父类的属性和方法，还有自己的特性，而不需要编写相同的代码，C++的继承多种多样，且支持多继承，限定符推荐只使用public
- 继承是一种进化能力，祖先能力的继承，子孙具备自主提升自我的能力
- 承上启下的作用：继承必须建立在封装的基础上 同时只有实现了继承才能实现下一个特性--多态
- 节省公共代码，提升代码的复用性
- 继承的目的是复用代码

### 继承的优缺点
#### 优点
使创建和维护一个程序变得更加简单和方便，提升代码的重用性，提高代码执行效率
#### 缺点
会增加程序的耦合性
### 继承的基本语法
#### 语法
```
class 子类 : 继承方式 父类
```
子类(Sub Class)也叫派生类(Derived Class)
父类(Parent Class)也叫基类(Base Class)

派生类中的成员，包含两大部分：
- 一类是从基类继承过来的，一类是自己增加的成员
- 从基类继承过来的表现其共性，而新增的成员体现其个性

### 继承方式
继承方式有3种：
#### 1.公共继承
```
class 子类 : public 父类
```

| 父类访问权限   | 子类访问权限     |
|:--------------|:-----------------|
| `public`      | `public`         |
| `protected`   | `protected`      |
| `private`     | 子类不可访问     |


#### 2.保护继承
```
class 子类 : protected 父类
```

| 父类访问权限   | 子类访问权限     |
|:--------------|:-----------------|
| `public`      | `protected`      |
| `protected`   | `protected`      |
| `private`     | 子类不可访问     |


#### 3.私有继承
```
class 子类 : private 父类
```

| 父类访问权限   | 子类访问权限     |
|:--------------|:-----------------|
| `public`      | `private`        |
| `protected`   | `private`        |
| `private`     | 子类不可访问     |


**注意：父类 ```peotected``` 在子类的类中可以访问，但是在别的函数例如 ```main``` 函数中创建的子类是无法访问的**

### using提升继承权限
private继承会将父类的属性全部降级为private
可以通过using来重新赋给管理权限
protected
public
一般用来给函数提权

#### 语法
```
public:
   using 父类名::函数名;

protected:
   using 父类名::函数名;
```

### 继承中的对象模型
父类中所有非静态成员属性都会被子类继承下去
父类中私有成员属性是被编译器隐藏了，因此是访问不到的，但是确实被继承下去了

利用开发人员命令提示工具查看对象模型
- 步骤1：跳转盘符到文件所在盘符
```
F:
```
- 步骤2：跳转文件路径
```
cd 具体路径
```
- 步骤3：查看命名
```
dir
```
- 步骤4：查询类所占字节
```
cl /d1 reportSingleClassLayout类名 源文件名.cpp 
```
**注意是小写CL空格/小写D数字1**


### 继承中构造和析构顺序
子类继承父类后，当创建子类对象时，也会调用父类的构造函数
先构造父类，后构造子类；先析构子类，后析构父类
#### 子类调用父类有参构造方法
子类无论是有参构造还是无参构造，默认会调用父类的无参构造
如果想要调用父类的有参构造，使用下面的语法
```
子类型名(类型名 参数1,类型名 参数2):父类型名(参数1,参数2){子类有参构造实现};
```

### 子类继承父类中的所有数据和方法，但不会继承这些方法
1. 基类的构造函数、析构函数和拷贝构造函数
2. 基类的重载运算符
3. 基类的友元函数


### 继承同名成员处理方式
当子类与父类出现同名的成员时，会自动遮蔽父类的同名成员
#### 遮蔽
当子类中出现和父类相同的变量和函数时，父类的变量和函数会被系统遮蔽，通过 ```父类名::访问```
- 访问子类同名成员，直接访问即可
- 访问父类同名成员，需要加作用域
  - 子类对象可以直接访问到子类中同名成员
  - 子类对象加作用域可以访问到父类同名成员
  - 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数

#### 继承同名静态成员处理方式
静态成员和非静态成员出现同名，处理方式一致
- 访问子类同名成员，直接访问即可
- 访问父类同名成员，需要加作用域

### 继承的内存对象模型
当基类成员被遮蔽时，仍然会留在派生类对象的内存中，派生类新增的所有成员永远排在基类的后面

派生类的对象模型，会包含所有基类的成员变量（父亲 爷爷...），访问效率高，否则会导致经过好几层间接索引计算

*子类对象可以直接当做是父类对象使用*

*不管指向对象的指针如何变化，内存中的数据从未发生过改变*

### 多继承语法
C++允许一个类继承多个类
#### 语法
```
class 子类：继承方式 父类1,继承方式 父类2...
```
多继承可能会引发父类中有同名成员出现，需要加作用域区分
**C++实际开发中不建议用多继承**
多继承中如果父类中出现了同名情况，子类使用时要加作用域

#### 菱形继承
##### 概念
- 两个派生类继承同一个基类
- 又有某个类同时继承这两个派生类
- 这种继承称为菱形继承，或钻石继承

当菱形继承时，两个父类拥有相同数据，需要加以作用域区分
菱形继承会导致一个问题，继承的数据有两份，造成资源浪费

利用虚继承，可以解决菱形继承的问题
在继承方式前加 ```virtual``` 关键字
此时基类称为虚基类
继承的数据会变成只有一份
虚函数父类必须加 ```virtual`` 关键字，子类可加可不加

| 术语   | 含义                                       |
|:------|:------------------------------------------|
| `vbptr` | 虚基类指针，指向虚基类表格（vftable）的指针  |
| `v`    | virtual（虚拟）                           |
| `b`    | base（基类）                              |
| `ptr`  | pointer（指针）                            |

虚继承继承的是指针，指向的是惟一的数据


## 多态/Polymorphism
### 多态的基本概念
多态是C++面向对象三大特征之一
- 为不同数据类型的实体提供统一的接口，使用一个单一的符号来表示多个不同的类型。C++通过纯虚函数来实现接口的功能
- 封装和继承是为多态准备的。多态是面向对象的核心，是C++程序项目设计的基石
- 面向对象是使用多态性获得对系统中每个源代码依赖项的绝对控制的能力的
- 高内聚、低耦合是程序设计的目标（无论是否面向对象），而多态是实现高内聚、低耦合的基础
- 当类存在继承的层级结构，就会涉及到多态
- C++中的多态意味着，在调用函数时，会根据调用者的具体类型来执行不同的函数
- 目的是让代码更通用
- 多种形态（动态绑定 延迟绑定）
- 在实现上，封装和继承是编译器支持的，和运行时没有关系。只有多态是编译器和运行时的共同支持
- 多态是绝大部分的设计模式的基础
- 多态实现了面向接口编程（面向抽象编程）

### 面向对象的知识链条
- 在封装和继承的而基础上才能实现多态
- 有了多态才能真正意义上面向接口编程

### C++多态实现
一个接口，多种实现

### 多态的优点
1. 代码组织结构清晰
2. 可读性强
3. 利于前期和后期的扩展和维护

**在真实开发中，提倡开闭原则**
开闭原则：对扩展进行开放，对修改进行关闭

C++开发提倡利用多态设计程序架构，因为多态优点很多

### 多态分为两类
- 静态多态（静态绑定）
函数重载和运算符重载属于静态多态，复用函数名，根据不同的形参来决定调用的具体的同名函数
- 动态多态（动态绑定）
派生类和虚函数实现运行时多态，通过虚函数实现。以继承为前提，派生类重写基类的虚函数，必须由基类的指针指向派生类对象

#### 静态多态和动态多态区别
1. 静态多态的函数地址早绑定--编译阶段确定函数地址
2. 动态多态的函数地址晚绑定--运行阶段确定函数地址


### 静态多态
- 在编程语言和类型论中，多态（Polymorphism）指为不同数据类型的实体提供统一的接口
- 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数
- 静态绑定：将名称绑定到一个固定的函数定义，然后在每次调用该名称时执行该定义，这个也是常态执行的方式
#### 静态多态的缺点
在面向对象编程时，创建指针一般都是创建父类类型，然后指向子类，但是静态多态中，指针指向子类的时候调用的依然是父类中的函数

### 动态多态
动态多态要满足两个条件：
1. 有继承关系
2. 子类要重写父类函数

**动态多态在语法上和静态多态的区别：**
**动态多态在重写的函数前加virtual**

#### 动态绑定（Dynamic binding）
1. 实现继承
2. 父类、子类需要动态绑定的函数设置为虚函数，且函数要在子类中重写
3. 必须通过父类指针/引用（推荐指针）指向子类对象，然后调用

- 编译器晚绑定技术
编译时并不确定具体调用的函数，而是在运行时，依据对象类型来确定具体调用哪个函数
- 编译器早绑定技术
如果函数，不是虚函数，在编译期间编译器就已经确定了哪个函数会被调用，早期绑定


#### 函数重写和函数重载的区别
| 特性       | 定义                                      |
|:---------|:----------------------------------------|
| 函数重写   | 函数返回值类型、函数名、参数列表完全相同        |
| 函数重载   | 函数名相同，返回值类型和参数列表可以不同       |


#### 重载，重写和隐藏的区别
| 特性   | 定义                                      |
|:-----|:----------------------------------------|
| 重载   | 两个函数在同一个作用域下且函数名相同，函数参数和返回值类型没有要求 -- 静态多态  |
| 重写   | 两个函数分别在基类和派生类作用域中，且函数必须是虚函数，函数名、参数列表、返回值类型（协变除外）都相同 -- 动态多态 |
| 隐藏（重定义） | 两个函数分别在基类和派生类作用域中，函数名相同，同时不满足重写的条件，构成隐藏 |


#### 动态多态使用条件
父类的指针或者引用指向子类对象

动态绑定是有代价的，会占用更多的内存

#### 虚函数
虚函数是应在子类中重新定义的成员函数
关键字为 ```virtual```
在函数前加 ```virtual```

#### 重写和重写协变
##### 重写
父类的虚函数，在子类中出现（函数名相同，参数列表相同，返回类型相同）
##### 重写协变
父类的虚函数，在子类中出现。函数名相同，参数列表相同，返回类型是基类和派生类的指针和引用

#### 重写与隐藏的区别
##### 隐藏
在子类的作用域中，根据就近原则屏蔽父类的同名函数，只要同名就会构成隐藏
##### 重写
不仅要求子类函数同名，对参数列表和返回类型也有要求（重写协变除外）
重写可以被看做是一种特殊的隐藏，前提是基类必须声明是虚函数

**当派生类的虚函数构成重写 派生类可以省略virtual关键字**
**分文件编写时，.cpp文件中的虚函数实现不用加virtual，因为编译器只编译.h文件**

**虚函数的实现**
在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率



#### 多态的两个应用场景
1. 函数
2. 存储进入 ```Collections```

#### 多态与Collection（集合/数组）
Collection
- 可以存储值类型（并不满足多态）
- 可以存储指针类型
- 不可以存储引用

#### override的用法
override子类的自检功能
如果父类没有override所对应的方法，则报错

如果子类中把函数名拼写错了，编译器并不会报错，只在编译时报错查找不到函数定义。加了override之后，拼写错了直接会飘红
一般在使用多态时都要加override

##### 语法

###### 父类
```
virtual 返回类型 函数名(传入参数)；
```
###### 子类
```
virtual 返回类型 函数名(传入参数) override;
```
#### final的用法
final/最终，标识为final的子类不可重写
如果不想让子类重写，就加上final

#### 多态与Overloading
###### Overload（重载）
在C++中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载

多态对象不能调用子类重载函数，但可以调用父类重载函数


### 纯虚函数和抽象类
#### 纯虚函数
在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容
因此可以将虚函数改为纯虚函数
##### 纯虚函数语法
```
virtual 返回值类型 函数名 (参数列表)=0;
```
当类中有了纯虚函数，这个类也称为抽象类

#### 抽象类
- 抽象类是包含了纯虚函数的类---抽象类（接口类）
- 抽象类无法实例化对象，如果子类没有完成对父类纯虚函数的重写，那么子类也是一个抽象类，也无法实例化对象
- 抽象类本质是强制子类去完成父类虚函数的重写
- 纯虚函数格式
```
虚函数=0 virtual void Fun()=0;//纯虚函数的定义 不实现
```
#### 抽象类特点
1. 无法实例化对象
2. 子类必须重写抽象类中的纯虚函数，否则也属于抽象类


#### 接口式抽象类
C++中不存在接口的关键字，但是可以模拟接口
一个只有纯虚函数和没有成员变量的抽象类可以用来模拟在其他面向对象编程语言中的接口

### 析构函数与多态
-析构函数在值类型销毁时，会依次调用继承的析构函数
-但是在多态对象销毁时，只会调用父类的析构函数
-解决方法
  - 将析构函数设置为虚函数可以解决该问题

#### 虚析构和纯虚析构
- **注意虚析构非常重要，不注意的话可能会造成内存泄漏**
- 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码
- 解决方法
  - 将父类中的析构函数改为虚析构或者纯虚析构

#### 虚析构和纯虚析构共性
1. 可以解决父类指针释放子类对象
2. 都需要有具体的函数实现

#### 虚析构和纯虚析构区别
如果是纯虚析构，该类属于抽象类，无法实例化对象

#### 语法
##### 虚析构语法
```
virtual ~类名(){}
```
##### 纯虚析构语法
```
virtual ~类名()=0;
```
要注意纯虚析构要有具体的函数实现，不能只有声明，因为父类有可能也会在堆区有数据

#### 总结
1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
3. 拥有纯虚析构函数的类也属于抽象类

### 多态的原理
本质是地址覆盖
- 首先每一个类都有一个对应的虚函数表vtable，虚函数表用来存放函数地址（函数指针一维数组）
- 在定义虚函数的类中，都会有一个虚函数表指针vptr指向虚函数表
- 当构造子类对象时，需要先调用父类的构造，调用父类构造时编译器还无法确定是否有继承者
- 那么会先创建父类的虚函数表及虚函数表指针，指向的父类的虚函数地址
- 当执行到子类的构造函数时，会初始化子类的虚函数表和虚函数指针
派生类继承基类，意味着同时会继承基类的虚函数表
- 如果派生类实现了重写，那么派生类中的虚函数表会使用重写以后的函数地址覆盖原地址

#### 虚函数表的生成过程
1. 先将基类的虚表内容拷贝一份到派生类的虚表中
2. 派生类重写了基类中某个虚函数，用自己的虚函数覆盖父类中虚函数地址
3. 派生类自己新增的虚函数，在派生类中的声明次序增加到虚函数表的最后
4. 虚函数表存储在代码段，一个类的不同对象共用一个虚函数表


### 类型转换
多态对象的缺点
- 虽然可以动态地调用子类中的虚函数，但是却不能调用子类中的其他函数
- 类型转换是非常重要的概念，即把指向父类的指针转为指向子类的指针
#### static_cast/静态类型转换
##### 语法
```
子类类型名 * 指向子类的指针名=static_cast<父类类型名 *>(指向父类的指针名);
```

static_cast相当于C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换如non-const对象转为const对象，编译时检查，用于非多态和多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性

它主要有如下几种用法：
- 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换
  - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
  - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的
- 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum
- 把空指针转换成目标类型的空指针
- 把任何类型的表达式转换成void类型
**注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性**

#### dynamic_cast/动态类型转换
##### 语法
```
子类类型名 * 指向子类的指针名=dynamic_cast<子类类型名 *>(指向父类的指针名);
```
动态类型转换时，原类型必须符合以下三个条件中的任何一个：
1. 是目标类型的公有派生类
2. 是目标类型的共有基类
3. 就是目标类型

##### 注意
- 如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为nullptr。不会抛出异常
- 如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个std::bad_cast异常(该异常定义在typeinfo标准库头文件中)。用bad_cast& e来catch异常

- dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）

- 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。dynamic_cast是唯一无法由C语言旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作

- 尽量少使用转型操作，尤其是dynamic_cast，耗时较高，会导致性能的下降，尽量使用其他方法替代

##### 替代方法
- 使用typeid操作符作判定配合静态类型转换来替代动态类型转换
##### 示例代码
```
class ClassA{};
class ClassB:public ClassA{};
int main()
{
  ClassA* a=new ClassB();
  if(typeid(*a).name()==typeid(ClassB).name())
  {
    ClassB* b=static_cast<ClassB*>(a);
  }
}
```


### typeid()操作符
注意typeid是操作符，不是函数
它可以在运行时获知类型名称
#### 语法
```
typeid(变量).name()
```
注意不同的编译器可能结果不同

#### 用法
- 直接对类型名使用
例：
```
cout << "typeid(float)=" << typeid(float).name() << endl;
```
- 对对象使用
任何对象都可以，常量、变量、指针引用等
- 对指向子类的父类类型指针和引用
指向子类的父类类型指针会返回父类类型
而解引用后会返回子类类型


# 文件操作
程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放
通过文件可以将数据持久化
C++中对文件操作需要包含头文件 ```<fstream>```
## IO流
### IO
向设备输入数据或输出数据
### 输出流
向设备写入数据（IO设备 文件/string/控制台）
### 输入流
从设备读取数据

**注意要区分清楚输入和输出**
以程序为基准，输入到程序中是输入，从程序中输出是输出

文件类型分为两种
- 文本文件
文件以文本的ASCII码形式存储在计算机中
- 二进制文件
文件以文本的二进制形式存储在计算机中，用户一半不能直接读懂它们

## C语言文件操作
### 实现原理
C语言中实现了一个FILE结构体
### 文件打开
```
FILE* fopen(char*filepath,char*open_mode) 文件路径
```
#### 打开模式
| 模式    | 描述                                                       |
|:------|:--------------------------------------------------------|
| r     | 打开文件进行读取                                            |
| w     | 创建文件进行写入，如果文件存在，则删除原本的内容                     |
| a     | 追加，打开或创建文件，在文件尾部写入                           |
| r+    | 打开文件进行更新（读取和写入）                                |
| w+    | 创建文件进行更新，如果文件存在，则删除原本的内容                     |
| a+    | 追加，打开或创建文件进行更新，在文件尾部写入                       |

### 关闭文件
```
int flose(FILE*)
```
### 读写文件
#### 写入
| 函数       | 描述                     |
|:---------|:------------------------|
| int fputc | 写入整型数值               |
| int fputs | 写入字符串                 |
| int fprintf | 写入一个格式化字符串        |

#### 读取
| 函数        | 描述                             |
|:----------|:--------------------------------|
| int fgetc | 读取单个字符                       |
| char* fgets | 读取字符串（遇到EOF会退出）          |
| int fscanf | 读取字符串（遇到空格会停止读取）      |


fgets和fscanf的区别
- fgets
从文件中读取一行数据存入缓冲区，遇到回车或文件结束符才会结束，会在缓冲区多写入一个\0 就是读一行
- fscanf
从文件中读取一段数据存入到缓冲区，遇到空格或回车或文件结束符就会结束，会把空格或者回车转换为\0 就是读一段



## C++文件操作
操作文件的三大类
| 类        | 描述           |
|:--------|:--------------|
| ofstream | 写操作          |
| ifstream | 读操作          |
| fstream  | 读写操作        |


### 文本文件
#### 写文件
##### 写文件的步骤
1. 包含头文件
```
#include<fstream>
```
2. 创建流对象
```
ofstream 对象名;//对象名一般用ofs，ofstream即out file stream 输出到文件流
```
3. 打开文件
```
ofs.open("文件路径",打开方式);
```
4. 写数据
```
ofs<<"写入的数据";
```
5. 关闭文件
```
ofs.close();
```
##### 文件打开方式
| 标志          | 描述                          |
|:------------|:-----------------------------|
| ios::in     | 为读文件而打开文件              |
| ios::out    | 为写文件而打开文件              |
| ios::ate    | 初始位置：文件尾                 |
| ios::app    | 追加方式写文件                  |
| ios::trunc  | 如果文件里有数据，就先清空数据，再写入 |
| ios::binary | 二进制方式                       |

**注意：文件打开方式可以配合使用，利用 ```|``` 操作符**
例如：用二进制方式写文件
```
 ios::binary | ios::out
```

##### 总结
1. 文件操作必须包含头文件fstream
2. 读文件可以利用ofstream或者fstream类
3. 打开文件时需要指定操作文件的路径，以及打开方式
4. 利用<<可以向文件中写数据
5. 操作完毕后，要关闭文件

**如果是写入.csv格式的表单，表格内容用","隔开，换行用endl**

#### 读文件
读文件与写文件步骤相似，但是读取方式比较多
##### 读文件的步骤
1. 包含头文件
```
#include<fstream>
```
2. 创建流对象
```
ifstream 对象名;//对象名一般用ifs，ifstream即in file stream 输出到文件流
```
3. 打开文件并判断文件是否打开成功
```
ifs.open("文件路径",打开方式);
```
4. 读数据
四种方式读取
5. 关闭文件
```
ifs.close();
```
##### ifstream的接口函数
| 函数               | 描述                              |
|:----------------- |:---------------------------------|
| ifs::is_open      | 判断文件是否打开成功，返回布尔值       |
| ifs::eof          | 读到文件尾部，即判断文件是否读取完，返回布尔值 |
| ifs::putback      | 把读取的单个字符放回去，即把已经读取过的单个字符再返回去标为未读，可以再重新读取这个字符 |


##### 读数据的API
###### ifs>>
ifstream重载了>>运算符，可以使用这一种方式逐字符读取
##### getline
```
getline(ifs,buffer)
```
可以逐行读取字符
*在C++14中，可能不识别，需要添加头文件 ```#include<sstream>```*


##### 读数据的4种方式
###### 读文件方法1
```
	char buf[1024] = { 0 };
	while (ifs >> buf)
	{
		cout << buf << endl;
	}
```
###### 读文件方法2
```
	char buf[1024] = { 0 };
	while (ifs.getline(buf,sizeof(buf)))
	{
		cout << buf << endl;
	}
```
###### 读文件方法3
```
	string buf;
	while (getline(ifs, buf))
	{
		cout << buf << endl;
	}
```
###### 读文件方法4--逐字符读取
```
	char buf;
	while ((buf = ifs.get()) != EOF)//EOF是文件的结尾  end of file
	{
		cout << buf;
	}
```
#### 总结
1. 读文件可以利用ifstream，或者fstream类
2. 利用is_open函数可以判断文件是否打开成功
3. close关闭文件
#### 注意EOF判断
1. 读取每一行文件数据，最后一行一定是EOF行，文件流读取到最后一行以后，才能判断是否文档读取完成
2. peek()返回即将读取的文件流的信息，可以使用
```
while(infile.peek()==infile.eof())
```
3. 如果没有对文件做EOF的判断，默认文件流会多读取一次


### 二进制文件
以二进制的方式对文件进行读写操作
打开方式要指定为 ```ios::binary```
#### 写文件
二进制方式写文件主要利用流对象调用成员函数write
##### 函数原型
```
ostream& write(const char *buffer,int len);
```
##### 参数解释
字符指针buffer指向内存中一段存储空间，len是读写的字节数

文件输出流对象可以通过write函数，以二进制方式写数据

#### 读文件
二进制方式读文件主要利用流对象调用成员函数read
##### 函数原型
```
istream& read(char *buffer,int len);
```
##### 参数解释
字符指针buffer指向内存中一段存储空间，len是读写的字节数


### C++ IO类库
- **ios_base**  
  基类，提供 IO 流的基本信息  
  - **ios**  
    是 IO 流的基类，继承自 `ios_base` 类  
    - **istream**  
      通用输入，继承自 `ios` 类，如 `cin` 对象就是从 `istream` 类实例化的  
      - **istringstream**  
        字符串输入，继承自 `istream` 类  
      - **ifstream**  
        输入文件流，用于从文件中读取数据，继承自 `istream` 类  
    - **ostream**  
      通用输出，继承自 `ios` 类，如 `cout` 对象就是从 `ostream` 类实例化的  
      - **ostringstream**  
        字符串输出，继承自 `ostream` 类  
      - **ofstream**  
        输出文件流，用于创建文件并向文件写入数据，继承自 `ostream` 类  
    - **iostream**  
      输入/输出文件流，同时具备 `istream` 和 `ostream` 两个类的功能，可读可写。菱形继承自 `istream` 类和 `ostream` 类  
      - **fstream**  
        文件输入输出，继承自 `iostream` 类  
      - **stringstream**  
        字符串输入输出，继承自 `iostream` 类


### 文件流指针
可以通过函数来读取或设置文件流中流指针的指向
#### 获取流指针
- tellg()-----ifstream
- tellp()-----ofstream
#### 修改流指针
- seekg()-----ifstream
- seekp()-----fstream
#### 位移模式
- ios::beg-----从流开始位置计算位移
- ios::cur-----从流当前指针位置开始计算位移
- ios::end-----从流末尾处开始计算的位移

### 操作文件夹
操作文件夹属于windows系统开发方向，有深度和难度，要掌握基础的一些API
#### 头文件
需要引入的头文件是 ```io.h```
```
#include<io.h>
```
#### API
##### _finddata_t
是一个结构体，用来存储文件各种信息
##### _findfirst
查询第一个文件
##### _findnext
查询下一个文件
##### _findcloses

**注意文件路径要用双斜杠，所有同类型文件用*表示**
例如
```
D:\\Program Files\\My Project\\*.txt
```

# C++提高编程
泛式编程和STL技术
C语言不支持泛型编程，C++支持泛型编程
## 模板
### 模板的概念
模板就是建立通用的模具，大大提高复用性

模板的特点：
1. 模板不可以直接使用，他只是一个框架
2. 模板的通用并不是万能的

#### 非类型模板
- 模板参数分为类型形参与非类型形参
- 非类型模板参数，就是用一个常量作为类模板或者函数模板的一个参数
- 非类型参数必须是整型常量，可以定义缺省参数

#### 多模板
在模板中使用其他类模板

#### 模板工作原理
- 模板定义并不是真正定义了一个函数或者类
- 而是编译器根据开发者所写的模板和形参来实现出一个对应版本的定义------模板实例化
- 编译器生成的版本通常被叫做模板的实例，这个过程类似于宏替换
- 在模板调用之前是不会生成代码的，由于编译器不会直接编译模板本身（模板的定义基本都在头文件中）
#### 非类型模板参数
当一个模板被实例化时，非类型参数被用户提供或者编译器自主推断的值所替代，其值在编译时进行确定，本质是常量表达式


### 函数模板
- C++另一种编程思想称为泛式编程，主要利用的技术就是模板
- C++提供两种模板机制：函数模板和类模板

#### 函数模板语法
##### 函数模板作用
建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表

##### 语法
```
template<typename T>
```
函数声明或定义

##### 解释
| 关键词    | 说明                                                |
|:--------|:---------------------------------------------------|
| `template` | 声明创建模板                                          |
| `typename` | 表明其后面的符号是一种数据类型，可以用 `class` 代替      |
| `T`      | 通用的数据类型，名称可以替换，通常为大写字母                  |


##### 使用函数模板的两种方法
1. 自动类型推导
编译器根据传入的实参类型，自动推导函数模板中的数据类型
2. 显示指定类型
在调用函数时使用下面的语法：
```
函数名<使用的数据类型>();
```

##### 总结
- 函数模板利用关键字template，函数模板也可以用关键字class
- 使用函数模板有两种方式:自动类型推导、显示指定类型
- 模板的目的是为了提高复用性，将类型参数化


#### 函数模板注意事项
- 自动类型推导，必须推导出一致的数据类型T，才可以使用
- 模板必须要确定出T的数据类型，才可以使用


#### 普通函数与函数模板的区别
##### 区别
1. 普通函数调用时可以发生自动类型转换（隐式类型转换）
2. 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
3. 如果利用显示指定类型的方式，可以发生隐式类型转换

##### 总结
建议使用显示指定类型的方式调用函数模板，因为可以自己确定通用类型T


#### 普通函数与函数模板的调用规则
##### 调用规则
1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配，优先调用函数模板

##### 总结
如果提供了函数模板，最好就不要提供普通函数，否则容易出现二义性

#### 模板的局限性
模板不是万能的，有些特定数据类型，需要用具体化方式做特殊实现

##### 具体化模板语法
```
template<> 函数返回类型 函数名（具体化的传入参数类型 传入参数）
```
##### 总结
1. 利用具体化模板，可以解决自定义类型的通用化
2. 学习模板并不是为了写模板 ，而是在STL能够运用系统提供的模板


### 类模板
#### 类模板语法
##### 类模板作用
建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表

##### 语法
```
template<typename T>
类
```

| 关键词    | 说明                                                |
|:--------|:---------------------------------------------------|
| `template` | 声明创建模板                                          |
| `typename` | 表明其后面的符号是一种数据类型，可以用 `class` 代替      |
| `T`      | 通用的数据类型，名称可以替换，通常为大写字母                  |


##### 调用语法
```
类名<T> 对象名;
```

#### 类模板与函数模板的区别
区别主要有两点：
1. 类模板没有自动类型推导的使用方式，只能用显示指定类型
2. 类模板在模板参数列表中可以有默认参数


#### 类模板中成员函数创建时机
类模板中成员函数和普通类中成员函数创建时机是有区别的：
- 普通类中的成员函数一开始就可以创建
- 类模板中的成员函数在调用时才创建

因为类模板中的成员函数不确定是什么数据类型，无法在一开始就创建。在调用时确定了数据类型后，才能创建


#### 类模板对象做函数参数
类模板实例化出的对象，向函数传参的方式

共有3种传入方式

| 方法            | 说明                               |
|:---------------|:----------------------------------|
| 指定传入的类型   | 直接显示对象的数据类型                      |
| 参数模板化       | 将对象中的参数变为模板进行传递               |
| 整个类模板化     | 将这个对象类型模板化进行传递                  |


一般使用第1种方法


获取参数类型名方法：
```
typeid(参数).name()
```

#### 类模板与继承
当类模板碰到继承时，需要注意以下几点：
1. 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
2. 如果不指定，编译器无法给子类分配内存
3. 如果想灵活指定出父类中T的类型，子类也需变为类模板


#### 类模板成员函数类外实现
类模板中成员函数类外实现时，需要加上模板参数列表
##### 语法
```
template<class T>
函数返回类型 类名<T>::函数名(){}
```

#### 类模板分文件编写
类模板中成员函数创建时机是在调用阶段，会导致分文件编写时，链接不到

##### 解决方法
- 方法1 直接包含.CPP源文件
- 方法2 将声明和实现写到同一个头文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制

主流的解决方法是方法2


#### 类模板与友元
##### 全局函数类内实现
直接在类内声明友元即可
##### 全局函数类外实现
需要提前让编译器知道全局函数的存在

全局函数类外实现，要在类内的友元函数声明中加空的模板参数列表

##### 总结
如果没有特殊需求，一般全局函数做类内实现，用法简单，而且编译器可以直接识别


## C++标准库
- 标准函数库是继承C，它是通用的、独立的，不属于任何类的函数来组成面向对象类库是类及其相关函数的集合
- C++对C做了包含，所有C语言的标准库都可以再C++中使用，同时为了支持类型安全，做了一定的添加和修改
### 标准函数库
- 输入/输出 I/O
- 字符串和字符处理
- 数学函数
- 时间，日期和本地化
- 动态分配
- 宽字符函数
- 其他函数
### 面向对象类库
- 标准的C++ i/o类
- String类
- 数值类
- STL容器类
- STL算法
- STL函数对象
- STL迭代器
- STL分配器
- 本地化库
- 异常处理
- 杂项



## STL
### STL基本概念
STL（Standard Template Library--标准模板库）
STL从广义上分为
- 容器（container）
- 算法（algorithm）
- 迭代器（iterator）

容器和算法之间通过迭代器进行无缝连接

STL几乎所有的代码都采用了模板类或者模板函数，相比于传统的由函数和类实现，增加了代码的复用性

### STL六大组件
容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器
#### 容器
各种数据结构，如vector、list、的确、set、map等，用来存放数据
#### 算法
各种常用的算法，如sort、find、copy、for_each等
#### 迭代器
扮演了容器与算法之间的胶合剂
#### 适配器
一种用来修饰容器或者仿函数或者迭代器接口的东西
#### 空间配置器
负责空间的配置与管理

### STL中容器、算法、迭代器
#### 容器：置物之所
- STL容器就是将运用最广泛的一些数据结构实现出来
- 常用的数据结构有：数组、链表、树、栈、队列、集合、映射表等
- 这些容器分为序列式容器和关联式容器两种
- 序列式容器
强调值的排序，序列式容器中的每个元素均有固定的位置
- 关联式容器
二叉树结构，各元素之间没有严格的物理上的顺序关系

#### 算法：问题的解法
- 有限的步骤，解决逻辑或数学上的问题，这一门学科叫算法（Algorithms）
- 算法分为质变算法和非质变算法
- 质变算法：指运算过程中会更改区间内的元素内容。例如拷贝、替换、删除等
- 非质变算法：指运算过程中不会更改区间内的元素内容。例如查找、计数、遍历、寻找极值等等
##### 算法头文件
- ```<algorithm>``` 是STL头文件中最大的一个 由一大推模板函数组成 每个函数独立
  - 涉及到的功能：比较 查找 遍历 复制 移除 修改 反转 排序 合并 交换等等
- ```<numeric>``` 一些简单数学运算的模板函数
- ```<functional>``` 一些模板类 用于申明函数对象


#### 迭代器：容器和算法之间的粘合剂
- 提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式
- 迭代器在STL里将算法和容器联系起来 类似一种黏合剂
- 每个容器都有自己专属的迭代器
- 算法通过迭代器访问容器中的元素
- 迭代器使用非常类似于指针

##### 迭代器定义
Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素

###### 迭代器和指针的区别
迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、*、++、—等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++等操作

迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身

##### 迭代器产生原因
Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果


##### 迭代器种类
| 种类               | 功能                                         | 支持运算                                      |
|:------------------|:--------------------------------------------|:--------------------------------------------|
| 输入迭代器          | 对数据的只读访问                               | 只读，支持 `++`、`==`、`!=`                  |
| 输出迭代器          | 对数据的只写访问                               | 只写，支持 `++`                              |
| 前向迭代器          | 读写操作，并能向前推进迭代器                    | 读写，支持 `++`、`==`、`!=`                  |
| 双向迭代器          | 读写操作，并能向前和向后操作                    | 读写，支持 `++`、`--`                        |
| 随机访问迭代器      | 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 | 读写，支持 `++`、`--`、`[n]`、`-n`、`<`、`<=`、`>`、`>=` |


常用的容器中，迭代器种类为双向迭代器和随机访问迭代器
##### 迭代器头文件
- ```<utility>``` STL里的几个模板声明
- ```<iterator>``` 提供了迭代器的核心函数
- ```<memory>``` 为容器的元素分配存储空间 并且对临时对象的处理机制


### 容器算法迭代器初识
#### vector存放内置数据类型
- 容器：```vector```
- 算法：```for_each```
- 迭代器：```vector<int>::iterator```

#### vector容器嵌套容器
```
vector<vector<int>>v;
```
注意嵌套容器增加元素要从小容器开始增加，再增加大容器



## STL常用容器
### string容器
#### string基本概念
##### 本质
string是C++风格的字符串，而string本质上是一个类

##### string和char*区别
- char*是一个指针
- string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器

##### 特点
- string类内部封装了很多成员方法
例如：查找find，拷贝copy，删除delete，替换replace，插入insert
- string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责

#### string构造函数
##### 构造函数原型
```
string(); 
```
创建一个空的字符串，例如 ```string str;```
```
string(const char* s);
```
使用字符串s初始化
```
string(const string & str);
```
拷贝构造，使用一个string对象初始化另一个string对象
```
string(int n,char c);
```
使用n个字符c初始化

string的多种构造方式没有优劣之分，灵活使用即可

#### string赋值操作
##### 赋值的函数原型
```
string& operator=(const char*s);
```
char*类型字符串赋值给当前的字符串
```
string& operator=(const string&s);
```
把字符串s赋值给当前的字符串
```
string& operator=(char c); 
```
字符赋值给当前的字符串
```
string& assign(const char *s); 
```
把字符串s赋给当前的字符串
```
string& assign(const char *s,int n);
```
把字符串s的前n个字符赋给当前的字符串
```
string& assign(const string&s); 
```
把字符串s赋给当前字符串
```
string& assign(int n,char c);
```
用n个字符c赋给当前字符串

string的赋值方式很多， ```operator=``` 这种方式是比较实用的


#### string字符串拼接（追加）
实现在字符串末尾拼接字符串
##### 函数原型
```
string& operator+=(const char* str);
```
重载+=操作符
```
string& operator+=(const char c);
```
重载+=操作符
```
string& operator+=(const string& str);
```
重载+=操作符
```
string& append(const char *s);
```
把字符串s连接到当前字符串结尾
```
string& append(const char *s,int n); 
```
把字符串s的前n个字符连接到当前字符串结尾
```
string& append(const string &s);
```
同operator+=(const string & str)
```
string& append(const string &s,int pos,int n);
```
字符串s中从pos开始的n个字符连接到字符串结尾


#### string查找和替换
查找：查找指定的字符串是否存在
替换：在指定的位置替换字符串
```.find```  ```.rfind```

find从左往右查找，rfind从右往左查找

##### 语法
```
string类型变量名.find(字符或字符串,pos)
```
返回一个int值是查找到的位置索引，从0开始，如果查找的字符串不存在，返回-1

##### 函数原型
```
int find(const string& str,int pos=0)const;
```
查找str第一次出现位置，从pos开始查找，返回一个int值是str所在位置
```
int find(const char* s,int pos=0)const;
```
查找s第一次出现位置，从pos开始查找
```
int find(const char* s,int pos,int n)const; 
```
从pos位置查找s的前n个字符第一次位置
```
int find(const char c,int pos=0)const;
```
查找字符c第一次出现位置
```
int rfind(const string& str,int pos=npos)const;
```
查找str最后一次位置，从pos开始查找
```
int rfind(const char* s,int pos=npos)const; 
```
查找s最后一次出现位置，从pos开始查找
```
int rfind(const char* s,int pos,int n)const;
```
从pos查找s的前n个字符最后一次位置
```
int rfind(const char c,int pos=0)const; 
```
查找字符c最后一次出现位置
```
string& replace(int pos,int n,const string& str);
```
替换从pos开始n个字符为字符串str
```
string& replace(int pos,int n,const char* s);
```
替换从pos开始的n个字符为字符串s

##### 总结
1. find查找是从左往右，rfind是从右往左
2. find找到字符串后返回查找的第一个字符位置，找不到就返回-1
3. replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串


#### string字符串比较
字符串之间的比较
##### 比较方式：
字符串比较实按字符的ASCII码进行对比
```
= 返回0
> 返回1
< 返回-1
```
##### 函数原型
```
int compare(const string &s)const;  //与字符串s比较
int compare(const char *s)const;    //与字符串s比较
```
字符串比大小意义不大，主要是用来判断两个字符串是否相等


#### string字符存取
string中单个字符存取方式有两种

##### 函数原型
```
char& operator[](int n);   //通过[]方式取字符
char& at(int n);           //通过at方法获取字符
```
string字符串中单个字符存取有两种方法，利用[]或at

#### string字符查找元素
##### 返回字符
```
string& front()  //返回第一个字符
string& back()   //返回最后一个字符
```

#### string插入和删除
对string字符串进行插入和删除字符操作

##### 函数原型
```
string& insert(int pos,const char* s);      //插入字符串
string& insert(int pos,const string& str);  //插入字符串
string& insert(int pos,int n,char c);       //在指定位置插入n个字符c
string& erase(int pos,int n=npos);          //删除从pos开始的n个字符
```
插入和删除的起始下标都是从0开始


#### string子串
从字符串中获取想要的子串

##### 函数原型
```
string substr(int pos=0,int n=npos)const;  //返回由pos开始的n个字符组成的字符串
```
灵活运用求子串功能，可以在实际开发中获取有效的信息

### vector容器
#### vector基本概念
##### 功能
vector数据结构和数组非常相似，也称为单端数组

##### vector与普通数组区别
不同之处在于数组是静态空间，而vector可以动态扩展

##### 动态扩展
并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间

##### vector内部结构
- 前端是封闭的
- 尾端是开放的提供尾插 ```push_back()``` 和尾删 ```pop_back()```

##### 提供的接口
- front()是第一个元素，back()是最后一个元素
- insert()是插入元素

##### 提供的迭代器
```
v.rend()               //指向第一个元素前一个位置
v.begin()              //指向第一个元素
v.rbegin()            //指向最后一个元素
v.end()               //指向最后一个元素下一个位置
```
vector容器的迭代器是支持随机访问的迭代器


#### vector构造函数
##### 功能
创建vector容器

##### 函数原型
```
vector<T> v;                 //采用模板实现类实现，默认构造函数
vector(v.begin(),v.end());   //将v[begin(),end())区间中的元素拷贝给本身,注意是前闭后开，begin()值可以取到，end()值取不到
vector(n.elem);              //构造函数将n个elem拷贝给本身
vector(const vector &vec);   //拷贝构造函数
```
vector多种构造方式没有优劣，灵活使用即可


#### vector赋值操作
给vector容器进行赋值

##### 函数原型
```
vector& operator=(const vector &vec); //重载等号操作符
assign(beg,end);                      //将[beg,end)区间中的数据拷贝赋值给本身
assign(n,elem);                       //将n个elem拷贝赋值给本身
```
#### vector容量和大小
对vector容器的容量和大小操作

##### 函数原型
```
empty();               //判断容器是否为空
capacity();            //容器的容量
size();                //返回容器中元素的个数
resize(int num);       //重新指定容器的长度为num，如果容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除
resize(int num,elem);  //重新指定容器的长度为num，如果容器变长，则以elem值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除
```
#### vector插入和删除
对vector进行插入、删除操作

##### 函数原型
```
push_back(ele);                                  //尾部插入元素ele
pop_back();                                     //删除最后一个元素
insert(const_iterator pos,ele);                 //迭代器指向位置pos插入元素ele
insert(const_iterator pos,int count,ele);       //迭代器指向位置pos插入count个元素ele
erase(const_iterator pos);                      //删除迭代器指向的元素
erase(const_iterator start,const_iterator end); //删除迭代器从start到end之间的元素
clear();                                        //删除容器中所有元素
```
##### 接口
| 操作   | 接口           | 说明                    |
|:------|:------------------|:-----------------------|
| 尾插   | `push_back`        | 在容器尾部插入元素         |
| 尾删   | `pop_back`         | 删除容器尾部的元素         |
| 插入   | `insert`           | 在指定位置插入元素          |
| 删除   | `erase`            | 删除指定位置的元素          |
| 清空   | `clear`            | 删除所有元素，清空容器      |


#### vector数据存取
对vector中的数据的存取操作

##### 函数原型
```
at(int idx);   //返回索引idx所指的数据
operator[];    //返回索引idx所指的数据
front();       //返回容器中第一个数据元素
back();        //返回容器中最后一个数据元素
```
##### 总结
1. 除了用迭代器获取vector容器中元素，[]和at也可以
2. front返回容器第一个元素
3. back返回容器最后一个元素


#### vector互换容器
实现两个容器内元素进行互换

##### 函数原型
```
swap(vec);  //将vec与本身的元素互换
```
##### 实际用途
巧用swap可以收缩内存空间
```
vector<int>(v).swap(v);
```
本质是创建一个匿名对象来和v互换容器，匿名对象在语句执行完后就会被释放


#### vector预留空间
减少vector在动态扩展容量时的扩展次数

##### 函数原型
```
reserve(int len);
```
容器预留len个元素长度，预留位置不初始化，元素不可访问

##### 实际用途
如果数据量较大，可以一开始的时候利用reserve预留空间，减少开辟空间次数

### list容器
#### list基本概念
##### 功能
将数据进行链式存储

- 链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的
- 数据结构中的双向链表,内存不连续，通过指针来访问数据，没有重载[ ]
- 可以迅速的完成对链表的删除和插入 但是随即存取效率较低

##### 链表的组成
链表由一系列结点组成

##### 结点的组成
一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域

**STL中的链表是一个双向循环链表**

由于链表的存储方式不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器

#### list的优点
1. 采用动态存储分配，不会造成内存浪费和溢出
2. 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素

#### list的缺点
1. 容器遍历速度没有数组快
2. 占用空间（指针域）比数组大

list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的

#### 总结
STL中list和vector是两个最常被使用的容器，各有优缺点

#### list构造函数
#### 函数原型
```
list<T>lst;
```
list采用模板类实现，对象的默认构造形式  
```
list(beg,end);
```
构造函数将[beg,end)区间中的元素拷贝给本身
```
list(n,elem);
```
构造函数将n个elem拷贝给本身
```
list(const list &lst);
```
拷贝构造函数
```
list构造方式与其他几个容器相同
```
#### list赋值和交换
#### 函数原型
```
assign(beg,end);
```
将[beg,end)区间中的数据拷贝赋值给本身
```
assign(n,elem);
```
将n个elem拷贝赋值给本身
```
list& operator=(const list &lst);
```
重载等号操作符
```
swap(lst); 
```
将lst与本身元素互换

#### list大小操作
对list容器的大小进行操作

#### 函数原型
```
size();
```
返回容器中元素的个数

```
empty();
```
判断容器是否为空

```
resize(num);
```
重新指定容器的长度为num，如果容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除

```
resize(num,elem);
```
重新指定容器的长度为num，如果容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除
|功能|关键字|
|----|----|
|判断是否为空|empty|
|返回元素个数|size|
|重新指定个数|resize|


#### list插入和删除
对list容器进行数据的插入和删除

##### 函数原型
```
push_back(elem);
```
在容器尾部加入一个元素

```
pop_back();
```
删除容器中最后一个元素

```
push_front(elem);
```
在容器开头插入一个元素

```
pop_front();
```
从容器开头移除第一个元素

```
insert(pos,elem);
```
在pos位置插入elem元素的拷贝，返回新数据的位置

```
insert(pos,n,elem);
```
在pos位置插入n个elem数据，无返回值

```
insert(pos,beg,end);
```
在pos位置插入[beg,end)区间的数据，无返回值

```
clear();
```
移除容器的所有数据

```
erase(beg,end);
```
删除[beg,end)区间的数据，返回下一个数据的位置

```
erase(pos);
```
删除pos位置的数据，返回下一个数据的位置

```
remove(elem);
```
删除容器中所有与elem值匹配的元素

##### 总结
|功能|关键字|
|----|----|
|尾插|push_back|
|尾删|pop_back|
|头插|push_front|
|头删|pop_front|
|插入|insert|
|删除|erase|
|移除|remove|
|清空|clear|


#### list数据存取
对list容器中数据进行存取
##### 函数原型
```
front();
```
返回第一个元素
```
back();
```
返回最后一个元素

**list容器不支持[]或at方式读取元素，迭代器也不支持随机访问跳跃式访问。原因是list本质上是链表，不是用连续线性空间存储数据的**

##### 使用iterator迭代器
```
list<int>::iterator it=lst.begin();
it++;支持递增
it--;支持递减
//it=it+1;不支持这种写法，因为不支持随机访问
```

##### 总结
list容器中不可以通过[]或者at方式访问数据
- 返回第一个元素: front
- 返回最后一个元素: back


#### list反转和排序

##### 函数原型
```
reverse();
```
反转链表
```
sort();
```
链表排序，把链表中所有元素从小到大排列

**注意：所有不支持随机访问迭代器的容器，不能使用标准算法**
**不支持随机访问迭代器的容器，内部会提供一些对应的算法**
sort()是成员函数，不是标准算法提供的全局函数

链表排序，把链表中所有元素从大到小排列
```
bool myCompare(int num1,int num2){return num1>num2;}

lst.sort(myCompare);
```
**注意**
1. 对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序
2. 高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂

### queue容器
也叫队列容器
queue是一种先进先出(First In First Out,FIFO)的线性存储表数据结构，有两个出口
#### 数据结构
- 两头开口，分为队头和队尾，队列方向从队尾到队头
- 元素的插入只能在队尾，元素的删除只能在队首
- 增加数据从队尾增加，入队接口push()
- 移除数据从队头移除，出队接口pop()

- 队列容器允许从一端新增元素，从另一端移除元素
- 队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为
- 队列中进数据称为--入队push
- 队列中出数据称为--出队pop

#### 常用接口
队列容器常用对外接口

##### 构造函数
```
queue<T> que;
```
queue采用模板类实现，queue对象的默认构造形式
```
queue(const queue &que);
```
拷贝构造函数

##### 赋值操作
```
queue& operator=(const queue &que);
```
重载等号操作符

##### 数据存取
```
push(elem);
```
往队尾添加元素
```
pop();
```
从队头移除第一个元素
```
back();
```
返回最后一个元素
```
front();
```
返回第一个元素

##### 大小操作
```
empty();
```
判断堆栈是否为空
```
size();
```
返回栈的大小

### priority_queue/优先队列（最大元素队列）
具备普通队列的特点，同时保证队列最大元素总是位于队首
当插入新元素 队列会按照从大到小的降序对数据元素进行排序

### deque容器
#### deque容器基本概念
##### 功能
双端队列，可以对头端进行插入删除操作

#### deque内部工作原理
- deque内部是分块的线性存储结构，每一块一般为512字节，称为一个deque块
- Map管理这些deque块，指向每一个队列块的首地址，```list<map<deque,deque地址>>```

- deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据
- 中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间

- deque容器的迭代器也是支持随机访问的

#### deque与vector的区别
1. vector对于头部的插入删除效率低，数据量越大，效率越低
2. deque相对而言，对头部的插入删除速度比vector快
3. vector访问元素时的速度比deque快，这和两者内部实现有关

#### vector与list与deque比较
##### vector
- 和数组类似，拥有连续的存储空间，支持随机存取和[]重载 
- 也是因为内存连续 所以在中间插入和删除数据会造成内存块的拷贝
- 如果插入元素个数过多，预留的内存空间导致不足，会重新申请新的内存，把原来的数据拷贝到新内存空间
##### list
- 数据结构中的双向链表，内存空间不连续，通过指针来进行数据访问，所以随机存取效率较低
- 如果进行插入和删除，那么list的速度是较快的
##### deque
- 支持随机存取[]，支持在双端的操作，在双端的操作上效率几乎一致
##### 使用情境
- 如果需要高效的随机存取，而不在乎删除和插入的数据，使用vector
- 如果有大量的删除和插入操作，而不需要随机存取，则使用list
- 如果需要随机存取，同时关心两端数据的插入和删除操作，则使用deque

#### 接口
| 接口                 | 描述               |
|----------------------|--------------------|
| `push_front()`        | 头部增加元素       |
| `push_back()`         | 尾部增加元素       |
| `insert()`            | 中间插入元素       |
| `pop_front()`         | 头部删除元素       |
| `pop_back()`          | 尾部删除元素       |


#### deque构造函数

##### 函数原型
```
deque<T> deqT;
```
默认构造形式

```
deque(beg,end);
```
构造函数将[beg,end)区间中的元素拷贝给本身

```
deque(n,elem);
```
构造函数将n个elem拷贝给本身

```
deque(const deque &deq);
```
拷贝构造函数

deque容器和vector容器构造方式几乎一致，灵活使用即可

#### deque赋值操作

##### 函数原型
```
deque& operator=(const deque &deq);
```
重载等号操作符

```
assign(beg,end);
```
将[beg,end)区间中的数据拷贝赋值给本身

```
assign(n,elem);
```
将n个elem拷贝赋值给本身

deque容器赋值操作与vector相同

#### deque大小操作

##### 函数原型
```
deque.empty();
```
判断容器是否为空

```
deque.size();
```
返回容器中元素的个数

```
deque.resize(num);
```
重新指定容器的长度为num，如果容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除

```
deque.resize(num,elem);
```
重新指定容器的长度为num，如果容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除

deque没有容量限制，可以无限开辟缓冲区，所以没有capacity（容量）相关函数

##### 总结
1. deque没有容量的概念
2. 判断是否为空--empty
3. 返回元素个数--size
4. 重新指定个数--resize

#### deque容器插入和删除数据

##### 函数原型
###### 两端插入操作
```
push_back(elem);
```
在容器尾部添加一个数据

```
push_front(elem);
```
在容器头部插入一个数据

```
pop_back();
```
删除容器最后一个数据

```
pop_front();
```
删除容器第一个数据

###### 指定位置操作
```
insert(pos,elem);
```
在pos位置插入一个elem元素的拷贝，返回新数据的位置

```
insert(pos,n,elem);
```
在pos位置插入n个elem数据，无返回值

```
insert(pos,beg,end);
```
在pos位置插入[beg,end)区间的数据，无返回值

```
clear();
```
清空容器的所有数据

```
erase(beg,end);
```
删除[beg,end)区间的数据，返回下一个数据的位置

```
erase(pos);
```
删除pos位置的数据，返回下一个数据的位置

##### 总结
插入和删除提供的位置是迭代器
| 操作       | 描述       |
|------------|------------|
| `push_back`| 尾插       |
| `pop_back` | 尾删       |
| `push_front`| 头插      |
| `pop_front`| 头删       |



#### deque容器数据存取

##### 函数原型
```
at(int idx);
```
返回索引idx所指的数据

```
operator[];
```
返回索引idx所指的数据

```
front();
```
返回容器中第一个数据

```
back();
```
返回容器中最后一个数据

##### 总结
1. 除了用迭代器获取deque容器中元素，[]和at也可以
2. front返回容器第一个元素
3. back返回容器最后一个元素


#### deque容器排序
##### 算法
```
sort(iterator beg,iterator end) //对beg和end区间内元素从小到大进行排序
```
需要添加标准算法头文件
```
#include<algorithm>
```
对于支持随机访问的迭代器的容器，都可以利用sort算法直接对其进行排序


### stack容器
#### stack基本概念
- stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口

- 底部叫栈底，顶部叫栈顶，只能从栈顶加入元素push()，只能从栈顶移除元素pop()

- 插入和删除元素都只在表的一端进行--栈顶（Stack Top)，另一端为栈底(Stack Bottom)
- 栈中只有栈顶的元素才可以被外界使用，因此栈不允许有遍历行为
- 栈中进入数据----入栈push
- 栈中弹出数据----出栈pop

#### stack常用接口
常用的对外接口

##### 构造函数
```
stack<T> stk;
```
stack采用模板类实现，stack对象的默认构造形式

```
stack(const stack &stk);
```
拷贝构造函数

##### 赋值操作
```
stack& operator=(const stack &stk);
```
重载等号操作符

##### 数据存取
```
push(elem);
```
向栈顶添加元素

```
pop();
```
从栈顶移除第一个元素

```
top();
```
返回栈顶元素

##### 大小操作
```
empty();
```
判断堆栈是否为空

```
size();
```
返回栈的大小

#### 总结
| 操作          | 描述             |
|---------------|------------------|
| `push`        | 入栈             |
| `pop`         | 出栈             |
| `top`         | 返回栈顶         |
| `empty`       | 判断栈是否为空   |
| `size`        | 返回栈大小       |


### set/multiset容器（集合）
#### set基本概念
所有元素都会在插入时自动被排序

#### 实现原理
- set/multiset属于关联式容器，底层是基于红黑树的平衡二叉搜索树的数据结构来实现
- 插入时，会自动调节二叉树的排列，把元素存储在最合适的位置，确保每个子树根节点的
- 值大于左子树，小于右子树，重复数据会忽略
- set的排序是二叉树的中序遍历，即左-根-右升序效果


#### set和multiset的区别
- set不允许容器中有重复的元素
- multiset允许容器中有重复的元素

#### set构造和赋值
创建set容器以及赋值
##### 构造
```
set<T>st;
```
默认构造函数
```
set(const set &st);
```
拷贝构造函数
##### 赋值
```
set& operator=(const set &st);
```
重载等号操作符

#### set容器特点
1. 所有元素在插入的时候会自动被排序
2. 容器不允许插入重复元素

set容器没有push_back，插入数据时用insert

#### set大小和交换
统计set容器大小以及交换set容器

##### 函数原型
```
size();
```
返回容器中元素的数目
```
empty();
```
判断容器是否为空
```
swap(st);
```
交换两个集合容器

#### set插入和删除

##### 函数原型
```
insert(elem);   
```
在容器中插入元素

```
clear();        
```
清除所有元素

```
erase(pos);     
```
删除pos迭代器所指的元素，返回下一个元素的迭代器

```
erase(beg,end); 
```
删除区间[beg,end)的所有元素，返回下一个元素的迭代器

```
erase(elem);    
```
删除容器中值为elem的元素（multiSet会删除所有值为elem的重复元素）

#### set查找和统计
对set容器进行查找数据和统计数据

##### 函数原型
```
find(key);
```
查找key是否存在，如果存在，就返回该键的元素的迭代器，如果不存在，返回set.end()
```
count(key);
```
统计key的元素个数
对于set而言，count(key)的结果不是0就是1，因为元素不能重复

#### set和multiset的区别
1. set不可以插入重复数据，而multiset可以
2. set插入数据的同时会返回插入结果（结果是对组数据类型的），表示插入是否成功
3. multiset不会监测数据，因此可以插入重复数据
```
set<int>st1;
pair< set<int>::iterator,bool> ret= st1.insert(10);
cout << ret.second << endl;
```
#### pair对组创建
对组即键值对
成对出现的数据，利用对组可以返回两个数据

##### 两种创建方式
```
pair<type,type> p (value1,value2);
```
```
pair<type,type> p=make_pair(value1,value2);
```

| 操作         | 描述           |
|--------------|----------------|
| `p.first`    | 获取第一个数据 |
| `p.second`   | 获取第二个数据 |

#### set容器排序
set容器默认排序规则为从小到大，掌握如何改变排序规则
##### 主要技术点
利用仿函数，可以改变排序规则

**要注意，set容器的排序需要在插入元素之前进行，具体方法是利用仿函数重载小括号**

**对于自定义数据类型，set必须指定排序规则才可以插入数据**


### map/multimap容器
即映射容器
#### map基本概念
- map中所有元素都是pair
- pair中第一个元素为key(键值)，起到索引作用，第二个元素为value(实值)
- 所有元素都会根据元素的键值自动排序

#### 本质
map/multimap属于关联式容器，底层是基于红黑树的平衡二叉搜索树的数据结构来实现（Java中的hashmap是使用HashTable实现的）

#### 优点
可以根据key值快速找到value值

#### map和multimap的区别
- map不允许容器中有重复key值元素，value值元素可以重复
- multimap允许容器中有重复key值元素和value值元素

#### map构造和赋值
##### 函数原型
###### 构造
```
map<T1,T2>mp;
```
map默认构造函数
```
map(const map &mp);
```
拷贝构造函数

###### 赋值
```
map& operator=(const map &mp);
```
重载等号操作符

##### 总结
map中所有元素都是成对出现，插入数据时要使用对组

#### map大小和交换
##### 函数原型
```
size();   
```
返回容器中元素的数目

```
empty();  
```
判断容器是否为空

```
swap(mp); 
```
交换两个映射容器

#### map插入和删除
##### 函数原型
```
insert(elem);   
```
在容器中插入元素

```
clear();        
```
清除所有元素

```
erase(pos);     
```
删除pos迭代器所指的元素，返回下一个元素的迭代器

```
erase(beg,end); 
```
删除区间[beg,end)的所有元素，返回下一个元素的迭代器

```
erase(key);     
```
删除容器中值为key的元素


##### map容器插入元素的4种方法
以map<int,int>m为例
###### 方法1
```
m.insert(pair<int,int>(key值,value值));
```
###### 方法2
```
m.insert(make_pair(key值,value值);
```
###### 方法3
```
m.insert(map<int,int>::value_type(key值,value值);
```
###### 方法4
```
m.[key值]=value值;
```
*方法4一般不在插入数据时使用，因为在没有给定value值时，编译器会自动赋值0，容易出现问题，但是利用方法4可以通过key访问到value，非常方便*


#### map查找和统计
##### 函数原型
```
find(key);
```
查找key是否存在，如果存在，返回该键的元素的迭代器，如果不存在，返回set.end()
```
count(key);
```
统计key的元素个数

#### map容器排序
map容器默认排序规则为按照key值进行从小到大排序，掌握如何改变排序规则
##### 主要技术点
- 利用仿函数，可以改变排序规则
- 对于自定义数据类型，map必须指定排序规则，同set容器

**VS2019使用仿函数重载()改变排序规则需要在传参的括号后面加const，否则会报错**


## STL-函数对象
### 函数对象
#### 函数对象概念
##### 概念
- 重载函数调用操作符的类，其对象常称为函数对象
- 函数对象使用重载的()时，行为类似函数调用，也叫仿函数
##### 本质
函数对象（仿函数）是一个类，不是一个函数

#### 函数对象使用
##### 特点
- 函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值
- 函数对象超出普通函数的概念，函数对象可以有自己的状态
- 函数对象可以作为参数传递

*仿函数的写法非常灵活*


### 谓词
#### 谓词概念
- 返回bool类型的仿函数称为谓词
- 如果operator()接收一个参数，就叫做一元谓词
- 如果operator()接收两个参数，就叫做二元谓词

#### 一元谓词
如果operator()接收一个参数，就叫做一元谓词

##### 标准库函数
```
find_if(迭代器1,迭代器2,一元谓词)
```
根据一元谓词的布尔值查找，找到返回元素的迭代器，找不到返回end()


### 内建函数对象
#### 内建函数对象意义
##### 概念
STL内建了一些函数对象，可以直接使用

##### 分类
- 算数仿函数
- 关系仿函数
- 逻辑仿函数

##### 用法
- 这些仿函数所产生的对象、用法和一般函数完全相同
- 使用内建函数对象，需要引入头文件 ```#include<functional>```

#### 算数仿函数
##### 功能描述
实现四则运算
其中negate是一元运算，其他都是二元运算

##### 仿函数原型
```
template<class T> T plus<T>       //加法仿函数
template<class T> T minus<T>      //减法仿函数
template<class T> T multiplies<T> //乘法仿函数
template<class T> T divides<T>    //除法仿函数
template<class T> T modulus<T>    //取模仿函数
template<class T> T negate<T>     //取反仿函数
```

**使用内建函数对象时，需要引入头文件 ```#include<functional>```**


#### 关系仿函数
实现关系对比

##### 仿函数原型
```
template<class T> bool equal_to<T>      //等于
template<class T> bool not_equal_to<T>  //不等于
template<class T> bool greater<T>       //大于
template<class T> bool greater_equal<T> //大于等于
template<class T> bool less<T>          //小于
template<class T> bool less_equal<T>    //小于等于
```
标准库函数sort()默认是从小到大排列,本质就用的是less仿函数

让sort()实现从大到小排列，可以使用重载仿函数
```
sort(v.begin(),v.end(),greater<int>());
```
#### 逻辑仿函数
实现逻辑运算

##### 仿函数原型
```
template<class T> bool logical_and<T>  //逻辑与
template<class T> bool logical_or<T>   //逻辑或
template<class T> bool logical_not<T>  //逻辑非
```
逻辑仿函数实际应用较少


### STL常用算法
#### 概述
- 算法主要是由头文件 ```<algorithm>``` ```<functional>``` ```<numeric>```
  - ```<algorithm>``` 是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等
  - ```<numeric>``` 体积很小，只包括几个在序列上面进行简单数学运算的模板函数
  - ```<functional>``` 定义了一些模板类，用以声明函数对象

#### 常用遍历算法
##### for_each
```
for_each  //遍历容器
```
遍历时，如果是函数，只用传入函数名，如果是仿函数，需要传入函数对象
for_each在实际开发中是最常用的遍历算法，需要熟练掌握
###### 使用全局函数
```
void printFunc(int n)
{
	cout << n << endl;
}
int main()
{
	vector<int>v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	for_each(v1.begin(), v1.end(), printFunc);
}
```
###### 使用函数对象
- 不传入额外参数
```
class printF
{
public:
	void operator()(int n)
	{
		cout << n+this->b << endl;
	}

};

int main()
{
	vector<int>v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	for_each(v1.begin(), v1.end(), printF());
}
```
- 通过构造函数传入额外参数
```
class printF
{
public:
	printF(int b)
	{
		this->b = b;
	}
	void operator()(int n)
	{
		cout << n+this->b << endl;
	}
	int b;
};
int main()
{
	vector<int>v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	for_each(v1.begin(), v1.end(), printF(1000));
}
```


##### transform
```
transform
```
搬运容器到另一个容器中
###### 函数原型
```
transform(iterator beg1,iterator end1,iterator beg2,_func);
//beg1 源容器开始迭代器
//end1 源容器结束迭代器
//beg2 目标容器开始迭代器
//_func 函数或函数对象
```
**注意：目标容器必须提前开辟空间才可以搬运**


#### 常用查找算法
##### find
```
find  //查找元素
```
查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()

###### 函数原型
```
find(iterator beg,iterator end,value);
//beg----开始迭代器
//end----结束迭代器
//value--查找的元素
```
##### find_if
```
find_if  //按条件查找元素
```
设置查找条件，查找符合条件的元素，找到返回指定位置迭代器，找不到返回结束迭代器位置
###### 函数原型
```
find_if(iterator beg,iterator end,_pred);
//beg----开始迭代器
//end----结束迭代器
//_Pred--函数或谓词（返回bool类型的仿函数）
```
##### adjacent_find
```
adjacent_find  //查找相邻重复元素
```
###### 函数原型
```
adjacent_find(iterator beg,iterator end);
//查找相邻重复元素，返回相邻元素的第一个位置的迭代器，如果没有相邻元素，返回end()
//beg--开始迭代器
//end--结束迭代器
```
###### 总结
使用的不多，面试题如果出现查找相邻重复元素，记得用STL中的adjacent_find算法

##### binary_search
```
binary_search  //二分查找法
```
查找指定元素是否存在,二分查找法查找效率很高，但是需要注意的是查找的容器中元素必须是有序序列（递增或递减）
###### 函数原型
```
bool binary_search(iterator beg,iterator end,value);
//查找指定的元素，查到返回True，否则返回false
//注意：在无序序列中不可用（即元素不是按递增或递减排列的），因为查找结果可能会出现错误
//beg----开始迭代器
//end----结束迭代器
//value--查找的元素
```
如果是自定义数据类型，要使用重载函数对象
```
bool binary_search(iterator beg,iterator end,value,_pred);
```
##### count
count  //统计元素个数
###### 函数原型
```
count(iterator beg,iterator end,value);
//统计元素出现次数
//beg----开始迭代器
//end----结束迭代器
//value--统计的元素
```
**统计自定义数据类型时，需要配合重载 ```operator==```**

##### count_if
```
count_if  //按条件统计元素个数
```
###### 函数原型
```
count_if(iterator beg,iterator end,_pred);
//按条件统计元素出现次数
//beg----开始迭代器
//end----结束迭代器
//_Pred--谓词
```

#### 常用排序算法
##### sort
```
sort  //对容器内元素进行排序
```
###### 函数原型
```
sort(iterator beg,iterator end,_Pred);
//按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置
//beg----开始迭代器
//end----结束迭代器
//_Pred--谓词
```
非常常用的排序算法
**如果使用的是内置数据类型，可以使用内建函数的关系仿函数，如果是自定义数据类型，必须自己创建函数或函数对象**

##### random_shuffle
```
random_shuffle  //洗牌 指定范围内的元素随即调整次序
```
###### 函数原型
```
random_shuffle(iterator beg,iterator end);
//指定范围内的元素随机调整次序
//beg----开始迭代器
//end----结束迭代器
```
**随机排序是伪随机，需要用添加srand((unsigned int)time(0))做随机种子**

###### 总结
random_shuffle洗牌算法比较实用，使用时记得加随机数种子

##### merge
```
merge  //容器元素合并，并存储到另一容器中
```
###### 函数原型
```
merge(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);
//beg1----容器1开始迭代器
//end1----容器1结束迭代器
//beg2----容器2开始迭代器
//end2----容器2结束迭代器
//dest----目标容器开始迭代器
```
**注意：两个容器必须是有序的，合并之后的新容器也是有序的**

如果是自定义数据类型，要使用谓词
```
merge(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest,_Pred);
```
**注意：要提前给目标容器分配内存**
可以用目标容器 ```.resize(容器1.size(),容器2.size());```

##### reverse
```
reverse  //反转指定范围的元素
```
将容器内元素进行反转
###### 函数原型
```
reverse(iterator beg,iterator end);
//反转指定范围的元素
//beg----开始迭代器
//end----结束迭代器
```

#### 常用拷贝和替换算法
##### copy
```
copy  //容器内指定范围的元素拷贝到另一容器中
```
###### 函数原型
```
copy(iterator beg,iterator end,iterator dest);
//按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置
//beg----开始迭代器
//end----结束迭代器
//dest---目标起始迭代器
```

##### replace
```
replace  //将容器内指定范围的旧元素修改为新元素
```
###### 函数原型
```
replace(iterator beg,iterator end,oldvalue,newvalue);
//将区间内旧元素替换成新元素
//beg----开始迭代器
//end----结束迭代器
//oldvalue---旧元素
//newvalue---新元素
```
它会替换区间内所有的指定元素


##### replace_if
```
replace_if  //容器内指定范围满足条件的元素替换为新元素
```
###### 函数原型
```
replace_if(iterator beg,iterator end,_Pred,newvalue);
//按条件替换元素，满足条件的替换成指定元素
//beg----开始迭代器
//end----结束迭代器
//_Pred------谓词
//newvalue---替换的新元素
```

##### swap
```
swap  //互换两个容器的元素
```
###### 函数原型
```
swap(container c1,container c2);
//c1----容器1
//c2----容器2
```
**注意：两个容器需要数据类型相同**


#### 常用算数生成算法
算数生成算法属于小型算法，使用时包含的头文件为
```
#include<numberic>
```
##### accumulate
```
accumulate  //计算容器元素累计总和
```
计算区间内容器元素累计总和
###### 函数原型
```
accumulate(iterator beg,iterator end,value);
//beg----开始迭代器
//end----结束迭代器
//value--起始值
```
##### fill
```
fill  //向容器中添加元素
```
###### 函数原型
```
fill(iterator beg,iterator end,value);
//beg----开始迭代器
//end----结束迭代器
//value--填充的值
```
  
#### 常用集合算法
##### set_intersection
```
set_intersection  //求两个容器的交集
```
###### 函数原型
```
set_intersection(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);
//beg1----容器1开始迭代器
//end1----容器1结束迭代器
//beg2----容器2开始迭代器
//end2----容器2结束迭代器
//dest----目标容器开始迭代器
```
**注意：两个容器必须是有序序列**

目标容器开辟的空间是两个容器大小的最小值
```
目标容器.resize(min(容器1.siez(),容器2.size()));
```
set_intersection返回值即为交集中最后一个元素的位置

**注意：如果是自定义数据类型，需要在最后加谓词（作用是排序，因为容器必须是有序序列，自定义数据类型如何排序需要重载）**


##### set_union
```
set_union  //求两个容器的并集
```
###### 函数原型
```
set_union(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);
//beg1----容器1开始迭代器
//end1----容器1结束迭代器
//beg2----容器2开始迭代器
//end2----容器2结束迭代器
//dest----目标容器开始迭代器
```
**注意：两个集合必须是有序序列**

**注意：如果是自定义数据类型，需要在最后加谓词（作用是排序，因为容器必须是有序序列，自定义数据类型如何排序需要重载）**

###### 总结
- 求并集的两个集合必须是有序序列
- 目标容器开辟空间需要两个容器相加
- set_union返回值即为并集中最后一个元素的位置


##### set_difference
```
set_difference  //求两个容器的差集
```
v1和v2的差集是v1中存在且v2中不存在的元素
v2和v1的差集是v2中存在且v1中不存在的元素

###### 函数原型
```
set_difference(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);
//beg1----容器1开始迭代器
//end1----容器1结束迭代器
//beg2----容器2开始迭代器
//end2----容器2结束迭代器
//dest----目标容器开始迭代器
```
**注意：两个集合必须是有序序列**

**注意：如果是自定义数据类型，需要在最后加谓词（作用是排序，因为容器必须是有序序列，自定义数据类型如何排序需要重载）**


**目标容器开辟的空间是两个容器大小的最大值**
```
目标容器.resize(max(容器1.siez(),容器2.size()));
```
set_intersection返回值即为并集中最后一个元素的位置

###### 总结
- 求差集的两个容器必须是有序序列
- 目标容器开辟空间需要两个容器取最大值
- set_difference返回值是差集中最后一个元素的位置




## standard library/标准库
### iostream库
包含两个基础类型istream（输入流）和ostream（输出流），一个流就是一个字符序列，是从IO设备读出或写入IO设备的

**流（stream）表示：随着时间的推移，字符是顺序生成或消耗的**
#### 标准输入输出对象
##### istream
- cin/标准输入
##### ostream
- cout/标准输出
- cerr/标准错误
用来输出警告和错误消息
- clog
输出程序运行时的一般性信息



## 宏定义和预处理
### 概念
- 预处理器不是真正编译过程的组成部分，它是编译代码之前，一个单独的步骤
- 宏的本质：预处理器只不过是做了一个文本替换的工作而已
- 所有的预处理器命令都是以#开头
- 注意区分预处理语句和实际的代码语句的区别

### 常用预处理指令
| 指令              | 描述                                         |
|-------------------|----------------------------------------------|
| `#include`         | 包含一个源代码文件                           |
| `#define`, `#undef`| 定义/取消一个宏                              |
| `#ifdef`, `#ifndef`| 如果宏（已/未）被定义，返回真，开始一个条件编译块 |
| `#if`, `#else`, `#elif` | 定义一个条件编译块                     |
| `#endif`           | 结束一个条件编译块                           |
| `#error`           | 输出错误消息，编译会中断                     |
| `#pragma`          | 向编译器发布特殊命令，控制编译               |


### #include
将一个文件嵌入另一个文件中去
通常用于引入头文件，进而引用另一个C或C++模块
#### 优点
模块化设计、系统库、静态库
注意配合#ifndef或#pragma once来防止重复引入同一文件

### 两种用法
#### ```#define <宏名> <字符串>```
```
#define PI 3.1415926
```
#### ```#define <宏名> （<参数表>） <宏体>```
```
#define A(x) x
```
**为了防止替换时出现歧义 每个变量和计算都加上括号，例如 ```area(x) ((x)*(x))```**
### 条件编译块
#### 用法1：
防止重复引用
```
#ifndef_A_HEAD_NAME_H
#define_A_HEAD_NAME_H
//文件内容
#endif
```
#### 用法2：
用来配置代码，通过宏设置，实现不同的功能
```
#ifdef 条件1
//代码块1
#elsif 条件2
//代码块2
#else
//代码块3
#endif
```

### #define和#undef
定义一个宏，这个宏将在编译前被替换为它所定义的文本
```
#define MAX_SIZE 10
```
定义一个宏之后，将一直有效，直到#undef
```
#define MAX_SIZE 10
int a=MAX_SIZE;
#undef MAX_SIZE
#define MAX_SIZE 100
int b=MAX_SIZE;
```
#### #define的妙用
##### 参数化的宏
像函数一样的用法
```
#define square(x)((x)*(x))
int var=square(5);
```
**注意参数化的宏加括号和不加括号的区别**
宏是单纯的文本替换，而数学运算符是有优先级的
```
#define x m+n
x*x    = m+n*m+n
(x)*(x)=(m+n)*(m+n)
```
#### 多行宏
\表示在宏中换行
```
#define calc(a,b) \
    (((a)*(a)+(b)*(b))+  \
      2*(a)*(b))
```

### 宏的要点
- 通常命名为大写
- 通常作为静态配置参数，让编译好的程序有不同的行为
- 宏与条件编译配合，可以静态调整程序模块、逻辑流程等
- 参数宏是代码替换，可能引起二进制代码的体积增大
- 配合预定义宏，可以实现很灵活的功能
```
 _DATE_  _TIME_  _FILE_  _LINE_等
```
### 宏定义中的三个特殊符号
| 符号   | 描述         | 示例                      | 结果               |
|--------|--------------|---------------------------|--------------------|
| `#`    | 加双引号      | `#define STR(x) #x`        | `STR(abc)` → `"abc"`|
| `##`   | 连接符号      | `#define ADD(a, b) a##b`   | `ADD(12, 34)` → `1234`|
| `#@`   | 加单引号（GCC 和部分编译器扩展） | `#define CHR(x) #@x` | `CHR(a)` → `'a'`      |



### 宏替换
编译预处理实现功能
1. 文件包含
把源程序中所有的#include扩展为文件正文
2. 条件编译
预处理器根据#if和#ifdef 等编译命令及其后续的条件 将源程序中的某部分包含或者排除
3. 宏展开
预处理器将源程序中出现的对宏的引用展开成相应的宏定义 也就是字符串替换#define
经过预处理器处理的源程序与之前的程序有所不同 这个阶段的工作只做替换 而不包含计
算

### 宏的优点
1. 方便程序的修改
使用简单的宏定义代替一个程序中经常使用的常量
当常量发生改变，不需要对整个程序进行修改，只修改宏定义的字符串即可
2. 提升程序的运行效率
使用带参数的宏定义完成类似函数调用的功能，减少了系统的开销，提升运行效率，函数的使用可以使程序更加模块化，便于组织，而且可重复利用
### 宏与函数比较
1. 当发生函数调用时，需要保留函数现场，以便于函数执行结束后返回继续执行
2. 如果子函数执行的操作比较多，这种转换开销可以忽略不计，但是功能比较少，转换开销就
相对较大
3. 宏定义一般完成简单的操作，复杂操作还是有函数调用完成，宏定义所占用的目标代码空间
相对较大

# C++杂项知识点
## namespace/命名空间
在C++中通过引入命名空间的概念，来解决命名冲突的问题
简单来说C++中的命名空间就是定义了一个范围
**注意**
**因为C++支持多编译器，接近底层，项目结构设计难度要高于一般的编程语言。命名空间就显得十分重要，一定要熟练掌握。否则在调试程序或阅读源码时，C++会立刻让你体验一下什么是魔鬼**
### ```using namespace std```
将std以内的所有内容引入到目前的命名空间中
#### 好处
大多数情况下会少写很多东西，使代码更易读
#### 坏处
有可能导致命名空间被污染

使用时可以仅在main.cpp中使用，是一个好习惯

**注意：千万不要在头文件中使用using**

### 创建命名空间
单文件创建命名空间
```
namespace Number_Func{}
```
### Default Global Namespace
Default Global Namespace默认全局命名空间
在其他命名空间中可以使用 ```::``` 来表示默认全局命名空间
### using的用法
#### 可以引入命名空间
按需解决冲突
#### 可以只引入类
```
using 命名空间名::类名
```
#### 可以只引入函数
```
using 命名空间名::函数名
```
### 嵌套命名空间与别名
Nested Namespaces
C++中命名空间是支持命名空间嵌套的，但是不要嵌套太深
C++中命名空间是支持别名的
```
namespace Some=Some1::Some2
```

## C++异常处理
当程序运行过程中出现的特殊情况，如除法的除数为0、编号输入的是负数、动态分配内存时空间不足导致的无法分配等异常时，C++提供了异常处理程序
### 3个关键字
异常提供了一组转移程序控制权的方法 三个关键字
#### ```throw```
当问题出现时 使用throw关键字抛出一个异常
#### ```catch```
抛出的异常会被catch捕获到
#### ```try```
- try将代码块标识为可能出现特定异常的语句块 后面通常跟着1个或者多个catch语句
- try标识的语句，一般被称为保护代码，放置哪些可能抛出异常的语句，后续即便是出现异常，不会导致程序崩溃,而是把代码执行调整到catch语句中
##### 示例代码
```
#include<iostream>
using namespace std;
#include<vector>

double divide(double a, double b)
{
	if (b == 0)
	{
		throw -1;
	}
	return a / b;
}


int main()
{
	try    //基础用法
	{
		divide(6, 0);
	}
	catch (int m)
	{
		cout <<"Error:"<<m << endl;
	}
        cout<<"-----------------------"<<endl;
	vector<int>v1(5);    //使用异常处理类用法
	try
	{
		cout << v1.at(6) << endl;
	}
	catch (out_of_range& err)
	{
		cout << err.what() << endl;
	}
}
```

### 异常处理类
#### 异常基类
**```exception```**
所有异常类的基类
#### 派生类
- ```bad_alloc```
使用new或new[]分配内存指令失败时抛出异常
- ```bad_cast```
dynamic_cast动态类型转换中，转换失败时抛出异常
- ```bad_typeid```
使用typeid操作一个空指针，且该指针是带有虚函数的类，此时会抛出bad_typeid异常
- ```ios_base::failure```
io 过程中出现的异常
- ```bad_exception```
这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的unexpected()函数中抛出了异常，不论什么类型，都会被替换为bad_exception类型
- ```logic_error```
逻辑错误，继承自此类的所有异常操作类都是逻辑错误，可以通过读取代码来查找的异常
  - ```out_of_range```
一般是vector或string获取时越界的抛出
※※※※※注意用at获取，如果下标越界才可以抛出，用[]获取无法抛出
  - ```length_error```
试图生成一个超出该类型最大长度的对象时抛出该异常，例如vector的resize操作或创建了过长的string
  - ```invalid_argument```
参数不合适，无效参数时抛出。在标准库中，当利用string对象构造bitset时，而string中的字符不是0或1的时候，抛出该异常
  - ```domain_error```
参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数
- ```runtime_error```
运行时错误,不可以通过读取代码来查找的异常
  - ```overflow_error```
算术计算上溢，抛出该异常
  - ```range_error```
计算结果超出了有意义的值域范围时，抛出该异常
  - ```underflow_error```
算术计算下溢，抛出该异常

#### 自定义异常
可以自己定义一个类，继承自exception，并重载what()函数
**注意：需要引入exception头文件**
```
#include <exception>
```

示例代码
```
#include <exception>//引入exception头文件
#include <iostream> 
using namespace std;
class MyException :public exception
{
	virtual const char* what() const
	{
		return "Custom Exception";
	}
 }myex;
int main() 
{
	try
	{
		if (true)
			throw myex;
	}
	catch (exception& e)
	{
		cout << e.what() << endl;
	}
}
```






## 设计模式
### 单例模式
#### Singleton 特点
只提供唯一一个类的实例，具有全局变量的特点。保证这个实例，在任意时刻任意位置都可以快速被获取
```
class Singleton
{ 
 private:
      //全局唯一的实例
      static Singleton* instance;
      //限制开发者 不能在其他位置实例化Singleton对象
      Singleton() {}
 public:
      int data;
      //提供给外部的访问单例对象的接口
      static Singleton* GetInstance() 
      {
          if(instance==NULL)
          instance = new Singleton();
          return instance;
      }
 };
Singleton* Singleton::instance = NULL;
```
