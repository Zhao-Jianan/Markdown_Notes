# 基础语法
## 字面量
在代码中，被写下来的的固定的值，称之为字面量
### Python中常用的有6种值（数据）的类型
#### 数字(Number)
-  整数(int)
-  浮点数(float)
-  复数(complex)  
如4+3j，以j结尾表示复数
#### 布尔(bool)
True为真，False为假，本质上是一个数字，True为1，False为0
#### 字符串（string）
描述文本的一种数据类型，字符串由任意数量的字符组成

Python中，字符串需要用双引号（"）包围起来，被引号包围起来的，都是字符串
#### 列表（list）
有序的可变序列，Python中使用最频繁的数据类型，可有序记录一堆数据
#### 元组（tuple）
有序的不可变序列，可有序记录一堆不可变的Python数据集合
#### 集合（Set）
无序不重复集合，可无序记录一堆不重复的Python数据集合
#### 字典（Dictionary）
无序Key-Value集合，可无序记录一堆Key-Value型的Python数据集合

## 注释
在程序代码中对程序代码进行解释说明的文字
### 注释的作用
注释不是程序，不能被执行，只是对程序代码进行解释说明，让别人可以看懂程序代码的作用，能够大大增强程序的可读性
### 注释的分类
#### 单行注释
以 # 开头，# 右边 的所有文字当作说明，而不是真正要执行的程序，起辅助说明作用
-  在 # 号和注释内容之间，间隔一个空格
-  单行注释一般用于对一行或一小部分代码进行解释
#### 多行注释
以 一对三个双引号 引起来来解释说明一段代码的作用使用方法
```
"""注释内容"""
```
多行注释一般对：Python文件、类或方法进行解释


## 变量
### 变量的定义
-  在程序运行时，能储存计算结果或能表示值的抽象概念
-  简单的说，变量就是在程序运行时，记录数据用的
### 变量的定义格式
```
变量名称 = 变量的值
```
- 每一个变量都有自己的名称，称之为：变量名，也就是变量本身
- 赋值，表示将等号右侧的值，赋予左侧的变量
- 每一个变量都有自己存储的值（内容），称之为：变量值
### 变量的特征
变量存储的数据，是可以发生改变的
### 变量的目的
- 变量的是为了存储运行过程的数据
- 存储的目的是为了：重复使用

## 数据类型
数据是有类型的
### 可以通过type()语句来得到数据的类型
#### 语法
```
type(被查看类型的数据)
```
### type()语句的使用方式
- 方法1  
在 ```print``` 语句中，直接输出类型信息
- 方法2  
用变量存储 ```type()``` 的结果（返回值）

### 字符串类型的不同定义方式
字符串有3种不同的定义方式
- 双引号定义法
- 单引号定义法
- 三引号定义法  
 三引号定义法，表示在一堆三个双引号的范围内，均是字符串

**要注意的是，包含范围是：从三个引号开始，到下一个三个引号结束**

**在Python中，三引号既可以做注释，也是字符串**

## 数据类型转换
数据类型之间，在特定的场景下，是可以相互转换的，如字符串转数字、数字转字符串等
### 为什么要转换类型
数据类型转换，是经常使用的功能
如：
- 从文件中读取的数字，默认是字符串，需要转换成数字类型
- input()语句，默认结果是字符串，若需要数字也需要转换
- 将数字转换成字符串用以写出到外部系统
- 等等
### 常见的转换语句（函数）
```
int(x)
```
将x转换为一个整数
```
float(x)
```
将x转换为一个浮点数
```
str(x)
```
将对象 x 转换为字符串

同type()语句一样，这三个语句，都是带有结果的（返回值），可以用print直接输出或用变量存储结果值

### 类型转换注意事项
类型转换不是万能的
- 任何类型，都可以通过str()，转换成字符串
- 字符串内必须真的是数字，才可以将字符串转换为数字
- 浮点数转整数会丢失精度，也就是小数部分

## 标识符
### 什么是标识符
在Python程序中，我们可以给很多东西起名字，比如：
- 变量的名字
- 方法的名字
- 类的名字,等等

这些名字，统一称为标识符，用来做内容的标识
所以，标识符是用户在编程的时候所使用的一系列名字，用于给变量、类、方法等命名
### 标识符命名规则
Python中，标识符命名的规则主要有3类：
#### 内容限定
标识符命名中，只允许出现：
  - 英文
  - 中文
  - 数字
  - 下划线（_）

这四类元素
其余任何内容都不被允许

**注意：**
- **一般不使用中文**
- **数字不可以开头**

#### 大小写敏感
字母大小写不同的变量，是两个完全不同的变量
#### 不可使用关键字
- Python中有一系列单词，称之为关键字
- 关键字在Python中都有特定用途
- 不可以使用它们作为标识符

### 变量命名规范
#### 见名知意
- 明了  
尽量做到，看到名字，就知道是什么意思
- 简洁  
尽量在确保“明了”的前提下，减少名字的长度
#### 下划线命名法
- 多个单词组合变量名，要使用下划线做分隔，这叫做蛇形命名法（Snake Case）。在蛇形命名法中，单词之间用下划线 ```_``` 分隔，全部小写
- 在Python社区，蛇形命名法被广泛接受，因为它更符合 Python 的风格指南（PEP 8）
#### 英文字母全小写
命名变量中的英文字母，应全部小写

## 运算符
### 算术（数学）运算符
```
+
```
加
```
-
```
减
```
*
```
乘
```
/
 ```
除

**注意和Java/C++不同，由于Python没有固定类型，所以整数相除不会自动整除，例如：在Java中，7/2=3，而在Python中7/2=3.5**
```
//
 ```
取整除
取相除结果的整数部分，例如：7//2=3，7.0//2=3.0
```
%
```
求余
```
**
```
指数，例如a**b为a的b次方
### 赋值运算符
```
=
```
把 = 号右边的结果 赋给 左边的变量
### 复合赋值运算符
```
 +=
 ```
加法赋值运算符，c += a 等效于 c = c + a
```
-=
```
减法赋值运算符，c -= a 等效于 c = c - a
```
*=
```
乘法赋值运算符，c *= a 等效于 c = c * a
```
/=
```
除法赋值运算符，c /= a 等效于 c = c / a
```
%=
```
取模赋值运算符，c %= a 等效于 c = c % a
```
**=
```
幂赋值运算符，c **= a 等效于 c = c ** a
```
//=
```
取整除赋值运算符，c //= a 等效于 c = c // a

## 字符串扩展
### 字符串的三种定义方式
字符串在Python中有多种定义形式
- 单引号定义法
- 双引号定义法
- 三引号定义法
  - 三引号定义法，和多行注释的写法一样，同样支持换行操作
  - 使用变量接收它，它就是字符串
  - 不使用变量接收它，就可以作为多行注释使用

### 字符串的引号嵌套
- 单引号定义法，可以内含双引号
- 双引号定义法，可以内含单引号
- 可以使用转移字符（\）来将引号解除效用，变成普通字符串

### 字符串拼接
- 如果有两个字符串（文本）字面量，可以将其拼接成一个字符串，通过+号即可完成
- 一般，字面量和变量或变量和变量之间会使用拼接
- 无法和非字符串类型如数字类型完成拼接

### 字符串格式化
#### 占位的形式拼接字符串
##### 语法
```
str1="Python"
str2="Hello %s" % str1
print(str2)
# % 表示：要占位
# %s 表示：字符串占位符
```
- 多个变量占位，变量要用括号括起来，并按照占位的顺序填入
- 数字也能用%s占位，是将数字转换成了字符串

#### Python中，常用的数据类型占位符
##### %s
将内容转换成字符串，放入占位位置
##### %d
将内容转换成整数，放入占位位置
##### %f
将内容转换成浮点型，放入占位位置

#### 快速写法
通过%符号占位已经很方便了，还能进行精度控制。可是追求效率和优雅的Python，有更加优雅的方式解决问题
##### 语法
```
f"内容{变量}"
```
##### 案例
```
name = "James"
age = 30
print(f"My name is {name}, I am {age} years old")
```
**这种写法不做精度控制，也不理会类型，适用于快速格式化字符串**

### 格式化的精度控制
#### 字符串格式化----数字精度控制
可以使用辅助符号 ```m.n``` 来控制数据的宽度和精度
- ```m```，控制宽度，要求是数字（很少使用）,设置的宽度小于数字自身，不生效
- ```.n```，控制小数点精度，要求是数字，会进行小数的四舍五入
##### 示例：
```
%5d
```
表示将整数的宽度控制在5位，如数字11，被设置为5d，就会变成：[空格][空格][空格]11，用三个空格补足宽度
```
%5.2f
```
表示将宽度控制为5，将小数点精度设置为2

小数点和小数部分也算入宽度计算。如，对11.345设置了```%7.2f``` 后，结果是：```[空格][空格]11.35```。2个空格补足宽度，小数部分限制2位精度后，四舍五入为 ```.35```
```
%.2f
```
表示不限制宽度，只设置小数点精度为2，如11.345设置```%.2f```后，结果是11.35
- m和.n均可省略
- 如果m比数字本身宽度还小，则m不生效
- .n会对小数部分做精度限制，同时会对小数部分做四舍五入
### 对表达式进行格式化
#### 表达式：一条具有明确执行结果的代码语句
##### 案例
- ```1 + 1```、```5 * 2``` ，就是表达式，因为有具体的结果，结果是一个数字
- 又或者，常见的变量定义：  
```name = “张三”  age = 11 + 11```  
等号右侧的都是表达式，因为它们有具体的结果，结果赋值给了等号左侧的变量

在无需使用变量进行数据存储的时候，可以直接格式化表达式，简化代码
```
f"{表达式}"
"%s\%d\%f" % (表达式、表达式、表达式）
```

## 数据输入输出
### 数据输出----print语句
#### print输出换行
- 默认print语句输出内容会自动换行
- 要使用print语句，输出不换行的功能，在print语句中加上```end=''```
#### 制表符
##### \t
效果等同于在键盘上按下：tab键，可以让多行字符串进行对齐
### 数据输入----input语句
在Python中读取键盘输入的内容

print语句（函数）可以完成将内容（字面量、变量等）输出到屏幕上

在Python中，与之对应的还有一个input语句，用来获取键盘输入
#### 数据输入：input
#### 使用```input()```语句可以从键盘获取输入
使用一个变量接收（存储）```input```语句获取的键盘输入数据即可
#### 语法
```
变量 = input("提示信息")
```
#### input语句获取的数据类型
无论键盘输入何种类型的数据，```input```语句获取的最终的结果都是：字符串类型的数据


# Python判断语句
判断是程序最基础最核心的逻辑功能
## 布尔类型和比较运算符
### 布尔类型
进行判断，只有2个结果：
是和否
#### 布尔类型的定义
布尔类型的字面量：
##### True  表示真（是、肯定）
##### False 表示假 （否、否定）
#### 定义变量存储布尔类型数据
变量名称 = 布尔类型字面量


### 比较运算符
布尔类型不仅可以自行定义，同时也可以通过计算得来，也就是使用比较运算符进行比较运算得到布尔类型的结果
#### ==
判断内容是否相等，满足为True，不满足为False
#### !=
判断内容是否不相等，满足为True，不满足为False
#### >
判断运算符左侧内容是否大于右侧。满足为True，不满足为False
#### <
判断运算符左侧内容是否小于右侧。满足为True，不满足为False
#### >=
判断运算符左侧内容是否大于等于右侧。满足为True，不满足为False
#### <=
判断运算符左侧内容是否小于等于右侧。满足为True，不满足为False

## if语句
### if语句的基本格式
#### 语法
if 要判断的条件:
    条件成立时要做的事情
#### 注意事项
- 判断条件的结果一定要是布尔类型
- 不要忘记判断条件后的： 引号
- 归属于 if 语句的代码块，需在前方填充4个空格缩进
### if else 语句
#### 语法
```
if 要判断的条件:
    条件成立时要做的事情
else:
    条件不成立时要做的事情
```
- if和其代码块，条件满足时执行
- else搭配if的判断条件，当不满足的时候执行

注意事项
- else不需要判断条件，当if的条件不满足时，else执行
- else的代码块，同样要4个空格作为缩进

### if elif else语句
可以完成多个条件的判断
#### 语法
```
if 条件1:
    条件1满足应做的事情
    条件1满足应做的事情
    ......
elif 条件2:
    条件2满足应做的事情
    条件2满足应做的事情
    ......
elif 条件N:
    条件N满足应做的事情
    条件N满足应做的事情
    ......
else:
    所有条件都不满足应做的事情
    所有条件都不满足应做的事情
    ......
```

#### 判断是互斥且有顺序的
- 满足1, 将不会理会2和3
- 满足2，将不会理会3
- 1、2、3均不满足，进入else
- else也可以省略不写，效果等同3个独立的if判断

#### if elif else注意事项
- elif可以写多个
- 判断是互斥且有序的，上一个满足后面的就不会判断了
- 可以在条件判断中，直接写input语句，节省代码量

### 判断语句的嵌套
有很多场景，不仅仅是多个并列条件，还会有满足前置条件才会二次判断的多层判断需求  
- 对这种需求，嵌套判断语句可以实现  

许多逻辑的判断，是嵌套的，多层次的
- 对于这种需求，可以自由组合 if elif else，完成特定需求的要求
#### 基础语法格式
```
if 条件1:
    满足条件1 做的事情1
    满足条件1 做的事情2

    if 条件2:
        满足条件2 做的事情1
        满足条件2 做的事情2
```
第二个if，属于第一个if内，只有第一个if满足条件，才会执行第二个if

嵌套的关键点，在于：**空格缩进**
- 通过空格缩进，来决定语句之间的：层次关系



# Python循环语句
循环同样是程序最基础最核心的逻辑功能
## while循环
### while循环的基础语法
```
while 条件:
    条件满足时，做的事情1
    条件满足时，做的事情2
    条件满足时，做的事情3
    ......
```
### while循环的注意事项
- 条件需提供布尔类型结果，True继续，False停止
- 空格缩进不能忘
- 规划好循环终止条件，否则将无限循环

### while循环的嵌套应用
#### 嵌套循环的语法格式
```
while 条件1:
    条件1满足时，做的事情1
    条件1满足时，做的事情2
    条件1满足时，做的事情3
    ......

    while 条件2:
        条件2满足时，做的事情1
        条件2满足时，做的事情2
        条件2满足时，做的事情3
        ......
```

#### 嵌套循环的注意事项
- 注意条件的控制，避免无限循环
- 多层嵌套，主要空格缩进来确定层次关系

#### 嵌套循环的使用难点
循环条件的控制，层次越多越复杂，需要细心+耐心

## for循环
Python中的for循环类似于C++和Java中的foreach循环
### while循环与for循环的区别
- while循环的循环条件是自定义的，自行控制循环条件
- for循环是一种”轮询”机制，是对一批内容进行”逐个处理”

### for循环的基础语法
```
for 临时变量 in 待处理数据集: 
    循环满足条件时执行的代码
```
### for循环的注意事项
- for循环也被称之为：遍历循环
- Python中的for循环无法定义循环条件，只能被动取出数据处理
  - 所以，理论上讲，Python的for循环无法构建无限循环（被处理的数据集不可能无限大）
- 要注意，循环内的语句，需要有空格缩进

### range语句
for循环中的待处理数据集，严格来说，称之为：可迭代类型


可迭代类型指，其内容可以一个个依次取出的一种类型，包括：
- 字符串
- 列表
- 元组
- 等

#### for循环语句，本质上是遍历：可迭代对象
#### range语句功能
获得一个数字序列（可迭代类型的一种）
#### range语句语法
##### 语法1
```
range(num)
```
- 获取一个从0开始，到num结束的数字序列（不含num本身）
- 例如range(5)取得的数据是：[0, 1, 2, 3, 4]

##### 语法2
```
range(num1,num2)
```
- 获得一个从num1开始，到num2结束的数字序列（不含num2本身）
- 例如，range(5, 10)取得的数据是：[5, 6, 7, 8, 9]

##### 语法3
```
range(num1,num2,step)
```
- 获得一个从num1开始，到num2结束的数字序列（不含num2本身）
- 数字之间的步长，以step为准（step默认为1）
- 例如，range(5, 10, 2)取得的数据是：[5, 7, 9]

#### for循环遍历range序列
##### 语法
```
for i in range(5): 
       print(i)
```
range的用途很多，多数用在for循环场景

### 变量作用域
#### for循环的变量作用域
临时变量，在编程规范上，作用范围（作用域），只限定在for循环内部
#### 如果在for循环外部访问临时变量
- 实际上是可以访问到的
- 在编程规范上，是不允许、不建议这么做的
- 如果实在需要在循环外访问循环内的临时变量，可以在循环外预先定义


### for循环的嵌套应用
#### for循环的嵌套语法
```
for循环 或 while循环:
    循环满足条件应做的事情1
    循环满足条件应做的事情2
    循环满足条件应做的事情3
    ......
    for循环 或 while循环:
        循环满足条件应做的事情1
        循环满足条件应做的事情2
        循环满足条件应做的事情3
        ......
```
#### for循环的嵌套注意事项
- 需要注意缩进，嵌套for循环同样通过缩进确定层次关系
- for循环和while循环可以相互嵌套使用

## 循环中断---- ```break``` 和 ```continue```
### continue
#### continue关键字用于
中断本次循环，直接进入下一次循环
#### continue可以用于
for循环和while循环，效果一致
#### continue在嵌套循环中的应用
```continue``` 关键字只可以控制：它所在的循环临时中断，无法对上层循环起作用


### break
#### break关键字用于
直接结束所在循环
#### break可以用于
for循环和while循环，效果一致
#### break在嵌套循环中的应用
```break``` 关键字同样只可以控制：它所在的循环永久中断，无法对上层循环起作用


# Python函数
## 函数介绍
### 函数
函数是组织好的，可重复使用的，用来实现特定功能的代码段
### 使用函数的目的
为了得到一个针对特定需求、可供重复利用的代码段
提高程序的复用性，减少重复性代码，提高开发效率
## 函数的定义
### 函数定义语法
```
def 函数名(传入参数):
    函数体
    return 返回值
```
### 函数调用语法
```
函数名(参数)
```

### 函数使用步骤
- 先定义函数
- 后调用函数

### 注意事项
- 参数如不需要，可以省略
- 返回值如不需要，可以省略
- 函数必须先定义后使用

## 函数的参数
### 函数的传入参数
传入参数的功能是：在函数进行计算的时候，接受外部（调用时）提供的数据
### 注意事项
- 函数定义中的参数，称之为形式参数
- 函数调用中的参数，称之为实际参数
- 函数的参数数量不限，使用逗号分隔开
- 传入参数的时候，要和形式参数一一对应，逗号隔开

## 函数的返回值
### 返回值
“返回值”就是程序中函数完成事情后，最后给调用者的结果
### 语法
```
def 函数(参数):
    函数体
    return 返回值
```
```
变量 = 函数(参数)
```
### 注意事项
函数体在遇到 ```return``` 后就结束了，所以写在 ```return``` 后的代码不会执行

### None类型
Python中有一个特殊的字面量：```None```，其类型是：```<class 'NoneType'>```

无返回值的函数，实际上就是返回了：```None``` 这个字面量
#### 函数如何返回None
- 不使用return语句即返回None
- 主动return None
#### None类型的应用场景
- 用在函数无返回值上
- 用在if判断上
  - 在if判断中，None等同于False
  - 一般用于在函数中主动返回None，配合if判断做相关处理
- 用于声明无内容的变量上  
定义变量，但暂时不需要变量有具体值，可以用None来代替

## 函数说明文档
函数是纯代码语言，想要理解其含义，就需要一行行的去阅读理解代码，效率比较低  
可以给函数添加说明文档，辅助理解函数的作用
### 语法
```
def func(x,y):
    """
    函数说明
    :param x:形参x的说明
    :param y:形参y的说明 
    :return:返回值的说明
    """
    函数体
    return 返回值
```
- 通过多行注释的形式，对函数进行说明解释
- 内容应写在函数体之前

### 在PyCharm中查看函数说明文档
在PyCharm编写代码时，可以通过鼠标悬停，查看调用函数的说明文档


## 函数的嵌套调用
### 定义
函数嵌套调用指的是一个函数里面又调用了另外一个函数
### 语法
```
def func_b():
    func_b的函数体

def func_a():
    func_a的函数体的执行语句1
    func_b()
    func_a的函数体的执行语句2

#调用函数func_a
func_a()
```
### 执行流程
如果函数A中，调用了另外一个函数B，那么先把函数B中的任务都执行完毕之后才会回到上次 函数A执行的位置

## 变量的作用域
变量作用域指的是变量的作用范围（变量在哪里可用，在哪里不可用）
主要分为两类：**局部变量**和**全局变量**
### 局部变量
#### 局部变量的定义
局部变量是定义在函数体内部的变量，即只在函数体内部生效
#### 局部变量的作用
在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量

### 全局变量
#### 全局变量的定义
全局变量，指的是在函数体内、外都能生效的变量

如果有一个数据，在函数A和函数B中都要使用，就将这个数据存储在一个全局变量里面

#### global关键字
使用 ```global``` 关键字 可以在函数内部声明变量为全局变量
##### 语法
```
变量名 = 变量值1
def 函数名():
    #global 关键字声明变量是全局变量
    global 变量名
    变量名 = 变量值2
```
## 函数进阶
### 函数多返回值
#### 一个函数如果两个return语句，则只执行了第一个return
原因是因为return可以退出当前函数，导致return下方的代码不执行
#### 如果一个函数要有多个返回值
- 按照返回值的顺序，写对应顺序的多个变量接收即可
- 变量之间用逗号隔开
- 支持不同类型的数据return
### 函数多种传参方式
#### 函数参数种类
根据使用方式上的不同, 函数有4中常见参数使用方式:
##### 位置参数
###### 语法  
调用函数时根据函数定义的参数位置来传递参数  
###### 例如  
```
def user_info(name, age, gender):
    print(f"您的名字是{name}，年龄是{age}，性别是{gender}")

user_info("James",30,"male")
```
###### 注意事项
传递的参数和定义的参数的顺序及个数必须一致
##### 关键字参数
###### 语法
函数调用时通过“键=值”形式传递参数
###### 作用
可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求
###### 例如
```
def user_info(name, age, gender):
    print(f"您的名字是{name}，年龄是{age}，性别是{gender}")

#关键字传参
user_info(name = "James",age = 30,gender = "male")
#可以不按照给定顺序传参
user_info(age = 30,gender = "male",name = "James")
#可以和位置参数混用，位置参数必须在前，且匹配参数顺序
user_info("James",age = 30,gender = "male")
```
###### 注意事项
函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序
##### 缺省参数
###### 定义
缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值
###### 作用
当调用函数时没有传递参数, 就会使用默认是用缺省参数对应的值
###### 例如
```
def user_info(name, age, gender="male"):
    print(f"您的名字是{name}，年龄是{age}，性别是{gender}")

user_info("James",30,)
user_info("Sara",28,"female")
```
###### 注意事项
所有位置参数必须出现在默认参数前，包括函数定义和调用

##### 不定长参数
###### 定义
不定长参数也叫可变参数. 用于不确定调用的时候会传递多少个参数(不传参也可以)的场景
###### 作用
当调用函数时不确定参数个数时, 可以使用不定长参数
###### 不定长参数的类型
###### 位置传递
- 语法  
位置不定长传递以*号标记一个形式参数，以元组的形式接受参数，形式参数一般命名为args
- 例如
```
def user_info(*args):
    print(args)

user_info("James")
user_info("James",30)
```
- 注意事项  
传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是位置传递

###### 关键字传递
- 语法
关键字不定长传递以**号标记一个形式参数，以字典的形式接受参数，形式参数一般命名为 ```kwargs```
- 例如
```
def user_info(**kwargs):
    print(kwargs)

user_info(name="James",age=30,id=110)
```
- 注意事项  
参数是“键=值”形式的形式的情况下, 所有的“键=值”都会被 ```kwargs``` 接受, 同时会根据“键=值”组成字典

### 匿名函数
#### 函数作为参数传递
##### 定义
函数本身也可以作为参数传入另一个函数内
##### 作用
将函数传入的作用在于：传入计算逻辑，而非传入数据
#### lambda匿名函数
##### 定义
函数的定义中
###### def关键字
可以定义带有名称的函数，有名称的函数，可以基于名称重复使用
###### lambda关键字
可以定义匿名函数（无名称），无名称的匿名函数，只可临时使用一次
##### 语法
```
lambda 传入参数:函数体(一行代码)
```
- lambda是关键字，表示定义匿名函数
  - 传入参数表示匿名函数的形式参数，如：x,y表示接收2个形式参数
  - 函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行代码
##### 注意事项
- 匿名函数用于临时构建一个函数，只用一次的场景
- 匿名函数的定义中，函数体只能写一行代码，如果函数体要写多行代码，不可用lambda匿名函数，应使用def定义带名函数


# Python数据容器
## 数据容器概述
### 数据容器定义
#### 一种可以容纳多份数据的数据类型，容纳的每一份数据称之为1个元素
#### 每一个元素，可以是任意类型的数据，如字符串、数字、布尔等
#### 类似于C++的模板和Java的集合

### 数据容器分类
根据特点的不同，如：是否支持重复元素、是否可以修改、是否有序，等，可分为5类
- 列表（list）
- 元组（tuple）
- 字符串（str）
- 集合（set）
- 字典（dict）

## 数据容器----列表（list）
### 基本语法
#### 字面量
```
[元素1,元素2,元素3,元素4,...]
```
#### 定义变量
```
变量名称 = [元素1,元素2,元素3,元素4,...]
```
#### 定义空列表
```
变量名称 = []
变量名称 = list()
```
### 列表内的每一个数据，称之为元素
- 以 [] 作为标识
- 列表内每一个元素之间用, 逗号隔开

*注意：列表可以一次存储多个数据，且可以为不同的数据类型，支持嵌套*

### 列表的下标（索引）
列表的每一个元素，都有编号称之为下标索引
#### 正向
从前向后的方向，编号从 ```0``` 开始递增
#### 反向
从后向前的方向，编号从 ```-1``` 开始递减
#### 通过下标索引取出对应位置的元素的语法
```
列表名[下标]
```
#### 下标索引的注意事项
要注意下标索引的取值范围，超出范围无法取出元素，并且会报错

### 列表的常用操作（方法）
#### 函数与方法
- 在Python中，如果将函数定义为class（类）的成员，那么函数会称之为：方法
- 方法和函数功能一样， 有传入参数，有返回值，只是方法的使用格式不同

##### 函数
函数直接在代码块里定义
```
def 函数名(形参):
    return 返回值
```
函数可以直接调用
```
变量 = 函数名(实参)
```
##### 方法
方法要在类中定义
```
class 类名:
    def 函数名(形参):
        return 返回值
```
方法的调用要使用 ```对象名.方法名```
```
对象 = 类名()
变量 = 对象名.方法名(实参)
```
#### 列表的查询功能（方法）
##### 查找某元素的下标
###### 功能
查找指定元素在列表的下标，如果找不到，报错 ```ValueError```
###### 语法
```
列表.index(元素)
```
index是列表对象（变量）内置的方法（函数）

#### 列表的修改功能（方法）
##### 修改特定位置（索引）的元素值
###### 语法
```
列表[下标] = 值
- 接对指定下标（正向、反向下标均可）的值进行：重新赋值（修改）
```
#### 列表的插入功能
##### 插入元素
###### 语法
```
列表.insert(下标, 元素)
```
###### 功能
在指定的下标位置，插入指定的元素

##### 追加元素
###### 语法
```
列表.append(元素)
```
###### 功能
将指定元素，追加到列表的尾部

##### 追加元素方式2
###### 语法
```
列表.extend(其它数据容器)
```
###### 功能
将其它数据容器的内容取出，依次追加到列表尾部


#### 列表的删除功能
##### 删除元素
###### 语法1
```
del 列表[下标]
```
###### 语法2
```
列表.pop(下标)
```
##### 删除某元素在列表中的第一个匹配项
###### 语法
```
列表.remove(元素)
```
##### 清空列表内容
###### 语法
```
列表.clear()
```
#### 列表的统计功能
##### 统计某元素在列表内的数量
###### 语法
```
列表.count(元素)
```
##### 统计列表内，有多少元素
###### 语法
```
len(列表)
```

### 列表的特点
- 可以容纳多个元素（上限为 ```2**63-1```、```9223372036854775807```个）
- 可以容纳不同类型的元素（混装）
- 数据是有序存储的（有下标序号）
- 允许重复数据存在
- 可以修改（增加或删除元素等）

### list（列表）的遍历
将容器内的元素依次取出进行处理的行为，称之为：遍历、迭代
#### 列表的遍历----while循环
##### 语法
```
index = 0
while index < len(列表):
    元素 = 列表[index]
    对元素进行处理
    index += 1
```
#### 列表的遍历----for循环
##### 语法
```
for 临时变量 in 数据容器:
    对临时变量进行处理
```
每一次循环将列表中的元素取出，赋值到变量 ```i```，供操作

#### while循环和for循环的对比
##### 在循环控制上
- while循环可以自定循环条件，并自行控制
- for循环不可以自定循环条件，只可以一个个从容器内取出数据

##### 在无限循环上
- while循环可以通过条件控制做到无限循环
- for循环理论上不可以，因为被遍历的容器容量不是无限的

##### 在使用场景上
- while循环适用于任何想要循环的场景
- for循环适用于，遍历数据容器的场景或简单的固定次数循环场景

### 列表的排序
```sorted``` 函数，可以对数据容器进行排序。但是 ```sorted```函数无法完成对列表进行排序，并指定排序规则，需要使用列表的 ```sort```方法
#### 使用方式
```
列表.sort(key=选择排序依据的函数, reverse=True|False)
```
- 参数key  
是要求传入一个函数，表示将列表的每一个元素都传入函数中，返回排序的依据
- 参数reverse  
是否反转排序结果，True表示降序，False表示升序



## 数据容器----tuple(元组)
### 元组概述
- 元组同列表一样，都是可以封装多个、不同类型的元素在内
- 但最大的不同点在于：元组一旦定义完成，就不可修改
- 当需要在程序内封装数据，又不希望封装的数据被篡改，那么元组就非常合适
### 定义元组
定义元组使用小括号，且使用逗号隔开各个数据，数据可以是不同的数据类型
#### 语法
##### 定义元组字面量
```
(元素,元素,......,元素)
```
##### 定义元组变量
```
变量名称 = (元素,元素,......,元素)
```
##### 定义空元组
###### 方法1
```
变量名称 = ()
```
###### 方法2
```
变量名称 = tuple()
```
##### 定义只有一个数据的元组，这个数据后面要添加逗号
```
变量名称 = (元素,)
```
**注意：必须带有逗号，否则不是元组类型**

##### 元组也支持嵌套
```
变量名称 = ((元素1.1,元素1.2,元素1.3),(元素2.1,元素2.2,元素2.3))
```

### 元组的相关操作
元组由于不可修改的特性，所以其操作方法非常少
#### 查找数据
##### 方法
```
index()
```
##### 作用
查找某个数据，如果数据存在返回对应的下标，否则报错

#### 统计数据
##### 统计某个数据在当前元组出现的次数
```
count()
```
##### 统计元组内的元素个数
```
len(元组)
```
### 元组的注意事项
- 不可以修改元组的内容，否则会直接报错
- 可以修改元组内嵌套的 ```list``` 的内容（修改元素、增加、删除、反转等）
- 修改元组内嵌套的 ```list``` 时不可以替换 ```list``` 为其它 ```list``` 或其它类型

### 元组的遍历
同列表一样，元组也可以使用 ```while``` 循环和 ```for``` 循环遍历

### 元组的特点
- 可以容纳多个数据
- 可以容纳不同类型的数据（混装）
- 数据是有序存储的（下标索引）
- 允许重复数据存在
- 不可以修改（增加或删除元素等）
- 支持for循环

**多数特性和 ```list``` 一致，不同点在于不可修改的特性**


## 数据容器----str(字符串)
字符串是字符的容器，一个字符串可以存放任意数量的字符。支持下标索引等特性
### 字符串的下标（索引）
- 和其它容器如：列表、元组一样，字符串也可以通过下标进行访问
  - 从前向后，下标从0开始
  - 从后向前，下标从-1开始

### 字符串是一个：无法修改的数据容器
修改、移除和追加均无法完成。如果必须要做，只能得到一个新的字符串，旧的字符串是无法修改

### 字符串的常用操作
#### 查找特定字符串的下标索引值
##### 语法
```
字符串.index(字符串)
```
#### 字符串的替换
##### 语法
```
字符串.replace(字符串1，字符串2）
```
##### 功能
将字符串内的全部：字符串1，替换为字符串2
##### 注意
不是修改字符串本身，而是得到了一个新字符串

#### 字符串的分割
##### 语法
```
字符串.split(分隔符字符串）
```
##### 功能
按照指定的分隔符字符串，将字符串划分为多个字符串，并存入列表对象中
##### 注意
字符串本身不变，而是得到了一个列表对象

#### 字符串的规整操作（去前后空格）
##### 语法
```
字符串.strip()
```
##### 功能
去除字符的前后空格，以及换行符

#### 字符串的规整操作（去前后指定字符串）
##### 语法
```
字符串.strip(字符串)
```
#### 统计字符串中某字符串的出现次数
##### 语法
```
字符串.count(字符串)
```
#### 统计字符串的长度
##### 语法
```
len(字符串)
```
##### 注意
- 数字（1、2、3...）
- 字母（abcd、ABCD等）
- 符号（空格、!、@、#、$等）
- 中文

均算作1个字符

### 字符串的遍历
字符串也支持 ```while``` 循环和 ```for``` 循环进行遍历

### 字符串的特点
#### 作为数据容器，字符串有如下特点
- 只可以存储字符串
- 长度任意（取决于内存大小）
- 支持下标索引
- 允许重复字符串存在
- 不可以修改（增加或删除元素等）
- 支持 ```for``` 循环

#### 基本和列表、元组相同
- 不同于列表和元组的在于
  - 字符串容器可以容纳的类型是单一的，只能是字符串类型
- 不同于列表，相同于元组的在于
  - 字符串不可修改

### 字符串大小比较
- 字符串进行比较时，从头到尾，一位位进行比较，其中一位大，后面就无需比较了
- 单个字符之间，通过ASCII码表，确定字符对应的码值数字来确定大小

## 数据容器（序列）的切片
### 序列
#### 序列概念
序列是指内容连续、有序，可使用下标索引的一类数据容器
#### 列表、元组、字符串，均可以可以视为序列
#### 序列的典型特征就是
有序并可用下标索引，字符串、元组、列表均满足这个要求

### 序列的常用操作 - 切片
#### 切片概念
从一个序列中，取出一个子序列
#### 序列支持切片，即：列表、元组、字符串，均支持进行切片操作
#### 语法
···
序列[起始下标:结束下标:步长]
···
#### 表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列
- 起始下标表示从何处开始，起始可以省略，省略从头开始
- 结束下标（不含）表示何处结束，结束可以省略，省略到尾结束
- 步长表示，依次取元素的间隔，步长可以省略，省略步长为1
  - 步长1表示，一个个取元素
  - 步长2表示，每次跳过1个元素取
  - 步长N表示，每次跳过N-1个元素取
  - 步长为负数表示，反向取（注意，起始下标和结束下标也要反向标记）
#### 注意
此操作不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）


这个操作对列表、元组、字符串是通用的。同时非常灵活，根据需求，起始位置，结束位置，步长（正反序）都是可以自行控制的


## 数据容器----set(集合)
### 为什么使用集合
#### 列表、元组、字符串都支持重复元素
- 列表可修改、支持重复元素且有序
- 元组、字符串不可修改、支持重复元素且有序
#### 集合，最主要的特点就是
**不支持元素的重复（自带去重功能）、并且内容无序**

去重且无序。因为要对元素做去重处理，所以无法保证顺序和创建的时候一致
### 集合的定义
#### 基本语法
##### 定义集合字面量
```
{元素,元素,...,元素}
```
##### 定义集合变量
```
变量名称 = {元素,元素,...,元素}
```
##### 定义空集合
```
变量名称 = set()
```
#### 和列表、元组、字符串等定义基本相同：
- 列表使用：```[]```
- 元组使用：```()```
- 字符串使用：```""```
- 集合使用：```{}```

### 集合的常用操作
集合是无序的，所以集合不支持：下标索引访问  
集合和列表一样，是允许修改的
#### 集合的常用操作----修改
##### 添加新元素
###### 语法
```
集合.add(元素)
```
###### 功能
将指定元素，添加到集合内
###### 结果
集合本身被修改，添加了新元素

##### 移除元素
###### 语法
```
集合.remove(元素)
```
###### 功能
将指定元素，从集合内移除
###### 结果
集合本身被修改，移除了元素

##### 从集合中随机取出元素
###### 语法
```
集合.pop()
```
###### 功能
从集合中随机取出一个元素
###### 结果
会得到一个元素的结果。同时集合本身被修改，元素被移除

##### 清空集合
###### 语法
```
集合.clear()
```
###### 功能
清空集合
###### 结果
集合本身被清空

##### 取出2个集合的差集
###### 语法
```
集合1.difference(集合2)
```
###### 功能
取出集合1和集合2的差集（集合1有而集合2没有的）
###### 结果
得到一个新集合，集合1和集合2不变

##### 消除2个集合的差集
###### 语法
```
集合1.difference_update(集合2)
```
###### 功能
对比集合1和集合2，在集合1内，删除和集合2相同的元素
###### 结果
集合1被修改，集合2不变

##### 2个集合合并
###### 语法
```
集合1.union(集合2)
```
###### 功能
将集合1和集合2组合成新集合
###### 结果
得到新集合，集合1和集合2不变

#### 集合的常用操作----集合长度
##### 查看集合的元素数量
###### 语法
```
len(集合)
```
###### 功能
统计集合内有多少元素
###### 结果
得到一个整数结果

#### 集合的常用操作----for循环遍历
- 集合同样支持使用for循环遍历
- 要注意：集合不支持下标索引，所以也就不支持使用 ```while``` 循环

### 集合的特点
- 可以容纳多个数据
- 可以容纳不同类型的数据（混装）
- 数据是无序存储的（不支持下标索引）
- 不允许重复数据存在
- 可以修改（增加或删除元素等）
- 支持for循环

## 数据容器----dict(字典、映射)
### 字典的定义
字典的定义，同样使用{}，不过存储的元素是一个个的：键值对
#### 语法
##### 定义字典字面量
```
{key : value, key : value,...,key : value}
```
##### 定义字典变量
```
my_dict = {key : value, key : value,...,key : value}
```
##### 定义空字典
###### 方式1
```
my_dict = {}
```
###### 方式2
```
my_dict = dict()
```

#### 注意事项
- 使用{}存储原始，每一个元素是一个键值对
- 每一个键值对包含Key和Value（用冒号分隔）
- 键值对之间使用逗号分隔
- Key和Value可以是任意类型的数据（key不可为字典）
- Key不可重复，重复会对原有数据覆盖

### 字典数据的获取
- 字典同集合一样，不可以使用下标索引
- 但是字典可以通过Key值来取得对应的Value

### 字典的嵌套
字典的Key和Value可以是任意数据类型（Key不可为字典）。表明，字典是可以嵌套的

#### 嵌套字典的内容获取

### 字典的常用操作
#### 新增元素
##### 语法
```
字典[Key] = Value
```
##### 结果
字典被修改，新增了元素

#### 更新元素
##### 语法
```
字典[Key] = Value
```
##### 结果
字典被修改，元素被更新
##### 注意
字典Key不可以重复，所以对已存在的Key执行上述操作，就是更新Value值

#### 删除元素
##### 语法
```
字典.pop(Key)
```
##### 结果
获得指定Key的Value，同时字典被修改，指定Key的数据被删除

#### 清空字典
##### 语法
```
字典.clear()
```
##### 结果
字典被修改，元素被清空

#### 获取全部的key
##### 语法
```
字典.keys()
```
##### 结果
得到字典中的全部Key

#### 遍历字典
##### 语法
```
for key in 字典.keys()
```
##### 注意
字典不支持下标索引，所以同样不可以用while循环遍历

#### 计算字典内的全部元素（键值对）数量
##### 语法
```
len(字典)
```
##### 结果
得到一个整数，表示字典内元素（键值对）的数量

### 字典的特点
- 可以容纳多个数据
- 可以容纳不同类型的数据
- 每一份数据是KeyValue键值对
- 可以通过Key获取到Value，Key不可重复（重复会覆盖）
- 不支持下标索引
- 可以修改（增加或删除更新元素等）
- 支持for循环，不支持while循环

## 数据容器对比总结
### 数据容器分类
- 是否支持下标索引
  - 支持：列表、元组、字符串 - 序列类型
  - 不支持：集合、字典 - 非序列类型
- 是否支持重复元素
  - 支持：列表、元组、字符串 - 序列类型
  - 不支持：集合、字典 - 非序列类型
- 是否可以修改
  - 支持：列表、集合、字典
  - 不支持：元组、字符串

### 数据容器使用场景
#### 列表
可修改、可重复的一批数据记录场景
#### 元组
不可修改、可重复的一批数据记录场景
#### 字符串
一串字符的记录场景
#### 集合
不可重复的数据记录场景
#### 字典
以Key检索Value的数据记录场景


## 数据容器的通用操作
### 数据容器的通用操作----遍历
#### 5类数据容器都支持for循环遍历
#### 列表、元组、字符串支持while循环，集合、字典不支持（无法下标索引）

### 数据容器的通用操作----统计功能
```
len(容器)
```
统计容器的元素个数
```
max(容器)
```
统计容器的最大元素
```
min(容器)
```
统计容器的最小元素

### 数据容器的通用操作----转换功能
```
list(容器)
```
将给定容器转换为列表
```
str(容器)
```
将给定容器转换为字符串
```
tuple(容器)
```
将给定容器转换为元组
```
set(容器)
```
将给定容器转换为集合

### 数据容器的通用操作----排序功能
```
sorted(容器, [reverse=True])
```
将给定容器进行排序
```
reverse=True表示降序
```
##### 注意
排序后都会得到列表 ```list``` 对象。（如果是对字典使用 ```sorted``` ，会丢失 ```value``` ）

# Python文件操作
## 文件的编码
### 编码概念
#### 编码
编码就是一种规则集合，记录了内容和二进制间进行相互转换的逻辑
#### 编码技术
翻译的规则，记录了如何将内容翻译成二进制，以及如何将二进制翻译回可识别内容
#### 为什么需要使用编码
- 计算机只认识0和1，所以需要将内容翻译成0和1才能保存在计算机中
- 同时也需要编码，将计算机保存的0和1，反向翻译回可以识别的内容

### 常见编码
#### UTF-8----当前最常用的多语言通用编码
UTF-8是目前全球通用的编码格式  
除非有特殊需求，否则，一律以UTF-8格式进行文件编码即可
#### GBK------中文编码
#### Big5-----繁体中文编码

## 文件的读取
### 什么是文件
- 内存中存放的数据在计算机关机后就会消失。要长久保存数据，就要使用硬盘、光盘、U 盘等设备。为了便于数据的管理和检索，引入了“文件”的概念
-  一篇文章、一段视频、一个可执行程序，都可以被保存为一个文件，并赋予一个文件名。操作系统以文件为单位管理磁盘中的数据
-  文件可分为文本文件、视频文件、音频文件、图像文件、可执行文件等多种类别

### 文件操作
文件操作主要包括打开、关闭、读、写等操作

### 打开文件
#### open()打开函数
在Python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件
##### 语法
```
open(name, mode, encoding)
```
- name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)
- mode：设置打开文件的模式(访问模式)：只读r、写入w、追加a等
- encoding: 编码格式（推荐使用UTF-8）
##### 示例代码
```
f = open('python.txt', 'r', encoding=”UTF-8)
```
- encoding的顺序不是第三位，所以不能用位置参数，用关键字参数直接指定
- 注意：此时的 ```f```是 ```open``` 函数的文件对象，对象是Python中一种特殊的数据类型，拥有属性和方法，可以使用对象.属性或对象.方法对其进行访问

##### mode常用的三种基础访问模式
###### 只读--r
以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式
###### 写入--w
打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，原有内容会被删除。如果该文件不存在，创建新文件
###### 追加--a
打开一个文件用于追加。如果该文件已存在，新的内容将会被写入到已有内容之后  
如果该文件不存在，创建新文件进行写入

##### with open
###### 语法
```
with open("python.txt", "r") as f:
    f.readlines()
```
- 通过在with open的语句块中对文件进行操作
- 可以在操作完成后自动关闭close文件，避免遗忘掉close方法

#### 读写文件--读操作
##### read()方法
###### 语法
```
文件对象.read(num)
```
- num  
num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据

##### readlines()方法
 ```readlines``` 可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素
```
f = open('python.txt')
content = f.readlines()

# ['hello world\n', 'abcdefg\n', 'aaa\n', 'bbb\n', 'ccc']
print(content)
```
# 关闭文件
```
f.close()
```

##### readline()方法
一次读取一行内容
```
f = open('python.txt')

content = f.readline()
print(f'第一行：{content}')

content = f.readline()
print(f'第二行：{content}')

# 关闭文件
f.close()
```
##### for循环读取文件行
```
for line in open("python.txt", "r"):
    print(line)

# 每一个line临时变量，就记录了文件的一行数据
```
### 关闭文件
#### close() 关闭文件对象
```
f = open("python.txt", "r")

f.close()

# 最后通过close，关闭文件对象，也就是关闭对文件的占用
# 如果不调用close,同时程序没有停止运行，那么这个文件将一直被Python程序占用
```

## 文件的写入
### 打开文件
```
f = open('python.txt', 'w')
```
### 文件写入
```
f.write('hello world')
```
### 内容刷新
```
f.flush()
```
### 注意
- 直接调用write，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区
- 当调用flush的时候，内容会真正写入文件
- 这样做是避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写磁盘）
- ```close()``` 方法，带有 ```flush()``` 方法的功能

### 写操作注意
- 文件如果不存在，使用 ```w``` 模式，会创建新文件
- 文件如果存在，使用 ```w``` 模式，会将原有内容清空

## 文件的追加
### 文件追加
```
# 1. 打开文件，通过a模式打开即可
f = open('python.txt', 'a')

# 2.文件写入
f.write('hello world')
```

# 3. 内容刷新
```
f.flush()
```
### 注意
- a模式，文件不存在会创建文件
- a模式，文件存在会在最后，追加写入文件
- 可以使用 ```\n``` 来写出换行符



# 异常
## 异常的概念
当检测到一个错误时，Python解释器就无法继续执行了，反而出现了一些错误的提示，这就是“异常”，即BUG

## 异常的捕获方法
### 为什么要捕获异常
- 世界上没有完美的程序，任何程序在运行的过程中，都有可能出现：异常，也就是出现bug，导致程序无法完美运行下去。
- 我们要做的，不是力求程序完美运行。而是在力所能及的范围内，对可能出现的bug，进行提前准备、提前处理。
- 这种行为我们称之为：异常处理（捕获异常）

### 捕获异常的作用
- 提前假设某处会出现异常，做好提前准备，当真的出现异常的时候，可以有后续手段
- 在可能发生异常的地方，进行捕获。当异常出现的时候，提供解决方式，而不是任由其导致程序无法运行

### 捕获异常的语法
```
try:
    可能发生异常的语句
except[异常 as 别名]:
    出现异常的准备手段
[else:]
    未出现异常时应做的事情
[finally:]
    不管出不出现异常都会做的事情
```
### 捕获常规异常
#### 基本语法
```
try:
    可能发生错误的代码
except:
    如果出现异常执行的代码
```
### 捕获指定异常
#### 基本语法
```
try:
    print(name)
except NameError as e:
    print('name变量名称未定义错误')
```
#### 注意事项
- 如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常
- 一般try下方只放一行尝试执行的代码

### 捕获多个异常
当捕获多个异常时，可以把要捕获的异常类型的名字，放到 ```except``` 后，并使用元组的方式进行书写
#### 基本语法
```
try:
    print(1/0)
except (NameError, ZeroDivisionError):
    print('ZeroDivision错误...')
```
### 捕获异常并输出描述信息
#### 基本语法
```
try:
    print(num)
except (NameError, ZeroDivisionError) as e:
    print(e)
```
### 捕获所有异常
#### 基本语法
```
try:
    print(name)
except Exception as e:
    print(e)
```
### 异常的else
else表示的是如果没有异常要执行的代码
#### 基本语法
```
try:
    print(1)
except Exception as e:
    print(e)
else:
    print('我是else，是没有异常的时候执行的代码')
```
### 异常的finally
finally表示的是无论是否异常都要执行的代码，例如关闭文件
#### 基本语法
```
try:
    f = open('test.txt', 'r')
except Exception as e:
    f = open('test.txt', 'w')
else:
    print('没有异常，真开心')
finally:
    f.close()
```

## 异常的传递
- 异常具有传递性
当函数 ```func01``` 中发生异常, 并且没有捕获处理这个异常的时候, 异常会传递到函数 ```func02``` , 当```func02``` 也没有捕获处理这个异常的时候 ```main``` 函数会捕获这个异常,  这就是异常的传递性

- 当所有函数都没有捕获异常的时候, 程序就会报错

- 利用异常具有传递性的特点, 当我们想要保证程序不会因为异常崩溃的时候, 就可以在 ```main``` 函数中设置异常捕获, 由于无论在整个程序哪里发生异常, 最终都会传递到 ```main``` 函数中, 这样就可以确保所有的异常都会被捕获


# Python模块
## 基本概念
### 模块概念
Python 模块(Module)，是一个 Python 文件，以 ```.py``` 结尾

模块能定义函数，类和变量，模块里也能包含可执行的代码
### 模块的作用
python中有很多各种不同的模块, 每一个模块都可以帮助我们快速的实现一些功能, 比如实现和时间相关的功能就可以使用time模块。我们可以认为一个模块就是一个工具包, 每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能

### 模块的导入方式
模块在使用前需要先导入
#### 语法
```
[from 模块名] import [模块|类|变量|函数|*][as 别名]
```
#### 常用的组合形式
```
import 模块名
```
```
import 模块名，模块名2
```
```
from 模块名 import 类、变量、方法等
```
```
from 模块名 import *
```
```
import 模块名 as 别名
```
```
from 模块名 import 功能名 as 别名
```

#### 注意事项
-  ```from``` 可以省略，直接 ```import``` 即可
-  ```as``` 别名可以省略
- 通过 ```.``` 来确定层级关系
- 模块的导入一般写在代码文件的开头位置


## 自定义模块
### 制作自定义模块
- Python中已经实现了很多的模块. 不过有时候需要一些个性化的模块, 可以通过自定义模块实现, 也就是自己制作一个模块
- 每个Python文件都可以作为一个模块，模块的名字就是文件的名字. 也就是说自定义模块名必须要符合标识符命名规则
- 在Python代码文件中正常写代码即可，通过import、from关键字和导入Python内置模块一样导入即可使用

```
if __name__ == '__main__'
```
在实际开发中，当开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，开发人员会自行在py文件中添加一些测试信息
```
def test(a, b):
    print(a + b)


test(1, 1)
```
#### 此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行 ```test``` 函数的调用
#### 解决方案
```
def test(a, b):
    print(a + b)

# 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行test函数调用
if __name__ == '__main__':
    test (1, 1)
```
```if __main__ == “__main__”``` 表示，只有当程序是直接执行的才会进入if内部，如果是被导入的，则if无法进入

### 注意事项
当导入多个模块的时候，且模块内有同名功能. 当调用这个同名功能的时候，调用到的是后面导入的模块的功能
```
__all__
```
如果一个模块文件中有 ```__all__``` 变量，当使用 ```from xxx import *``` 导入时，只能导入这个列表中的元素



# Python包
## 自定义包
### Python包的概念
- 从物理上看，包就是一个文件夹，在该文件夹下包含了一个  ```__init__.py``` 文件，该文件夹可用于包含多个模块文件
- 从逻辑上看，包的本质依然是模块
### 包的作用 
当模块文件越来越多时,包可以帮助我们管理这些模块, 包的作用就是包含多个模块，但包的本质依然是模块
### ```__init__.py``` 文件的作用
创建包会默认自动创建的文件，通过这个文件来表示一个文件夹是Python的包，而非普通的文件夹
### ```__all__``` 变量的作用
同模块中的是一个作用，控制 ```import *``` 能够导入的内容

### 导入包
#### 方式1
```
import 包名.模块名
import 包名.模块名.目标
```
#### 方式2
```
from 包名 import *
```
*注意：必须在 ```__init__.py``` 文件中添加 ```__all__ = []```，控制允许导入的模块列表*


## 安装第三方包
包可以包含一堆的Python模块，而每个模块又内含许多的功能。一个包，就是一堆同类型功能的集合体
### 第三方包
在Python程序的生态中，有许多非常多的第三方包（非Python官方），可以极大的帮助我们提高开发效率
- 科学计算中常用的：numpy
- 数据分析中常用的：pandas
- 大数据计算中常用的：pyspark apache-flink
- 图形可视化常用的：matplotlib pyecharts
- 人工智能常用的：pytorch tensorflow

### 安装方法
#### 在conda中安装
##### 在命令提示符内
```
pip install 包名称
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称
```
##### 在PyCharm中安装


# json数据格式
## json概念
- JSON是一种轻量级的数据交互格式。可以按照JSON指定的格式去组织和封装数据
- JSON本质上是一个带有特定格式的字符串

## 主要功能
json就是一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互。类似于：国际通用语言-英语

## json用途
- 各种编程语言存储数据的容器不尽相同,在Python中有字典dict这样的数据类型, 而其它语言可能没有对应的字典
- 为了让不同的语言都能够相互通用的互相传递数据，JSON就是一种非常良好的中转数据格式

## json格式数据转化
json格式的数据要求很严格
### json格式的数据
```
# json数据的格式可以是： 
{"name":"admin","age":18} 


# 也可以是：  
[{"name":"admin","age":18},{"name":"root","age":16},{"name":"张三","age":20}] 
```
### Python数据和Json数据的相互转化
```
# 导入json模块 
import json 

# 准备符合格式json格式要求的python数据 
data = [{"name": "老王", "age": 16}, {"name": "张三", "age": 20}]
 
# 通过 json.dumps(data) 方法把python数据转化为了 json数据 
data = json.dumps(data) 

# 通过 json.loads(data) 方法把json数据转化为了 python数据 
data = json.loads(data)
```

# pyecharts
## pyecharts概况
Echarts 是个由百度开源的数据可视化，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可. 而 Python 是门富有表达力的语言，很适合用于数据处理. 当数据分析遇上数据可视化时pyecharts 诞生了

### 官网
#### 官方文档
https://pyecharts.org/#/zh-cn/intro
#### gallery
https://gallery.pyecharts.org/#/README

## pyecharts模块安装
```
pip install pyecharts
conda install pyecharts
```
## 折线图
# 导包
```
import pyecharts.charts as charts
import pyecharts.options as opts
```
# 创建一个折线图对象
```
lineGraph = charts.Line()
# 给折线图对象添加x轴的数据
lineGraph.add_xaxis(['China', 'UK', 'USA'])
# 给折线图对象添加y轴的数据
lineGraph.add_yaxis('GDP', [180, 68, 89])
# 设置全局配置项set_global_opts来设置
lineGraph.set_global_opts(
    title_opts=opts.TitleOpts(title="GDP Graph",pos_left='center'),
    xaxis_opts=opts.AxisOpts(is_show=True, name='Country'),
    yaxis_opts=opts.AxisOpts(is_show=True, name='GDP per capita'),
    toolbox_opts=opts.ToolboxOpts(is_show=True),
    tooltip_opts=opts.TooltipOpts(is_show=True),
    legend_opts=opts.LegendOpts(is_show=True, pos_left='right'),
    visualmap_opts=opts.VisualMapOpts(is_show=True)
)
# 通过render方法，将代码生成为图像
lineGraph.render()
```

## pyecharts有哪些配置选项
### 全局配置选项
#### set_global_opts方法
全局配置选项可以通过set_global_opts方法来进行配置
```
options.TitleOpts
```
标题配置项
```
options.LegendOpts
```
图例配置项
```
options.ToolboxOpts
```
工具箱配置项
```
options.TooltipOpts
```
提示框配置项
```
options.VisualMapOpts
```
视觉映射配置项
```
options.DataZoomOpts
```
区域缩放配置项
### 系列配置选项
## 地图
```
from pyecharts.charts import Map
from pyecharts.options import VisualMapOpts

# 准备地图对象
map = Map()

# 准备数据
data = [
    ("北京", 99),
    ("上海", 199),
    ("湖南", 299),
    ("台湾", 399),
    ("广东", 499)
]

# 添加数据
map.add("测试地图", data, "china")

# 设置全局选项
map.set_global_opts(
    visualmap_opts=VisualMapOpts(
        is_show=True,
        is_piecewise=True,
        pieces=[
            {"min": 1, "max": 9, "label": "1-9", "color": "#CCFFFF"},
            {"min": 10, "max": 99, "label": "10-99", "color": "#FF6666"},
            {"min": 100, "max": 500, "label": "100-500", "color": "#990033"}
        ]
    )
)

# 绘图
map.render()
```

## 柱状图
### 基础柱状图
- 通过 ```Bar()``` 构建一个柱状图对象
- 和折线图一样，通过 ```add_xaxis()``` 和 ```add_yaxis()``` 添加x和y轴数据
- 通过柱状图对象的：```reversal_axis()``` ，反转x和y轴
- 通过 ```label_opts=LabelOpts(position="right")``` 设置数值标签在右侧显示
```
bar = charts.Bar()
bar.add_xaxis(['China','USA','UK'])
bar.add_yaxis('GDP',[87,98,83],label_opts=opts.LabelOpts(position='right'))
bar.reversal_axis()
bar.render('bar_test.html')
```
### 时间线柱状图
#### Timeline()-时间线
- 柱状图描述的是分类数据，回答的是每一个分类中『有多少？』这个问题. 这是柱状图的主要特点,同时柱状图很难动态的描述一个趋势性的数据。pyecharts提供了一种解决方案-时间线
- 一个Bar、Line对象是一张图表，时间线就是创建一个一维的x轴，轴上每一个点就是一个图表对象

#### 构建时间线
```
from pyecharts.charts import Bar, Timeline
from pyecharts.options import LabelOpts
from pyecharts.globals import ThemeType

bar1 = Bar()
bar1.add_xaxis(["中国", "美国", "英国"])
bar1.add_yaxis("GDP", [30, 30, 20], label_opts=LabelOpts(position="right"))
bar1.reversal_axis()

bar2 = Bar()
bar2.add_xaxis(["中国", "美国", "英国"])
bar2.add_yaxis("GDP", [50, 50, 50], label_opts=LabelOpts(position="right"))
bar2.reversal_axis()

bar3 = Bar()
bar3.add_xaxis(["中国", "美国", "英国"])
bar3.add_yaxis("GDP", [70, 60, 60], label_opts=LabelOpts(position="right"))
bar3.reversal_axis()

# 构建时间线对象
timeline = Timeline({"theme": ThemeType.LIGHT})

# 在时间线内添加柱状图对象
timeline.add(bar1, "点1")
timeline.add(bar2, "点2")
timeline.add(bar3, "点3")

# 绘图是用时间线对象绘图，而不是bar对象了
timeline.render("基础时间线柱状图.html")
```
#### 自动播放设置
```
timeline.add_schema(
    play_interval=1000,
    is_timeline_show=True,
    is_auto_play=True,
    is_loop_play=True
)
```
#### 设置时间线主题
##### 示例代码
```
from pyecharts.globals import ThemeType
timeline = Timeline({"theme": ThemeType.LIGHT})
```

# 面向对象
## 初识对象
### 使用对象组织数据
- 在程序中设计表格，称为：设计类（class）
- 在程序中打印生产表格，称为：创建对象
- 在程序中填写表格，称之为：对象属性赋值

## 成员方法
### 类的定义
#### 语法
##### 定义类
```
class 类名称:
    类的属性
    类的行为
```
- class是关键字，表示定义类
- 类的属性，即定义在类中的变量（成员变量）
- 类的行为，即定义在类中的函数（成员方法）

##### 创建类对象
```
对象名 = 类名称()
```
### 成员变量和成员方法
#### 类中
- 不仅可以定义属性用来记录数据
- 也可以定义函数，用来记录行为

*定义在类内部的函数称为方法*

#### 成员方法的定义语法
在类中定义成员方法和定义函数基本一致，但仍有细微区别
```
def 方法名(self, 形参1,...,形参N):
     方法体
```
在方法定义的参数列表中，有一个 self 关键字
- self 关键字是成员方法定义的时候，必须填写的。它用来表示类对象自身的意思
- 当使用类对象调用方法的是，self 会自动被 python 传入
- 在方法内部，想要访问类的成员变量，必须使用 self

##### 注意事项
 self 关键字尽管在参数列表中，但是传参的时候可以忽略它


## 类和对象
### 概念
- 基于类创建对象的语法
- 类只是一种程序内的“设计图纸”，需要基于图纸生产实体（对象），才能正常工作。这种套路，称之为：面向对象编程

## 魔术方法
### 构造方法
可用于创建类对象的时候设置初始化行为
#### 语法
```
__init__()
```
#### 构造方法的作用
- 构建类对象的时候会自动运行
- 构建类对象的传参会传递给构造方法，借此特性可以给成员变量赋值
#### 注意事项
- 构造方法不要忘记 ```self``` 关键字
- 在方法内使用成员变量需要使用 ```self```
  - 因为变量是定义在构造方法内部，如果要成为成员变量，需要用 ```self``` 来表示

### 其它内置方法
#### 字符串方法
用于实现类对象转字符串的行为
##### 语法
```
__str__
```
当类对象需要被转换为字符串之时，会输出内存地址。可以通过 ```__str__``` 方法，控制类转换为字符串的行为
- 方法名：```__str__```
- 返回值：字符串
- 内容：自行定义


#### 大于、小于符号比较
用于2个类对象进行小于或大于比较
##### 语法
```
__lt__
```
Python无法直接对2个对象进行比较，但是在类中实现 ```__lt__``` 方法，即可同时完成：小于符号 和 大于符号 2种比较
- 方法名： ```__lt__```
- 传入参数：```other```，另一个类对象
- 返回值：```True``` 或 ```False```
- 内容：自行定义
- 比较大于符号的魔术方法是： ```__gt__```
  - 实现了 ```__lt__``` ， ```__gt__``` 就没必要实现了


#### 大于等于、小于等于符号比较
用于2个类对象进行小于等于或大于等于比较
##### 语法
```
__le__
```
```__le__``` 可用于：<=、>=两种比较运算符上
- 方法名：```__le__```
- 传入参数：other，另一个类对象
- 返回值：True 或 False
- 内容：自行定义
- ```>=``` 符号实现的魔术方法是：```__ge__```
  - 实现了 ```__le__``` ，```__ge__``` 就没必要实现了

#### 相等符号比较
用于2个类对象进行相等比较
##### 语法
```
__eq__
```
不实现 ```__eq__``` 方法，对象之间可以比较，但是是比较内存地址，也即是：不同对象==比较一定是False结果

实现了 ```__eq__``` 方法，就可以根据需求来决定2个对象是否相等

- 方法名：```__eq__```
- 传入参数：other，另一个类对象
- 返回值：True 或 False
- 内容：自行定义

## 封装
### 面向对象思想
#### 面向对象的理解
- 面向对象编程，是许多编程语言都支持的一种编程思想。
- 简单理解是  
基于模板（类）去创建实体（对象），使用对象完成功能开发
#### 面向对象的三大特性
- 封装
- 继承
- 多态


### 封装的概念
封装表示的是，将现实世界事物的：属性和行为封装到类中，描述为：成员变量和成员方法，从而完成程序对现实世界事物的描述

将现实世界事物在类中描述为属性和方法，即为封装

### 对用户隐藏的属性和行为
现实世界中的事物，有属性和行为。但是不代表这些属性和行为都是开放给用户使用的

### 私有成员
既然现实事物有不公开的属性和行为，那么作为现实事物在程序中映射的类，也应该支持
#### 类中提供了私有成员的形式来支持
- 私有成员变量
- 私有成员方法

#### 定义私有成员的方式
- 私有成员变量  
变量名以__开头（2个下划线）

- 私有成员方法  
方法名以__开头（2个下划线）

#### 私有成员的访问限制
- 类对象无法访问私有成员，私有方法无法直接被类对象使用，无法赋值，也无法获取值
- 类中的其它成员可以访问私有成员

#### 私有成员的实际意义
在类中提供仅供内部使用的属性和方法，而不对外开放


## 继承
### 继承的概念
- 继承就是一个类，继承另外一个类的成员变量和成员方法（不含私有）
- 子类构建的类对象，可以
  - 有自己的成员变量和成员方法
  - 使用父类的成员变量和成员方法

### 继承的语法
```
class 类([父类1,父类2,...,N]):
   类内容体
```
### 单继承和多继承
#### 单继承
一个类继承另一个类
#### 多继承
- 一个类继承多个类，按照顺序从左向右依次继承
- 多继承中，如果父类有同名方法或属性，先继承的优先级高于后继承，默认以继承顺序（从左到右）为优先级。即：**先继承的保留，后继承的被覆盖**

### pass关键字
```pass```是占位语句，用来保证函数（方法）或类定义的完整性，表示无内容，空的意思


### 复写
#### 复写概念
对父类的成员属性或成员方法进行重新定义
#### 复写的语法
在子类中重新实现同名成员方法或成员属性即可

### 使用父类成员
一旦复写父类成员，那么类对象调用成员的时候，就会调用复写后的新成员

如果需要使用被复写的父类的成员，需要特殊的调用方式
#### 方式1--调用父类成员
##### 使用成员变量
```
父类名.成员变量
```
##### 使用成员方法
```
父类名.成员方法(self)
```
#### 方式2--使用super()调用父类成员
##### 使用成员变量
```
super().成员变量
```
##### 使用成员方法
```
super().成员方法()
```
*注意：只可以在子类内部调用父类的同名成员，子类的实体类对象调用默认是调用子类复写的*

## 类型注解
Python在3.5版本的时候引入了类型注解，以方便静态类型检查工具，IDE等第三方工具
### 类型注解的概念
在代码中涉及数据交互之时，对数据类型进行显式的说明
### 主要功能
- 帮助第三方IDE工具（如PyCharm）对代码进行类型推断，协助做代码提示
- 帮助开发者自身对变量进行类型注释

### 类型
- 变量的类型注解
- 函数（方法）形参列表和返回值的类型注解

### 变量的类型注解
#### 语法
##### 语法1
```
变量: 类型
```
##### 语法2
```
在注释中，# type: 类型
```
#### 注意事项
- 元组类型设置类型详细注解，需要将每一个元素都标记出来
- 字典类型设置类型详细注解，需要2个类型，第一个是key第二个是value
- 为变量设置注解，显式的变量定义，一般无需注解。无法直接看出变量类型之时会添加变量的类型注解

#### 类型注解的限制
- 类型注解并不会真正的对类型做验证和判断
- 类型注解仅仅是提示性的，不是决定性的

#### 示例代码
```
# 基础数据类型注解
var_1: int = 10
var_2: str = "itheima"
var_3: bool = True
# 类对象类型注解
class Student:
    pass
stu: Student = Student()
# 基础容器类型注解
my_list: list = [1, 2, 3]
my_tuple: tuple = (1, 2, 3)
my_dict: dict = {"itheima": 666}
# 容器类型详细注解
my_list: list[int] = [1, 2, 3]
my_tuple: tuple[int, str, bool] = (1, "itheima", True)
my_dict: dict[str, int] = {"itheima": 666}
# 在注释中进行类型注解
var_1 = random.randint(1, 10)   # type: int
var_2 = json.loads('{"name": "zhangsan"}')  # type: dict[str, str]
def func():
    return 10
var_3 = func()  # type: int
# 类型注解的限制
var_4: int = "itheima"
var_5: str = 123
```

### 函数（方法）的类型注解
#### 形参注解
##### 语法
```
def 函数方法名(形参名:类型,形参名:类型,...):
```
#### 返回值注解
##### 语法
```
def 函数方法名(形参名:类型,形参名:类型,...) -> 返回值类型:
```
### Union类型
#### Union类型概念
- 使用Union可以定义联合类型注解
- Union联合类型注解，在变量注解、函数（方法）形参和返回值注解中，均可使用
#### Union的使用方式
##### 导包
```
from typing import Union
```
##### 使用
```
Union[类型, ......, 类型]
```

## 多态
### 多态的概念
- 多态指的是，同一个行为，使用不同的对象获得不同的状态
- 如，定义函数（方法），通过类型注解声明需要父类对象，实际传入子类对象进行工作，从而获得不同的工作状态
- 同样的行为（函数），传入不同的对象，得到不同的状态

### 多态常作用在继承关系上
- 函数(方法)形参声明接收父类对象，实际传入父类的子类对象进行工作
- 以父类做定义声明，以子类做实际工作，用以获得同一行为, 不同状态


### 抽象类（接口）
#### 抽象类的概念
- 抽象类  
包含抽象方法的类
- 抽象方法  
没有具体实现的方法（pass）

#### 这种设计的含义
- 父类用来确定有哪些方法
- 具体的方法实现，由子类自行决定

#### 抽象类的作用
- 多用于做顶层设计（设计标准），以便子类做具体实现
- 也是对子类的一种软性约束，要求子类必须复写（实现）父类的一些方法
- 并配合多态使用，获得不同的工作状态
  - 抽象的父类设计----设计标准
  - 具体的子类实现----实现标准


# Python & MySQL数据库操作
## pymysql
在Python中，使用第三方库：```pymysql``` 来完成对MySQL数据库的操作
### 安装
```
pip install pymysql
```
### 获取链接对象
#### 导包
```
from pymysql import Connection
```
#### 获取链接对象
Connection(主机,端口,账户,密码)即可得到链接对象
```
# 构建到MySQL数据库的链接
conn = Connection(
    host="localhost",   # 主机名（IP）
    port=3306,          # 端口
    user="root",        # 账户
    password="123456",  # 密码
    autocommit=True     # 设置自动提交
)
```
#### 选择数据库
```
conn.select_db("world")
```
### 执行查询SQL
#### 获取到游标对象
```
# 获取到游标对象
cursor = conn.cursor()      
#### 执行sql
# 执行sql
cursor.execute("SELECT * FROM student")
```
#### 获取查询结果
```
result: tuple = cursor.fetchall()
```
- 游标对象使用 ```fetchall()``` 方法，得到的是全部的查询结果，是一个元组
- 这个元组内部嵌套了元组，嵌套的元组就是一行查询结果

### 执行非查询SQL
#### 获取到游标对象
```
# 获取到游标对象
cursor = conn.cursor()   
```   
#### 执行sql
```
# 执行sql
cursor.execute("INSERT INTO student VALUES(4,'Nana'),(5,'Dan')")
```
#### 提交事务
```
cursor.connection.commit()
```
注意
- pymysql库在执行对数据库有修改操作的行为时，是需要通过链接对象的commit成员方法来进行确认的
- 只有确认的修改，才能生效
- 在 ```conn = Connection()``` 中设置```autocommit=True``` ，为自动提交

### 关闭链接
关闭和MySQL数据库的连接
```
链接对象.close()
```

# PySpark
## PySpark简介
### Spark定义
- Apache Spark是用于大规模数据（large-scala data）处理的统一（unified）分析引擎
- 简单来说，Spark是一款分布式的计算框架，用于调度成百上千的服务器集群，计算TB、PB乃至EB级别的海量数据

### Python On Spark
Spark作为全球顶级的分布式计算框架，支持众多的编程语言进行开发。而Python语言，则是Spark重点支持的方向

### PySpark
- PySpark是由Spark官方开发的Python语言第三方库
- Python开发者可以使用pip程序快速的安装PySpark并像其它三方库那样直接使用
- PySpark可提交至Spark集群进行分布式集群计算

### PySpark应用方向
- 大数据开发  
Spark（PySpark）是大数据开发中的核心技术
- 人工智能
- 数据分析

## PySpark构建执行环境
### PySpark库的安装
```
pip install pyspark
```
或使用国内代理镜像网站（清华大学源）
```
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspark
```
### 构建PySpark执行环境入口对象
- 使用PySpark库完成数据处理，首先需要构建一个执行环境入口对象
- PySpark的执行环境入口对象是：类 SparkContext 的类对象
```
# 导包
from pyspark import SparkConf, SparkContext

# 创建SparkConf类对象
conf = SparkConf().setMaster("local[*]").setAppName("test_spark_app")

# 基于SparkConf类对象创建SparkContext对象
sc = SparkContext(conf=conf)

# 打印PySpark的运行版本
print(sc.version)

# 停止SparkContext对象的运行（停止PySpark程序）
sc.stop()
```
### PySpark的编程模型
```SparkContext``` 类对象，是PySpark编程中一切功能的入口

PySpark的编程，主要分为如下三大步骤
- #### 数据输入
通过SparkContext类对象的成员方法完成数据的读取操作，读取后得到RDD类对象
- #### 数据处理计算
通过RDD类对象的成员方法完成各种数据计算的需求
- #### 数据输出
将处理完成后的RDD对象调用各种成员方法完成写出文件，将结果输出到list、元组、字典、文本文件、数据库等

## 数据输入
### RDD对象
PySpark支持多种数据的输入，在输入完成后，都会得到一个：RDD类的对象

RDD全称为：弹性分布式数据集（Resilient Distributed Datasets）

PySpark针对数据的处理，都是以RDD对象作为载体，即：
- 数据存储在RDD内
- 各类数据的计算方法，也都是RDD的成员方法
- RDD的数据计算方法，返回值依旧是RDD对象
#### PySpark的编程模型（左图）可以归纳为
准备数据到RDD -> RDD迭代计算 -> RDD导出为list、文本文件等

即：源数据 -> RDD -> 结果数据

### Python数据容器转RDD对象
#### PySpark支持通过SparkContext对象的parallelize成员方法，将：
- list
- tuple
- set
- dict
- str

转换为PySpark的RDD对象

#### 语法
```
from pyspark import SparkConf, SparkContext
conf = SparkConf().setMaster('local[*]').setAppName('data_input')
sc = SparkContext(conf=conf)

# 通过parallelize方法将Python对象加载到Spark内，成为RDD对象
rdd1 = sc.parallelize(数据容器对象)

# 如果要查看RDD里面有什么内容，需要用collect()方法
print(rdd1.collect())

sc.stop()
```
#### 注意
- 字符串会被拆分出1个个的字符，存入RDD对象
- 字典仅有key会被存入RDD对象

### 读取文件转RDD对象
PySpark也支持通过SparkContext的textFile成员方法，读取文本文件，来构建出RDD对象
#### 语法
```
from pyspark import SparkConf, SparkContext
conf = SparkConf().setMaster('local[*]').setAppName('data_input')
sc = SparkContext(conf=conf)

# 用textFile方法，读取文件数据加载到Spark内，成为RDD对象
rdd2 = sc.textFile('文件路径')
print(rdd2.collect())

sc.stop()
```

## 数据处理计算
*注意事项*  
*在进行数据计算时，需要给PySpark指定python解释器路径,否则会报错*
```
import os
os.environ["PYSPARK_PYTHON"] = "路径/python.exe"
```
### map方法
PySpark的数据计算，都是基于RDD对象来进行的，依赖RDD对象内置丰富的成员方法（算子）
#### map算子功能
- 接受一个处理函数，可用lambda表达式快速编写
- 对RDD内的元素逐个处理，并返回一个新的RDD
#### 语法
```
rdd.map(func)
# func:  f:(T) -> U
# f: 表示这是一个函数（方法）
# (T) -> U 表示的是方法的定义：
        # ()表示传入参数，(T)表示传入1个参数，()表示没有传入参数
        # T和U是泛型的代称，在这里表示任意类型
        # -> U 表示返回值
# (T) -> U 表示：这是一个方法，这个方法接受一个参数传入，传入参数类型不限，返回一个返回值，返回值类型不限
# (A) -> A 表示：这是一个方法，这个方法接受一个参数传入，传入参数类型不限，返回一个返回值，返回值和传入参数类型一致
```
#### 传参方式
- 定义方法，传入其方法名
- 使用lambda匿名函数
如果方法体可以一行写完，就用lambda，如果方法体复杂，就直接定义方法

#### 链式调用
对于返回值是新RDD的算子，可以通过链式调用的方式多次调用算子


### flatMap方法
#### flatMap算子功能
##### 对rdd执行map操作，然后进行解除嵌套操作
#### 示例代码
```
rdd = sc.parallelize(['C pointer STL','Java method interface','Python pass elif'])

print(rdd.map(lambda x: x.split()).collect())
#  输出 [['C', 'pointer', 'STL'], ['Java', 'method', 'interface'], ['Python', 'pass', 'elif']]

print(rdd.flatMap(lambda x: x.split()).collect())
#  输出 ['C', 'pointer', 'STL', 'Java', 'method', 'interface', 'Python', 'pass', 'elif']
```
### reduceByKey方法
#### reduceByKey算子功能
- 接受一个处理函数，对数据进行两两计算
- 针对KV型RDD，自动按照key分组，然后根据你提供的聚合逻辑，完成组内数据(value)的聚合操作
- ```reduceByKey``` 中的聚合逻辑
  - 例如，[1,2,3,4,5] 的聚合函数是 ```lambda a,b:a+b```

#### 语法
```
rdd.reduceByKey(func)
# func: (V,V) -> V
# 接收2个传入参数（类型要一致），返回一个返回值，类型和传入要求一致
```
#### 注意
reduceByKey中接收的函数，只负责聚合，不进行分组，分组是自动由 by key进行的


### filter方法
过滤想要的数据进行保留
#### filter算子功能
- 接受一个处理函数，可用lambda快速编写
- 函数对RDD数据逐个处理，得到True的保留至返回值的RDD中

#### 语法
```
rdd.filter(func)
# func: (T) -> bool 传入1个参数（任意类型），返回值必须是True or False
```
返回是True的数据被保留，False的数据被丢弃


### distinct方法
#### distinct算子功能
对RDD数据进行去重，返回新RDD

#### 语法
```
rdd.distinct()
```
##### 无需传参

### sortBy方法
#### sortBy算子功能
基于指定的排序依据，对RDD数据进行排序
#### 语法
```
rdd.sortBy(func, ascending=False, numPartitions=1)
#func: (T) -> U:告知按照rdd中的哪个数据进行排序，比如 lambda x: x[1]表示按照rdd中的第2列元素进行排序
#ascending True升序，False降序
#numPartitions 在分布式中用多少分区排序
```
#### 注意
- 接收一个处理函数，可用lambda快速编写
- 函数表示用来决定排序的依据
- 可以控制升序或降序
- 全局排序需要设置分区数为1


## 数据输出
### 输出为python对象
#### collect方法
##### collect算子功能
将RDD各个分区内的数据，统一收集到Driver中，形成一个List对象
##### 语法
```
rdd.collect()
```
##### 返回类型
list

#### reduce方法
##### reduce算子功能
对RDD数据集按照传入的逻辑进行聚合
##### 语法
```
rdd.reduce(func)
# func: (T, T) -> T
# 2个传入参数，1个返回值，返回值和参数要求类型一致
```
##### 示例代码
```
rdd = sc.parallelize(range(1,10))
# 将rdd的数据进行累加求和
print(rdd.reduce(lambda a, b: a + b))
```
返回值等同于计算函数的返回值

#### take方法
##### take算子功能
取RDD的前N个元素，组合成list返回
##### 示例代码
```
sc.parallelize([3,2,1,4,5,6]).take(3)
# 返回[3,2,1]
```

#### count方法
##### count算子功能
统计RDD有多少条数据，返回值是一个数字
##### 示例代码
```
sc.parallelize([3,2,1,4,5,6]).count()
# 返回6
```
### 输出到文件
#### saveAsTextFile方法
##### saveAsTextFile算子功能
- 将RDD的数据写入文本文件中
- 支持本地写出，hdfs等文件系统
- 输出的结果是一个文件夹
- 默认有几个分区就输出多少个结果文件
##### 示例代码
```
rdd = sc.parallelize([3,2,1,4,5,6])
rdd.saveAsTextFile('输出路径')
```
##### 注意事项
调用保存文件的算子，需要配置Hadoop依赖
- 下载Hadoop安装包
http://archive.apache.org/dist/hadoop/common/hadoop-3.0.0/hadoop-3.0.0.tar.gz
- 解压到电脑任意位置
- 在Python代码中使用os模块配置：```os.environ[‘HADOOP_HOME’] = ‘HADOOP解压文件夹路径’```
- 下载 ```winutils.exe```，并放入Hadoop解压文件夹的bin目录内
https://raw.githubusercontent.com/steveloughran/winutils/master/hadoop-3.0.0/bin/winutils.exe
- 下载 ```hadoop.dll```，并放入 ```C:/Windows/System32``` 文件夹内
https://raw.githubusercontent.com/steveloughran/winutils/master/hadoop-3.0.0/bin/hadoop.dll

##### 修改rdd分区为1个
- 方法1
```SparkConf``` 对象设置 ```conf.set("spark.default.parallelism", "1")```
- 方法2
创建RDD的时候，```sc.parallelize``` 方法传入 ```numSlices``` 参数为1


# Python高阶技巧
## 闭包
### 闭包解决的问题
- 定义全局变量在命名空间上不够干净、整洁
- 全局变量有被修改的风险
### 闭包定义
- 定义双层嵌套函数，内层函数可以访问外层函数的变量
- 将内存函数作为外层函数的返回，此内层函数就是闭包函数

### 闭包优点和缺点
#### 优点
- 不定义全局变量，也可以让函数持续访问和修改一个外部变量
- 闭包函数引用的外部变量，是外层函数的内部变量。作用域封闭，不容易被误操作修改
#### 缺点
- 由于内部函数持续引用外部函数的值，所以会导致这一部分内存空间不被释放，一直占用内存

### nonlocal关键字
在闭包函数（内部函数中）想要修改外部函数的变量值，需要用 ```nonlocal``` 声明这个外部变量

### 示例代码
```
# 使用闭包实现ATM小案例
def account_create(account_name, account_balance):
    def inner(money,deposit=True):
        nonlocal account_balance
        behaviour = ''
        if deposit:
            account_balance += money
            behaviour = 'save money'
        else:
            account_balance -= money
            behaviour = 'draw money'

        print(f'{account_name} {behaviour}: {money},now account_balance is {account_balance}')
    return inner
```

## 装饰器
装饰器其实也是一种闭包， 其功能就是在不破坏目标函数原有的代码和功能的前提下，为目标函数增加新功能
### 装饰器定义
- 装饰器就是使用创建一个闭包函数，在闭包函数内调用目标函数
- 可以达到不改动目标函数的同时，增加额外的功能

### 装饰器的一般写法（闭包写法）
#### 定义一个闭包函数， 在闭包函数内部：
- 执行目标函数
- 并完成功能的添加
#### 示例代码
```
def sleep():
    import time,random
    print('sleeping')
    time.sleep(random.randint(1,3))

def decorator(func):
    def warp():
        print('go to bed')
        func()
        print('get up')
    return warp

decorator(sleep)
```

### 装饰器的语法糖写法
- 使用 ```@outer```
- 定义在目标函数 ```sleep``` 之上

#### 示例代码
```
def decorator(func):
    def warp():
        print('go to bed')
        func()
        print('get up')
    return warp

@decorator
def sleep():
    import time,random
    print('sleeping')
    time.sleep(random.randint(1,3))

sleep()
```

## 设计模式
### 定义
- 设计模式是一种编程套路，可以极大的方便程序的开发
- 最常见、最经典的设计模式，就是面向对象
- 除了面向对象外，在编程中也有很多既定的套路可以方便开发
  - 单例、工厂模式
  - 建造者、责任链、状态、备忘录、解释器、访问者、观察者、中介、模板、代理模式等等模式

### 单例模式--Singleton Pattern
#### 定义
- 单例模式就是对一个类，只获取其唯一的类实例对象，持续复用它
- 保证一个类只有一个实例,并提供一个访问它的全局访问点
#### 适用场景
当一个类只能有一个实例，而用户可以从一个众所周知的访问点访问它时
#### 优点
- 节省内存
- 节省创建对象的开销
#### python实现单例模式
在一个文件中定义类，并实例化为对象
```
class Singleton:
    pass

singleton = Singleton()
```
在另一个文件中导入对象
```
from singleton_class import singleton

class1 = singleton
class2 = singleton
```
### 工厂模式
#### 定义
- 当需要大量创建一个类的实例的时候，可以使用工厂模式
- 即，从原生的使用类的构造去创建对象的形式迁移到，基于工厂提供的方法去创建对象的形式

#### 优点
- 大批量创建对象的时候有统一的入口，易于代码维护
- 当发生修改，仅修改工厂类的创建方法即可
- 符合现实世界的模式，即由工厂来制作产品（对象）
#### python实现工厂模式
```
class Animal:
    def __init__(self):
        print('Animal is created!')

class Dog(Animal):
    def __init__(self):
        print('Dog is created!')

class Cat(Animal):
    def __init__(self):
        print('Cat is created!')

class Pig(Animal):
    def __init__(self):
        print('Pig is created')

class Factory():
    @staticmethod
    def create_animal(animal):
        if animal == 'dog':
            return Dog()
        elif animal == 'cat':
            return Cat()
        elif animal == 'pig':
            return Pig()
        else:
            print('Invalid animal')

dag = Factory.create_animal('dog')
cat = Factory.create_animal('cat')
pig = Factory.create_animal('pig')
duck = Factory.create_animal('duck')
```
## 多线程
### 进程、线程和并行执行
现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统
#### 进程
就是一个程序，运行在系统之上，那么便称之这个程序为一个运行进程，并分配进程ID方便系统管理。
#### 线程
线程是归属于进程的，一个进程可以开启多个线程，执行不同的工作，是进程的实际工作最小单位
#### 进程和线程的关系和区别
- 进程就好比一家公司，是操作系统对程序进行运行管理的单位
- 线程就好比公司的员工，进程可以有多个线程（员工），是进程实际的工作者
- 操作系统中可以运行多个进程，即多任务运行
- 一个进程内可以运行多个线程，即多线程运行

#### 注意
- 进程之间是内存隔离的， 即不同的进程拥有各自的内存空间。 这就类似于不同的公司拥有不同的办公场所
- 线程之间是内存共享的，线程是属于进程的，一个进程内的多个线程之间是共享这个进程所拥有的内存空间的。这就好比，公司员工之间是共享公司的办公场所

#### 并行执行
- 并行执行的意思指的是同一时间做不同的工作
- 进程之间就是并行执行的，操作系统可以同时运行好多程序，这些程序都是在并行执行
- 除了进程外，线程其实也是可以并行执行的
  - 一个Python程序完全可以做到：  
    - 一个线程在输出：你好  
    - 一个线程在输出：Hello

- 多个进程同时在运行，即不同的程序同时运行，称之为：多任务并行执行
- 一个进程内的多个线程同时在运行，即一个程序在同一时间做两件乃至多件不同的事情， 就称之为：多线程并行执行

### 多线程编程
绝大多数编程语言，都允许多线程编程，Pyhton也不例外。Python的多线程可以通过threading模块来实现
#### threading模块
##### 语法
```
import threading
thread_obj = threading.Thread([group[,target[,name[,args[,kwargs]]]]])
```
- group  
暂时无用，未来功能的预留参数
- target  
执行的目标任务名，即函数名
- args  
以元组的方式给执行任务传参  
例如 
```args=("我要唱歌 哈哈哈", )```
- kwargs
以字典的方式给执行任务传参
例如
```kwargs={"msg": "我在跳舞 啦啦啦"}```
- name
线程名，一般不用设置

##### 使用
创建线程对象
```
thread_obj = threading.Thread(target=func)  
```
启动线程执行
```
thread_obj.start() 
```


## 网络编程
### 网络编程相关概念
```Socket```
#### 定义
socket (简称 套接字) 是进程之间通信一个工具，好比现实生活中的插座，所有的家用电器要想工作都是基于插座进行，进程之间想要进行网络通信需要socket
#### 作用
Socket负责进程之间的网络数据传输，好比数据的搬运工
#### 客户端和服务端
2个进程之间通过Socket进行相互通讯，就必须有服务端和客户端
- Socket服务端  
等待其它进程的连接、可接受发来的消息、可以回复消息
- Socket客户端  
主动连接服务端、可以发送消息、可以接收回复

### 服务端开发
#### Socket服务端编程
主要分为如下几个步骤：
创建socket对象
```
import socket
socket_server = socket.socket()
```
绑定socket_server到指定IP和地址
```
socket_server.bind(host,port)
```
服务端开始监听端口
```
socket_server.listen(backlog)
```
- backlog为int证书，表示允许的连接数量，超出的会等待，如果不填，会自动设置一个合理值
接收客户端连接，获得连接对象
```
conn, address = socket_server.accept()
```
- accept方法返回的是二元元组(链接对象， 客户端地址信息)
- 可以通过 变量1, 变量2 = socket_server.accept()的形式，直接接受二元元组内的两个元素
- accept()方法，是阻塞的方法，等待客户端的链接，如果没有链接，就卡在这一行不向下执行了
客户端连接后，通过recv方法，接收客户端发送的消息
```
while True:
    # 接受客户端信息，要使用客户端和服务端的本次链接对象，而非socket_server对象
    data: str = conn.recv(1024).decode("UTF-8")
    # recv接受的参数是缓冲区大小，一般给1024即可
    # recv方法的返回值是一个字节数组也就是bytes对象，不是字符串，可以通过decode方法通过UTF-8编码，将字节数组转换为字符串对象
    print(f"客户端发来的消息是：{data}")
```
通过conn（客户端当次连接对象），调用send方法可以回复消息
```
    # 发送回复消息
    msg = input("请输入你要和客户端回复的消息：")
    if msg == 'exit':
        break
    conn.send(msg.encode("UTF-8"))
```
conn（客户端当次连接对象）和socket_server对象调用close方法，关闭连接
```
conn.close()
socket_server.close()
```

### 客户端开发
#### Socket客户端编程
主要分为如下几个步骤：
创建socket对象
```
import socket
socket_client = socket.socket()
```
连接到服务端
```
socket_client.connect(host,port)
```
发送消息
```
while True:
    # 发送消息
    msg = input("请输入要给服务端发送的消息：")
    if msg == 'exit':
        break
    socket_client.send(msg.encode("UTF-8"))
```
接收返回消息
```
# 接收返回消息
recv_data = socket_client.recv(1024)

# 1024是缓冲区的大小，一般1024即可。 同样recv方法是阻塞的
print(f"服务端回复的消息是：{recv_data.decode('UTF-8')}")
```
##### 关闭链接
```
socket_client.close()
```

## 正则表达式
### 概念
- 正则表达式，又称规则表达式（Regular Expression），是使用单个字符串来描述、匹配某个句法规则的字符串，常被用来检索、替换那些符合某个模式（规则）的文本
- 简单来说，正则表达式就是使用：字符串定义规则，并通过规则去验证字符串是否匹配
- 比如，验证一个字符串是否是符合条件的电子邮箱地址，只需要配置好正则规则，即可匹配任意邮箱
- 比如通过正则规则： ```(^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$)```  即可匹配一个字符串是否是标准邮箱格式
- 但如果不使用正则，使用```if else```来对字符串做判断就非常困难了

### 基础匹配
Python正则表达式，使用re模块，并基于re模块中三个基础方法来做正则匹配。分别是：match、search、findall
#### match(匹配规则， 被匹配字符串)
##### 功能
从被匹配字符串开头进行匹配， 匹配成功返回匹配对象（包含匹配的信息），匹配不成功返回空
##### 示例代码
```
result = re.match("python", sentence)
print(result)
print(result.span())
print(result.group())
```
#### search(匹配规则， 被匹配字符串)
##### 功能
- 搜索整个字符串，找出匹配的。从前向后，找到第一个后，就停止，不会继续向后
- 整个字符串都找不到，返回None
##### 示例代码
```
result = re.search('java',sentence)
print(result)
print(result.span())
print(result.group())
```
#### findall(匹配规则， 被匹配字符串)
##### 功能
- 匹配整个字符串，找出全部匹配项
- 找不到返回空list: []

#### finditer(匹配规则， 被匹配字符串)
##### 功能
- 匹配整个字符串，找出全部匹配项
- 把结果封装到一个迭代器中
##### 示例代码
```
result = re.finditer('java',sentence)
for e in result:
    print(e.group())
```

### 预加载正则表达式
#### 功能
在匹配前先定义好正则表达式格式
#### 语法
```
re.compile()
```
#### 示例代码
```
pattern = re.compile('\d+')
result = pattern.findall('My phone number is 123456, my friend\'s is 654321')
print(result)
```

### 元字符匹配
#### 单字符匹配
##### .
匹配任意1个字符（除了\n），```\.``` 匹配点本身
##### []
匹配 ```[]``` 中列举的字符
例如找到全部英文字母 ```[a-zA-Z]```
##### \d
匹配数字，即0-9
##### \D
匹配非数字
##### \s
匹配空白，即空格和 ```Tab``` 键
##### \S
匹配非空白
##### \w
匹配单词字符，即 ```a-z,A-Z,0-9,_```
##### \W
匹配非单词字符

#### 数量匹配
##### *
匹配前一个规则的字符出现0至无数次
##### +
匹配前一个规则的字符出现1至无数次
##### ?
匹配前一个规则的字符出现0次或1次
##### {m}
匹配前一个规则的字符出现m次
##### {m,}
匹配前一个规则的字符出现最少m次
##### {m,n}
匹配前一个规则的字符出现m到n次

#### 边界匹配
##### ^
匹配字符串开头
##### $
匹配字符串结尾
##### \b
匹配一个单词的边界
##### \B
匹配非单词边界

#### 分组匹配
##### |
匹配左右任意一个表达式
##### ()
将括号中的字符作为一个分组

#### 字符串的r标记表示，字符串内转移字符无效，作为普通字符使用

## 递归
### 递归概念
- 递归在编程中是一种非常重要的算法
- 递归： 即方法（函数）自己调用自己的一种特殊编程写法  
如：
```
def func():
   if ...:
       func()

   return
```
- 函数调用自己，即称之为递归调用

### 递归注意事项
- 注意退出的条件，否则容易变成无限递归
- 注意返回值的传递，确保从最内层，层层传递到最外层

### os模块的3个方法
```
os.listdir
```
列出指定目录下的内容
```
os.path.isdir
```
判断给定路径是否是文件夹，是返回True，否返回False
```
os.path.exists
```
判断给定路径是否存在，存在返回True，否则返回False
