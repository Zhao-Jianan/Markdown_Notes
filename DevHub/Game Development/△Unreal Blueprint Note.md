# 蓝图
Debug时F9可以设置节点断点，然后点击模拟进行调试
断点节点是即将执行还没有执行的地方

## UE万物皆是Actor
UE4获取Actor的方式
1. 根据Class获取
2. 已知根组件获取子节点
3. 通过标签查找Actor（不能连Tick，不能频繁调用，内存开销较大）

## 蓝图通信
### 通信模式
1. 获取引用->调用函数
2. 注册事件->回调函数
### 具体通信方式
1. 变量公开
2. 动态关卡中查找和获取Actor或具体类型（根据类型获取或根据标签获取），例如Get All Actors Of Class
3. 蓝图接口
4. 事件分发器

## MVC
### Model 模型（数据层）PlayerState
哪些逻辑写在PlayerState里？
- PlayerState只为Player存在,不为NPC存在,UPlayer和PlayerState对应
- PlayerState表示的是游玩数据，Controller控制需要的一些临时数据不应该交由playerState管
- 玩家在切换关卡的时候，PlayerState会被释放，playerstate表示的是当前关卡玩家的数据信息
### View 视图（显示层）Pawn或Character
哪些逻辑写在Pawn里？
UE4通过Actor中派生出了Pawn类型，Pawn的功能扩展：
1. 可被Controller控制
2. PhysicsCollision表示
3. MovementInput的基本响应

一个pawn在游戏世界中需要表达自身的存在（PhysicsCollision）,可以移动
（MovementInput），然后需要响应输入和处理逻辑（Controller）

Actor是用来表示3D游戏对象,Pawn继承于Actor,Pawn只是逻辑的载体，具体如何行走还是要靠外部的Controller机制来处理，pawn形容可被玩家操控的能力

总结：当某个事件发生之后，在游戏屏幕上能看到的反馈和更新逻辑都应该写在Pawn里
### Controller 控制（控制层）PlayerController或AIController
哪些逻辑写在Controller里？

Controller是游戏业务逻辑最重要的载体
1. 从概念上分析，Pawn表示的是物体具有能动的概念，controller代表是动到哪里的概念，重点在于方向或位置
2. 从功能上分析，如果某一套逻辑只属于某一类的Pawn，那么逻辑在Pawn中执行，没有任何问题。而如果一个逻辑可以应用于多个Pawn，那么就该放到Controller里
3. 通过存在性分析，Controller的生命周期要比Pawn更长，销毁Pawn代表pawn就不存在了，就算重新实例化一个Pawn对象，之前自身所保存的数据也会并重置

## 正交
非常重要的编程思维，两个元素没有相关联的因素，即两个元素正交，一个元素变化，不会影响另一个元素

在实现一个功能时要考虑有哪些正交因素，互相正交的因素应该分离开

例如：制作小地图时
地图图片、地图上的图标、内部逻辑是三个互相正交的因素，应该分开实现

## 反射
蓝图支持很弱的反射，可通过C++加强
C++不支持反射，但是虚幻4中的C++支持一部分
### 反射支持
- 根据名字获得类----------C++支持

- 根据名字调用函数--------蓝图支持
例如：Set Timer by Function Name节点
- 根据名字获得成员变量----C++支持
- 根据名字获得组件--------蓝图支持
Get Components By Class和Get Component by Class两个节点

## 蓝图的底层逻辑
### 虚拟机
VM----Virtual Machine
可以运行程序的程序
VMWare是特殊的虚拟机，是可以运行操作系统的虚拟机

### 编译与解释
- 解释(interpret)：把代码直接翻译成机器指令来运行   //注意英文单词，不是explain
编译与解释的区别：
- 编译：先做一桌子菜再吃
- 解释：火锅，边涮边吃

**Java、Python、Lua等大多数语言都有虚拟机，编译+解释**
在程序编译时先生成一个Class（不是面向对象编程中的类），Class会根据不同的操作系统和硬件会生成相应的代码，优点是开发效率高，缺点是运行速度慢

**C/C++没有虚拟机，只编译**
C/C++是在程序写好后编译，编译成功后直接转为机器代码，不同的操作系统和硬件，需要不同的代码，同一个程序无法在不同操作系统上运行，优点是运行速度快，缺点是开发效率低

C语言编译流程：
预处理（Preprocess）-->编译（Compile）-->汇编（Assemble）-->链接（Link）

#### 蓝图，编译+解释
蓝图有虚拟机
蓝图中的Compile编译本质上就是把蓝图代码转成虚拟机代码，Play的时候就直接在虚拟机上运行

特殊情况：Nativization
Nativization即把蓝图变为C++
Nativization情况下不是编译+解释，执行过程是编译后直接转为机器代码

把蓝图变为C++的方法：
在Project Settings-->Packaging-->Blueprints中，找到Blueprint Nativization Method选项，Disabled不转换，Inclusive所有的蓝图类都转换，Exclusive加入列表中的蓝图类进行转换，设置好后打包，蓝图类会转换成C++类，注意关卡蓝图无法转换成C++

打包后会在源文件夹Unreal Projects\工程名\Intermediate\Plugins\NativizedAssets\Windows\Game\Source\NativizedAssets\Private中找到转换后的C++类

一些关键运算因为在蓝图中计算比较慢，可能会成为程序运行的瓶颈，就需要Nativization
### 控制流
control flow,flow of control
语句/指令的执行顺序 
- 顺序--Sequence
- 分支--Branch
- 循环--Loop
### 系统开销
蓝图是调用C++代码，开销与纯C++相比，多的是传入参数和传出参数的系统消耗
### 时序问题
有依赖关系的两段代码，执行时间不确定，所引起的问题
例如：两个类互相引用或UI引用蓝图类

#### 解决方法
1. 加Delay
2. 明确调用顺序

#### 游戏主循环
- 开始游戏
- 循环执行  接收输入-->处理游戏逻辑-->渲染-->Sleep（用来稳定帧率）
- 循环执行的流程执行一次即为一帧


#### 处理游戏逻辑的循环流程
还有未处理的Actor吗-->调用这个Actor上的Tick事件-->标记Actor在本帧处理过了

因为对于未处理的Actor，处理的顺序是引擎自己判断的，所以可能会出现时序问题

### 进程和线程
进程就是一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间

线程是进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据

大部分程序都是单线程的，单线程程序只能利用多核CPU中的一个核

#### 单线程改多线程的阻力
1. 应用场景不一定适合：可能瓶颈不在CPU，而在比如显卡等其他硬件
2. 对开发人员要求高：要正确处理数据之间的依赖关系
3. 多线程本身有额外开销
#### UE4引擎的线程设计
1. 游戏主循环是单线程的
2. 设计思想上，模拟了并行，不同的Actor可以互不影响，但是实际的游戏处理逻辑是逐个调用Actor上的Tick事件，所以本质上是单线程的，所以不会有真正的同时
3. 编译、构建、运行时与显卡的交互，可能是多线程的
4. 用户可以自己创建多线程，但是蓝图并未提供多线程接口，可以使用C++或插件


## 对象池/缓存池/孵化池
同一个概念的不同叫法，非常重要
游戏中频繁创建和销毁的对象，会导致大量的内存消耗，产生GC(Garbage Collection)，并产生内存碎片，最后直接卡死
对象池是定义一个固定大小的缓冲区，缓存哪些可以重复被利用的资源，比如子弹或敌人等
当对象需要被销毁时，不进行销毁，而是将其设置为非激活，存入缓存池。当需要再次创建时，从缓存池中获取

### 对象池使用方法：
- 第1步：创建Actor蓝图，创建空的数组用来存放需要生成的对象，数组变量对象选择需要生成的对象
- 第2步：创建需要的功能函数，方便调用
  - 对象状态切换函数-------设置隐藏、碰撞、Tick的激活和关闭
  - 预加载函数-------------游戏开始时运行，生成物体，并把所有生成的物体设为非激活，存入数组
  - 生成函数---------------场景中需要生成对象时，生成对象的Actor调用此函数，如玩家角色发出子弹时，玩家角色调用此函数，功能是如果对象池中对象足够，就从对象池中提取对象，供Actor生成；如果对象池中对象不够，就生成物体
  - 回收函数---------------当生成的对象需要销毁时，对其进行回收，如果对象池中足够存储，就存入对象池中，否则就直接销毁对象

## 数据持久化管理
游戏的存档和读档一般在开发中要写一个SaveGameManager的Actor类型的蓝图来管理存档读档的操作

需要多个相同子类时，就需要创建一个Manager来管理

玩家信息、场景信息、配置信息等分开存储，不然读档效率很低

存档数据最好用结构体来存放，再将结构体作为Save Game的变量，这样便于管理，还可以将结构体存为数组，方便存储多个游戏档案数据

### 数据在开发中会存储在
1. 临时内存
2. 文件
3. 数据库

### 文件格式
1. 序列化和反序列化SaveGame
2. XML格式
3. JSON格式
4. CSV、Excel等表格文件

### Save Game Manager
要实现游戏存档的存档、读档、删、改、查功能
#### 变量
##### Save Map Configs
类型是字符串到Save Game Base类的映射，用来存储所有的存档数据信息，初始就把所有存档类都添加到默认值，在游戏运行开始时把所有游戏中需要持久化的数据都读取，属于存储功能
##### Save Game Map
类型是字符串到Save Game Base对象的映射，用来缓存所有已加载过的Save Game数据，初始化时为空，当加载过一个Save Game对象后，把Save Game对象添加到Save Game Map。可以通过Save Game Map获取某一个存档数据是否已经加载过，可以在任何地方和时机获取某一个存档数据
#### 函数
##### 读档功能
###### Load All Save Games
供外部调用的函数

读取所有的Save Games，用来供外部调用读取游戏，因为不同的Save Game存储的是不同的游戏数据，需要读取完所有的数据才能加载，实现的实际上就是读档功能

无输入接口

无输出接口

函数内容通过遍历Save Map Configs的key值，每一个key值都要调用内部函数Load Game Single

###### Load Game Single
内部函数

读取单个游戏Save Game的数据

输入接口为字符串Save key

无输出接口

函数内容先用Does Save Game Exit判断传入的Save key为插槽名的游戏存档插槽是否存在

-->如果不存在，就从Save Map Configs查找Save key对应的Save Game类，用Create Save Game Object创建相应的Save Game对象，触发Save Game对象的On Initialize回调函数，并添加到Save Game Map数组中缓存

-->如果存在，用Load Game from Slot读取，类型转换到Save Game Base，调用On Load回调函数读取对应的Save Game对象中的游戏数据，并添加到Save Game Map数组中缓存
##### 存档功能
###### Save All Games
供外部调用的函数
把所有需要存储的数据存到对应的Save Games，用来供外部调用存储游戏
无输入接口
无输出接口
函数内容通过遍历Save Game Map的key值，每一个key值都要调用内部函数Save Game Single
###### Save Game Single
内部函数
存储单个游戏Save Game的数据
输入接口为字符串Save key
无输出接口
函数内容首先根据输入的Save key从Save Game Map中查找
-->如果不存在，无执行逻辑
-->如果存在，调用On Save回调函数把要存储的游戏数据缓存到对应的Save Game对象中，然后用Save Game to Slot节点把Save Game对象中的游戏数据存到存档插槽中
##### 删档功能
###### Delete All Games
供外部调用的函数
无输入接口
无输出接口
需要把所有的Save Games删除，才能实现删除存档。如果是存档系统是多存档的话，需要实现移除所有Save Games中所有数据的对应项，这个函数是物理删除存档
###### Delete Save Game
供外部调用的函数
输入接口为字符串Save key
无输出接口
通过传入的字符串Delete Key,从Save Game Map中查询，如果存在，就从Save Game Map中移除
这个删档功能并不会实际删除存档，只会移除缓存，一般是初始化时调用
##### 查询功能
###### Get Save Game
供外部调用的函数
输入接口为字符串Get key
输出接口为Save Game Base对象类型
通过传入的字符串Get key,,从Save Game Map中查询，如果存在，就返回查询到的Save Game Base对象
##### Save Game Base
创建一个Save Game类型的蓝图，作为存档类父类，创建On Load、On Save、On Initialize三个函数供回调，也可以根据需要创建On Delete等

##### On Load
读档的回调函数，数据读档时调用一次，子类在On Load中要把成员变量(存档数据)赋值给游戏中对应的对象
##### On Save
存档的回调函数，数据存档之前调用一次，子类在On Save中要完成对成员变量即存档数据的赋值
##### On Initialize
初始化的回调函数，第一次初始化存档类对象时调用一次，子类在On Initialize中要完成对成员变量即存档数据的初始化



# 蓝图相关资产
## ULevel/关卡
关卡是Actor的集合，是World里的板块，对应umap
## UWorld/世界
世界是Level的集合，运行时的真正的Actor集合，是关卡的真正单位，是场景的真正表示对象

注意要理解世界和关卡的区别，世界才是游戏上说的第一关第二关的关卡，虚幻里的关卡只是世界里的一部分

世界可以有多个，视口里是游戏世界，资产预览里是预览世界Preview World，网络游戏有服务端和各客户端的世界，编辑器视口里是Editor World，运行后是PIE World

# Blueprint/蓝图资产
## Blueprint Class/蓝图类
在Content Browser中右键创建BluePrint Class,可以创建常见的7种蓝图，或在所有类中查找创建其他类型的蓝图
## 类的父子关系
- 继承：子类从父类获取的变量和函数
- 扩展：子类可以实现父类没有的功能（添加变量和函数）
- 重写：子类对父类提供的功能进行修改（父类的函数被子类重写）

子类可以被当做父类使用，如果一个函数输入是一个类，那么这个类的所有子类都可以作为输入

获取的时候子类会自动转换为父类，Cast To是把父类转换为子类

Object是可以传递任意类型可以转换成任意类型的根父类

| 类别                | 存在于        | 是否复制              | 进程内个数                         |
|:--------------------|:-------------|:----------------------|:----------------------------------|
| GameInstance        | 进程          | 服务器和客户端       | 否                                 | 1                                  |
| GameMode            | 关卡          | 服务器               | N/A                                | 1                                  |
| GameState           | 关卡          | 服务器和客户端       | 是                                 | 1                                  |
| PlayerController    | 关卡          | 服务器和客户端       | 是                                 | 服务器同玩家个数，客户端仅1个    |
| PlayerState         | 关卡          | 服务器和客户端       | 是                                 | 同玩家个数                        |
| Pawn/Character      | 逻辑控制      | 服务器和客户端       | 是                                 | 同玩家个数                        |


## 网游/联机游戏各类都在哪里
Server-->GameMode
Client-->HUD、UMG、PlayerController
参与网络复制的类-->Game State、所有玩家的Player State、所有玩家的Pawn

### 什么逻辑写在哪里：
| 类别                                      | 功能、能力                             |
|:------------------------------------------|:--------------------------------------|
| Component                                 | 功能、能力                             |
| Actor                                     | 个体本身的逻辑                         |
| APawn - APlayerController - APlayerState  | 主角肉体 - 主角灵魂 - 主角状态         |
| APawn - AAIController - APlayerState      | AI肉体 - AI灵魂 - AI状态               |
| AAIController - BehaviorTree - Blackboard | AI灵魂 - 行为树 - 数据                 |
| AGameMode - AGameState                    | 游戏规则 - 游戏状态                   |
| UGameInstance - USaveGame                 | 全局游戏实例 - 游戏存档               |
| USubsystem                                | 游戏逻辑组件                           |


## 常见类
- ▲Actor
- Pawn
- Character
- Game Mode Base
## 所有类
### UObject/对象
对象模型，根基类

特点
1. 万物可追踪（类型转换）
2. 属性接口的通用性（通用接口：PrintString toString GetName Equals Clone）
3. 内存分配释放
4. 序列化（把一个数据缓存到本地，把数据持久化，比如游戏存档）
5. 编辑器可见
#### AActor/演员
可以被放在关卡中的类，无法被控制，没有具体特征，是UE中最重要的Object

Actor的深入理解
1. 组成世界的单位个体
2. 可互相嵌套
3. 组件的容器
4. Spawn & Tick
5. 网络通信的通道
6. 派生出各种不同职责的Actor

不是所有的Actor都看得见

对Object的扩展功能
1. Replication网络复制（多人游戏中同步）
2. Spawn Destory产生和死亡
3. Tick心跳，保持更新
4. 相互嵌套的功能
Actor默认不带变换组件，不存储变换数据，变换功能由DefaultSceneRoot组件提供
###### Replication/网络复制
- Replicates---------------------复制，勾选后，Actor的数据可以进行网络复制
- Net Cull Distance Squared------网络剔除距离平方，与相关性有关的一个参数，因为是比较距离来确定相关性，而计算距离的勾股定理需要开方，计算量大且不必要，于是仅比较距离平方

游戏场景的规模可能非常大，在特定时刻某个玩家只能看到关卡中的一小部分Actor。场景中的其他大多数Actor都不会被看到和听到， 对玩家也不会产生显著的影响。被服务器认为可见或能够影响客户端的Actor组会被视为该客户端的相关Actor组。虚幻引擎的网络代码中包含一处重要的带宽优化：服务器只会让客户端知道其相关组内的Actor
- Net Priority-------------------网络优先级，数字越大优先级越高，分配的带宽越多，更新频度越高，唯一影响优先顺序的就是它们的比值；所以无法通过提高所有优先级的数值来增加虚幻引擎的网络性能
性能调整中分配的NetPriority默认值：
Actor = 1.0
Matinee = 2.7
Pawn = 3.0
PlayerController = 3.0

##### ALevelScriptActor/关卡蓝图
关卡蓝图是一个特殊的默认脚本Actor:ALevelScriptActor
正经项目大部分情况下都不适合用，因为无法跨关卡使用
适合做Demo
适合一些关卡本身强相关的逻辑


##### HUD
HUD是一种“平头显示信息”，或者说是二维的屏幕显示信息,在很多游戏中都很常见
例如生命值、弹药量、枪支十字准线等
每个PlayerController一般都具有一些这样的信息
HUD是用来进行简单UI绘制的入口，一般在游戏开发中均更换为UMG为用户界面开发主要手段

##### APawn
可以被控制器控制的Actor，Pawn是由玩家控制的所有的Actor的基础类型，是玩家在游戏世界场景中的物理代表

一个Pawn决定了玩家的实体显示效果，决定了如何与场景其他物体产生碰撞等物理交互，可以表示玩家在世界的具体方位、角度等

Pawn的深入理解：
1. 可被控制
2. 逻辑足够复杂MVC
3. 肉体，在Pawn里只实现肉体的功能，不能把玩家所有功能全放到Pawn里
4. 人形角色

对Actor的扩展功能
1. 可被Controller 控制
2. PhysicsCollision表示
3. MovementImput响应

只有继承在Pawn的对象才能成为默认玩家
###### DefaultPawn/默认Pawn
自己创建的Pawn都是默认Pawn，只包含DefaultSceneRoot组件，需要自己添加功能
###### ACharacter/角色
人形Pawn，包含骨骼网格体组件、箭头组件、移动组件，Character目的是表示当前处于站立的玩家，可以在世界中行走、奔跑、跳跃、游泳、飞行等,是可以行动的Pawn
##### Pawn
- Auto Possess Player------------自动支配角色，控制游戏开始时哪个玩家自动控制这个蓝图角色，如果没有PlayerController，可以选择Player0，这样游戏开始时玩家自动控制这个蓝图角色
##### SkeletalMeshComponent/骨骼网格体
便于实现骨架的相关动画的播放和切换
##### CapsuleComponent/胶囊体组件
用于运动碰撞，假设玩家是一个垂直向上的胶囊体
##### CharacterMovementComponent/角色运动组件
掉落和跑动的摩擦值，水中、空中的移动速度、浮力、重力

第一人称角色和相机的旋转是同步的，第三人称角色和相机的旋转不同步

###### PaperCharacter/Paper角色
Paper2D使用的角色蓝图，包含Sprite组件、箭头组件、移动组件
###### SpectatorPawn/旁观者
不带重力，没有碰撞的漫游Pawn
##### Controller
没有物理表现的Actor。Pawn是一个可被控制的Actor 而控制Pawn的对象就是Controller

对Actor的扩展功能
1. 与Pawn关联
2. 挂载和释放
3. 脱离Pawn存在
4. 制作Pawn
5. 事件响应
6. 访问数据PlayerState

PlayerController和AIController是Controller的两种具体类型
###### APlayer Controller/玩家控制器
用于控制玩家角色作的非实体对象，可以理解为提线木偶，真实玩家使用PlayerController控制场景中的玩家角色

负责管理玩家的Actor类型对象。主要目的是将真实玩家的意愿进行收集，最后汇总转投给虚拟角色。这个过程就是游戏中的玩家交互过程

PlayerController是Pawn和控制它的人类玩家间的接口，玩家键盘鼠标输入都是通过PlayerController再和别的Actor交互的

PlayerController本质上代表了人类玩家的意愿，是主角的灵魂，是和玩家沟通的渠道

**Player Controller中一般写玩家的输入逻辑，玩家血量、得分等状态不能放在Player Controller中，因为Player Controller不能网络复制**

**创建UI写在Player Controller里比较好，因为是和真实玩家相关的逻辑**

PlayerController在整个游戏运行过程中是一直存在的，但是Pawn可能随时被销毁，也可能初始并不存在在任意时间，控制器和Pawn之间是一对一的关系，动态生成的pawn必须设置Possess才可以被控制

控制器会接受其控制的Pawn所发生诸多事件的通知，控制器会借机实现响应此事件的行为，拦截事件或替pawn执行默认行为，从而更大限度减少输入处理与pawn移动之间的延迟
- Class Defaults
##### Mouse Interface/鼠标界面
- Show Mouse Curor---------------显示鼠标光标
- Enable Click Events------------启用点击事件
- Enable Touch Events------------启用触控事件
- Enable Mouse Over Events-------启用鼠标悬停事件
- Enable Touch Over Events-------启用触控悬停事件
默认在PlayerController里显示光标、激活点击或悬停触摸等事件
Pawn更多是获取事件、等待事件发生去执行相应的逻辑
###### AAI Controller
用于控制NPC，给AI角色添加自动寻路等功能
AI Controller的深入理解：
1. 是AI的灵魂
2. 行为树功能强大
3. AI感知
4. EQS环境查询
##### Info
主要负责游戏中的相关信息
###### Game Mode Base/游戏基础模式
用来定义游戏的一些参数，这些参数在角色死亡之后仍然生效
它的生命周期与关卡的生命周期相同
GameMode是世界规则，是最权威的

GM主要负责管理游戏的规则。这些规则包括:
1. 出现的玩家和观众数量，以及允许的玩家和观众最大数量
2. 玩家进入游戏的方式，可包含选择生成地点和其他生成/重生成行为的规则
3. 游戏是否可以暂停，以及如何处理游戏暂停
4. 关卡之间的过渡，包括游戏是否以动画模式开场

GM的主要任务就是构建和实现游戏的规则，并将游戏中的其他角色进行注册：例如默认的玩家，HUD类，玩家控制器，观众类，GameState类，PlayerState类

游戏规则及获胜条件这样的内容。它仅存在于服务器上。它一般在游戏过程中不会有太多数据改变，并且它一定不应该具有客户端需要的临时数据

在创建了Game Mode Base后，要在世界设置中的Game Mode选择创建的Game Mode Base，才会生效


在Classes中的Default Pawn Class中选择玩家角色后，可以用玩家出生点创建多个出生点，开始游戏时随机从这些出生点出生

###### AGame Mode/游戏模式
在Game Mode Base的基础上，增加了一些具体的游戏模式设置
###### Game State Base/游戏基础状态
Game State是世界状态，会通知到服务端和所有的客户端
Game State主要负责游戏中共享信息的记录，游戏的信息可以通过GameState进行存储和同步。包括:
1. 游戏已运行的时间(包括本地玩家加入前的运行时间)
2. 每个个体玩家加入游戏的时间和玩家的当前状态
3. 当前Game Mode的基类
4. 游戏是否已开始

GameState是虚幻为我们进行游戏信息记录的载体。包括像关联玩家的列表、分数、象棋游戏中的象棋位置或者在开放世界游戏中已经完成的任务列表。GameState存在于服务器和所有客户端上，可以自由地进行复制来保持同步
###### AGame State/游戏状态
###### APlayer State/玩家状态
Player State用来存储当前关卡玩家的数据信息，如玩家名、血量等数据，在切换关卡时，PlayerState会被释放，清空数据，Player State可以被网络复制从服务端同步到客户端
Player State可以理解为玩家角色肉体的状态，把它和Pawn抽离开是为了网络复制


Controller和Pawn中都有一个PlayerState对象，两者的区别是：
1. Pawn中的PlayerState是Controller中PlayerState的引用
2. Controller中的PlayerState对象在InitPlayerState()中初始化。当Possessed一个pawn的时候，会把自己的PlayerState设置给pawn中的PlayerState对象。Unpossessed的时候会把Pawn中的PlayerState对象设置为Null
3. 所以PlayerState是跟着Controller走的，Controller中的PlayerState是根源
4. PlayerState的GetOwner就是Controller
5. PlayerState的GetPawn获得当前的Pawn 有可能是Null

##### PaperFlipbookActor
Actor蓝图里添加一个Render Component组件，可以与Paper Flipbook资产绑定
##### PaperSpriteActor
Actor蓝图里添加一个PaperSprite组件，可以与Paper Sprite资产绑定

#### BTNode/行为树节点
##### BTAuxiliaryNode/行为树辅助节点
###### BTDecotator/行为树装饰器
###### BTDecorator_BlueprintBase/行为树装饰器_基础蓝图
可以自己写逻辑的行为树装饰器
###### BTService/行为树服务节点
###### BTService_BlueprintBase/行为树服务节点_基础蓝图
可以自己写逻辑的行为树服务节点
###### BTTaskNode/行为树任务节点
###### BTTaskNode_BlueprintBase/行为树任务节点_基础蓝图
可以自己写逻辑的行为树任务节点

#### Nav Area Base
##### Nav Area/导航区域
这个蓝图相当于一个枚举值中的标记，可以自定义消耗值
#### Navigation Query Filter/导航查询过滤器
包含一个数组，用来将多个Nav Area进行统一管理，方便查看和重载修改消耗值，编辑好后在AIController的类默认值中可以配置过滤器，不同的AIController配置不同的过滤器，可以实现不同的怪物和玩家寻路消耗不同，从而达到寻路逻辑不同
#### Nav Link Proxy/导航链接代理
导航链接代理的蓝图版本，通常都使用这个，因为可以触发事件，方便控制和扩展，它提供了一个Event Receive Smart Link Reached/接收智能链接已抵达事件，会在寻路角色到达导航链接时触发

它有两个输出引脚，Agent代理，即寻路的角色；Destination目标，即链接的结束点，如果角色到达的是左侧的点，目标输出的是右侧的点。这个事件可以用来做人物到达梯子，开始执行爬梯子动画；到达悬崖边，开始执行跳跃等逻辑


#### UGame Instance/游戏实例
游戏实例在游戏开始运行后始终存在，没有Scence组件，不会在场景中显示，可以用来存放游戏中始终需要使用的数据，如UIManager可以缓存到Game Instance中，再在父UI中调用并缓存
它与进程的生命周期相同

Game Instance的深入理解：
1. 是整场游戏的全局实例
2. 是World的外围管理对象
3. 是跨关卡的逻辑

#### RichTextBlockDecorator/多文本格式块装饰器
##### RichTextBlockImageDecorator/多文本格式块图片装饰器
用来制作图片类数据图表的装饰器蓝图，供UMG系统的多文本格式块调用

#### Save Game/保存游戏
保存游戏对象的基类，用于保存游戏状态，需要为保存的信息添加成员变量，借助保存游戏相关的蓝图节点，将游戏保存到存档插槽，实现存档和从存档插槽中读档等功能

是Save Game系统的核心机制，是运行内存和硬盘上存储的.sav文件的中转站，在正式存储之前，用于临时收集和存储所有要保存数据的容器。临时存储需要写入到硬盘中文件的数据，或者从硬盘中读取数据然后再写入到运行内存

注意Save Game类是存储游戏状态的，把要保存的信息添加为变量，而保存游戏的逻辑不能在Save Game中写

Save Game类智能保存基础数据类型、三种容器（数组、集合、映射）、结构体，不能保存对象引用、类等其他类型的数据

存档实际上就是数据持久化
Save Game实现数据持久化

##### UE提供的游戏保存基本原理
序列化对象（以二进制格式存储），通过创建Save Game蓝图类对象，把需要保存的数据赋值给该对象的成员变量，再把SaveGame对象序列化，得到.sav文件，保存到磁盘上来实现持久化

存档就是把运行时的数据缓存到Save Game蓝图中，再保存到硬盘文件.sav的过程
读档就是从.sav硬盘文件加载到运行内存中使用的过程

开发阶段，项目未打包前存储目录：Unreal Projects->项目名->Saved->SaveGames
打包到用户的电脑或者设备上之后，存储在不同平台的项目持久化文件夹中

##### 需要保存的数据如何管理
##### 数据分类
1. 全局数据
2. 单个玩家数据
##### 原则
相关的放在一起，不相关的分开，如果不分开存储，当项目大了之后，存储数据量多大，可能导致卡死，从而存档损坏


#### Visual
##### Widget
包含标准控件和用户控件，标准控件即UMG系统中默认提供的文本控件、按钮控件等。不能重写函数，没有事件，详见UMG系统
###### UserWidget/UMG用户控件蓝图
制作UI界面和交互的蓝图，详见UMG系统

## Blueprint Function Library/蓝图函数库
可以用来封装函数，封装的函数可供所有蓝图类使用，即C++的库，函数均为全局函数，一般放置不依赖类而单独存在的全局函数

- 用法1：可以完全通过外部传递参数，函数库只进行计算的封装
- 用法2：可以在函数库内部创建局部变量进行计算
- 用法3：函数库内部的函数可以相互调用


注意：函数库是适用于全局的函数，注意不要自身引用和信息情况添加到全局函数库中。如果包含自身信息，就把信息当做蓝图输入传递给函数库
### Graph
- Pure---------------------------纯函数，勾选后函数库调用时没有执行点（绿色），不勾选时调用有执行点（蓝色）

注意：函数库中的函数仅仅是放在一起，它们之间的数据是无关的


## Blueprint Interface/蓝图接口
蓝图接口是综合了事件分发器（Event Dispatcher）和搜索（Get All Actors of Class）二合一的东西

它相当于把事件分发器加了一个搜索的功能，同时也不限制蓝图，在蓝图接口里创建的东西（如自定义事件，函数等等），哪个蓝图都能用
创建接口之后无法编辑，可以在蓝图类中调用再进行编辑

接口主要用于有获取的时候

事件分发器必须依赖于场景中存在的文件,而蓝图接口不借助于场景中存在的文件，蓝图接口本身就有一个文件，它是通过这个文件把消息转出去，但这个文件在场景中是不存在的。这个文件是拖拽不到场景里的，但它必须存在于工程里
它虽不借助于场景中存在的文件，但它只能把消息转给场景中存在的蓝图

蓝图接口的好处在于，如果换场景，换关卡，蓝图接口照样起作用，因为蓝图接口与场景没关系
蓝图接口不借助于场景中存在的蓝图，而借助自己的文件传给场景中存在的蓝图。无论接口也好，分发器也好，都为了实现蓝图之间信息传递这个功能

**使用很频繁**

### 使用方法
有两种使用方法，使用方法比较灵活
#### 方法1：自定义事件方式实现蓝图通信
可以实现从传出数据的蓝图向接收数据的蓝图传递数据
- 第1步：创建蓝图接口，添加函数，并添加要进行通信的数据变量类（注意：使用自定义事件蓝图接口只能有输入端口，不能有输出端口）
注意：视窗里的节点是灰色 因为不同对象会执行不同命令，要到具体对象里去实现，这里只是一个声明。类似C++的多态，但是不完全一样，因为不涉及父子关系
- 第2步：在需要接收数据的蓝图（可以是多个接收数据的蓝图）中点击Class Settings，在Interfaces中添加对应的蓝图接口，然后编译
- 第3步：在需要接收数据的蓝图的My Blueprint面板中出现的Interfaces中选择要使用的函数，右键选择Implement event（执行事件时），然后在事件图表中搜索event+函数名调用自定义事件（如果蓝图接口有输出端口，则无法调用自定义事件）
- 第4步：在需要传出数据的蓝图中事件图表里搜索蓝图接口中相应的函数名，选择带Message的节点，（带Message的是在不同蓝图之间通信，不带Message是同一蓝图中调用）节点的Target需要连接接收数据的蓝图，用公开变量获取或Get Actor Of Class获取
#### 方法2：函数方式实现蓝图通信
可以实现在传出数据的蓝图中传进参数，调用接收数据的蓝图对应的蓝图接口函数进行计算，再传回计算结果
- 第1步：创建蓝图接口，添加函数，并添加要进行通信的数据变量类，可以有输入和输出端口
- 第2步：在需要接收数据的蓝图（可以是多个接收数据的蓝图）中点击Class Settings，在Interfaces中添加对应的蓝图接口，然后编译
- 第3步：在需要接收数据的蓝图的My Blueprint面板中出现的Interfaces中选择要使用的函数，双击进入函数图表，编辑函数执行逻辑，不需要在事件图表中调用
- 第4步：在需要传出数据的蓝图中事件图表里搜索蓝图接口中相应的函数名，选择带Message的节点，（带Message的是在不同蓝图之间通信，不带Message是同一蓝图中调用）节点的Target需要连接接收数据的蓝图，用公开变量获取或Get Actor Of Class获取
- 第5步：在函数的输入端口输入要传进的参数，输出端口是经过接收数据的蓝图对应的蓝图接口函数计算后的结果
#### 总结
- 没输出引脚：发出者调用接口，接口调用接收者中的“事件”
- 有输出引脚：发出者调用接口，接口调用接收者中的“函数”，发出者得到其返回值后执行后面逻辑
- 事件——在接口蓝图中，未添加输出引脚，注意输入引脚并不影响
- 函数——在接口蓝图中，添加了输出引脚，注意输入引脚并不影响


## Blueprint Macro Library/蓝图宏库
宏与函数的区别是函数只能有一个输入执行引脚和一个输出执行引脚，而宏可以有多个。类中的成员宏是私有的，不能被子类继承，要使用公开的宏，要创建蓝图宏库，并选择作用范围的类，在宏库里创建的宏在选定的类和子类中都可以使用

因为宏可以有多个执行引脚，因此它非常适合封装流程控制

在宏中使用局部变量，要创建节点Local 变量类型，给局部变量赋值要用Assign节点


## Enumeration/蓝图枚举
创建多个同类枚举，供蓝图类调用

用法：创建之后在蓝图中创建变量，类型为创建的枚举，即可以在蓝图、动画蓝图等中调用

## Structure/蓝图结构体
创建多个公用变量可供所有蓝图类调用，也可以用来设置数据表格的类型，蓝图结构体中只能创建成员变量，不能包含成员函数，成员变量可以直接设置默认值
使用结构体，变量就由单一属性，变成复合属性。打破了变量同质（相同性质）的特点

结构体可以嵌套结构体

结构体可以变成数组

特别注意：结构体被调用之后要避免改动结构体资源的名字，避免将蓝结构体资源移动位置，否则会报错，并无法使用。如果已经改名或移动位置，在使用了结构体资源的蓝图中点击File-->Refresh All Nodes刷新节点。如果还是不行，需要手动一个个修改出错的节点


## Miscellaneous/杂项
### Composite Curve Table/复合曲线表格
只能存储纯数字数字类型的数据，可以用来配置每一级升级经验、不同等级不同的攻击力等

### Composite Data Table/复合数据表格
可以堆叠覆盖多个Data Table，实现配置的层次
对外透明，像普通的Data Table一样使用

## Data Asset/数据资产
灵活的数据配置方式。方便配置树状组织数据，全局配置，数据对象集合
每一个Data Asset都是一份数据对象
如继承自UPrimaryDataAsset可方便管理数据对象的加载释放

Data Asset的优缺点：
优点：
1. 容易子类化
2. 可快速引用其他资产UMyDataAsset*
3. 可用BulkEdit快速编辑多个Data Asset
4. 可容纳UObject实例
缺点：
不好管理大量的配置对象



## Data Table/数据表格
独立的记录数据的表格，可供蓝图、UMG等系统调用，可以从CSV格式的表格文件中导入数据
创建时要选择类型，有一些默认类型，还可以自定义类型，类型由Structure(蓝图结构体)决定，可以为数据表格创建蓝图结构体，用于读取数据
### CSV
Comma-Separated Valus，是用逗号隔开的纯文本文件，策划方便改，程序方便读 
#### 默认类型
- Rich Image Row-----------------富图片行，数据有行序号和笔刷数据（包括图像、图像大小、着色等），要创建一个Rich Text Block Image Decorator多文本格式块图片装饰器蓝图,来加载富图片行数据，使用的时候在富文本控件中的装饰器类选择多文本格式块图片装饰器蓝图，然后使用<Img id="行序号"/>来调用图片，例如可以将数字和艺术字数字图片绑定到Data Table，在UMG系统中调用
- Rich Text Style Row------------富文本风格行，数据有行命名和文本样式，可以设定字体、颜色、字号等文本样式，在可以在UMG系统的富文本控件中设置文本样式集，然后使用  <行命名>文本内容</>  字段来使用文本样式

Data Table的优缺点：
优点：
1. 表格式视图，易于编辑
2. 可以导入导出CSV/JSON
3. 可以用FDataTableRowHandle引用一行
4. 方便配置大量数据
缺点：
1. 不能包含UObjects
2. 无父子层级关系
3. 无序，用TMap<FName.T>保存
4. 不可引用其他表格
5. 依然强绑定资产的加载

# BluePrint蓝图编辑器
## Components/组件
把不同的功能封装成不同的组件，需要的时候调用。组件从属于Actor。组件里包含一些关卡编辑器中Modes中的一些对象，如灯光，添加后与Modes中的灯光相同，有灯光的所有参数，但是可以在蓝图中使用节点控制。还有Modes中没有的一些组件可以在蓝图中使用

Component的深入理解
1. 组件是种能力
2. 为Actor提供能力
3. 能力一般跟业务逻辑无关
4. 能力是跨游戏的


可以把Actor看成一个角色，Components是角色的技能，给Actor添加什么Components，他就会有什么技能

Actor是UE4的最基础的概念，而组件Component用于扩展Actor的功能，让Actor具备解决问题的能力和思想
### 蓝图文件名（自身）即Class Defaults
#### Pawn
- Use Controller Rotation Pitch--使用控制器控制Pawn的Pitch
- Use Controller Rotation Yaw----使用控制器控制Pawn的Yaw，这样Pawn的旋转与控制器完全一致，一般默认会勾选，但是第三人称类游戏角色和相机旋转是独立的，会取消此项勾选，让相机和控制器旋转同步，角色的旋转由当前朝向来决定

注意：右手坐标系Pitch、Yaw、Roll对应绕X、Y、Z旋转，但是UE使用左手坐标系，Roll、Pitch、Yaw对应绕X、Y、Z旋转
- Auto Posses Player-------------选择自动受哪个玩家控制
#### Default Scene Root/根组件
创建蓝图后自带的空白组件，仅有缩放变换，无碰撞。如果用别的组件替换，就无法再创建根组件。根组件决定了物体有能被看见的功能（Transform），保证物体的位置、旋转、缩放信息，从而在3D场景中显示

### 组件的主要类型
#### UActorComponent
基础组件，可作为Actor的一部分被包含。如果需要，可进行Tick。ActorComponents与特定的Actor相关联，但不存在于场景中的任意特定位置。通常用于概念上的功能，创建自定义的组件时，如果不需要在空间中的变换，就使用ActorComponent
如:CharacterMovementComponent
#### USceneComponent
SceneComponents是拥有变换的ActorComponent。SceneComponents能以层级的方式相互附加。Actor的位置、旋转和缩放取自位于层级根部的SceneComponent
#### UPrimitiveComponent
PrimitiveComponent是拥有一类图像表达（如网格体或粒子系统）的SceneComponent。诸多的物理和碰撞设置均在此处

### Common/常用组件
#### Scene/场景组件<USceneComponent>
相当于一个空物体，用途很多，可以获取到角色骨骼中的插槽，绑定枪支武器等，也可以作为生成对象的生成点，提供位置、缩放、旋转信息等
#### Skeletal Mesh/骨骼网格体组件<USkeletalMeshComponent>
添加带骨骼的模型，给角色添加实体模型
##### Sockets/插槽
- Parent Socket------------------父项插槽，在这里选择插槽
##### Animation/动画
给角色添加动画控制
- Animation Mode-----------------动画模式，一般使用动画蓝图
- Anim Class---------------------动画类，选择配置好的动画蓝图文件，使动画蓝图与蓝图绑定
##### Mesh
- Skeletal Mesh------------------选择模型资源
#### Static Mesh/静态网格体组件<UStaticMeshComponent>
添加无骨骼的模型
##### Physics/物理
- Simulate Physics---------------模拟物理，勾选后开启模拟物理，会受到重力、力、冲量的影响
- MassInKg-----------------------对象的质量（千克）
- Linear Damping-----------------线性阻尼，给物理对象添加类似线性阻力的效果，减缓线性运动速度，实质上是定义了物理对象抵抗线性运动的程度
- Angular Damping----------------角阻尼，给物理对象添加旋转阻力的效果，减缓旋转速度，实质上是定义了物理对象抵抗训传的程度
- Enable Gravity-----------------启用重力，勾选后，物理对象具有重力
- Constraints--------------------约束，对物理对象进行约束
  - Lock Position------------------锁定位置，分为X、Y、Z三个轴，勾选哪个轴，物理对象的那个轴的位置在物理模拟中不会变化
  - Lock Rotation------------------锁定旋转，分为X、Y、Z三个轴，勾选哪个轴，物理对象的那个轴的旋转在物理模拟中不会变化
  - Mode---------------------------约束模式
    - Default------------------------默认，根据Lock Position和Lock Rotation控制
    - Six DOF------------------------指定要冻结旋转和移动的轴
    - YZPlane------------------------锁定在YZ平面
    - XZPlane------------------------锁定在XZ平面
    - XYPlane------------------------锁定在XY平面
    - Custom Plane-------------------锁定到自定义平面
    - None---------------------------无约束
- Ignore Radial Impulse----------忽略径向冲量，会忽略冲量在径向的作用
- Ignore Radial Force------------忽略径向力，会忽略力在径向的作用
- Apply Impulse on Damage--------在伤害上应用冲量，勾选后，此组件如果受到伤害事件，会应用冲量
##### Collision/碰撞
UE4的碰撞检测
前提：碰撞器（碰撞体积 碰撞空间）

两种类型
1. CollisionComponent 碰撞组件 盒子 胶囊 球体
2. CollisionMesh 导入网格资源自动生成的碰撞器

UE4物体的碰撞响应的三种状态：Ignore忽略、Overlap重叠、Block阻挡
碰撞事件
1. 如果两个物体有一个被设置成了Ignore，那么不会产生任何碰撞事件
2. 如果两个物体有一个设置成了Overlap，且另一个不是Ignore，那么会产生overlap事件
3. 两个都设置成了Block，会产生Hit事件（命中事件）

UE4在识别碰撞时，只会识别根组件的碰撞检测，子节点忽略

Sweep:在移动过程中，时刻检测周边环境，触发碰撞(物理效果)和触发事件（逻辑），如果碰撞检测设置的没问题，但是没有发生碰撞，检查是否勾选了Sweep

### 物理引擎和碰撞的计算具有随机性
原因：
1. 每一帧的时间不是严格相等
2. 浮点数计算不准确（两个浮点数计算，结果不可重复）
- Simulation Generates Hit Events--模拟生成命中事件，勾选后，物体在碰撞时可以触发碰撞事件
- Generate Overlap Events----------生成重叠事件，勾选后，物体在发生重叠时可以触发重叠事件

重叠事件默认勾选 需要Hit事件则需要额外勾选，一般不会同时使用

- Collision Presets--------------碰撞预设，在这里调整组件的碰撞设置，非常重要
- Collision Presets--------------碰撞预设
  - Custom-------------------------自定义碰撞，手动控制对象与所有碰撞通道的碰撞关系
  - No Collision-------------------无碰撞，不进行碰撞检测
  - Block All----------------------阻挡全部，对所有物体都进行阻挡
  - Block All Dynamic--------------阻挡所有动态物体
  - Overlap All--------------------重叠全部，对所有物体都进行重叠
  - Overlap All Dynamic------------重叠所有动态物体，对动态物体进行重叠
- Collision Enabled--------------碰撞已启用，设定碰撞的类型
  - No Collision-------------------无碰撞，不进行碰撞检测
  - Query Only(No Physics Collision)--纯查询（无物理碰撞），仅会触发碰撞查询，有碰撞响应，会触发碰撞事件，但是不会出现物理碰撞
  - Physics Only(No Query Collision)--纯物理（不查询碰撞），仅有物理上的碰撞，但是不会触发碰撞查询，没有碰撞响应，不会触发碰撞事件
  - Collision Enabled(Query and Physics)--已启用碰撞（查询和物理），会触发碰撞查询，有碰撞响应，会触发碰撞事件，同时也会出现物理碰撞
- Object Type--------------------对象类型，即碰撞通道，选择对象是属于哪个碰撞通道的，碰撞根据通道来检测
默认有5个碰撞通道，可以在Project Settings-->Collision中添加对象通道和追踪通道，每种通道最多可以添加18个
  - World Static-------------------世界中静态物体
  - World Dynamic------------------世界中动态物体
  - Pawn---------------------------角色
- Collision Responses------------碰撞响应，在这里设置与各追踪通道和碰撞通道的碰撞响应

### AI/AI组件
#### AIPerception/AI感知组件
一般在AIController中使用，可以让AI有视觉或听觉等感知行为，例如：AI在看见敌人后才进行射击
##### AI Perception/AI感知
设置AI感知行为
- Senses Config------------------添加感知行为
  - AI Sight config----------------AI视觉感知
- Sense
  - Sight Radius-------------------视觉半径，该感官可以开始感知的最大距离
  - Lose Sight Radius--------------视觉丢失半径，视觉感官不能再感知已看见目标的最大距离
  - Peripheral Vision Half Angle Degrees--周边视觉半角度，即视觉范围角度
  - Detection by Affiliation-------按归属检测决定敌方（Enemies） 、 中立方（Neutrals） 或 友方（Friendlies）是否可以触发这种感官


该属性可用于设置团队视觉感知。目前，归属关系（Affiliation）只能在C++中定义。对蓝图而言，可以使用 检测中立方（Detect Neutrals） 选项来检测所有Actor，然后使用标签（Tags）过滤Actor的类型

- Dominant Sense-----------------主导感官，指定一种感官，确定被感测Actor的位置后，该感官应优先于其他感官。应该将其设为感官配置（Senses Config）部分中所配置的一种感官，或者设为无（None）
##### Events/感知事件
- On Perception Updated/感知更新时
当感知系统接收到更新时，将触发此事件并返回发出更新信号的Actor排列
- On Target Perception Info Updated/目标感知信息更新时
通知所有绑定对象给定目标的感知信息已更新。根据刺激配置，针对任何接收到的刺激或状态变化广播通知
- On Target Perception Updated/目标感知更新时
感知系统接收到更新时将触发此事件并返回发出更新信号的Actor。它还会返回 AI刺激（AI Stimulus） 结构体，可将其分解来获得附加信息
  - >Break
  - Age----------------------------时长，刺激发生后的时长
  - Expiration Age-----------------失效时长，该刺激失效前的时长
  - Strength-----------------------强度，刺激中定义的强度
  - Stimulus Location--------------刺激位置，该刺激的起源位置
  - Receiver Location--------------接收者位置，该刺激由AI感知系统所注册的位置
  - Tag----------------------------标签，与该刺激相关联的所有Gameplay标签
  - Successfully Sensed------------成功感知，该刺激是否被AI感知系统感应（返回True或False）
- On Component Activated/组件激活时
AI感知组件被激活时所触发的事件
- On Component Deactivated/组件停用时
AI感知组件被停用时所触发的事件

### Camera/摄像机组件
#### Camera/摄像机组件
```
<UCameraComponent>------#include "Camera/CameraComponent.h"
```
一般要手动添加一个摄像机部件，因为在默认摄像机下，旋转时模型会改变位置，而不是同步旋转
#### Spring Arm/弹簧臂组件
```
<USpringArmComponent>-----#include "GameFramework/SpringArmComponent.h"
```
该组件会尝试维持子项与父项的固定距离，若出现碰撞，将收回子项，无碰撞时，将弹回子项
一般用作摄像机的父组件，当做相机吊杆，方便控制，当角色和相机之间有障碍，弹簧臂会自动收缩，避开障碍。相机和角色距离会拉近，此时移动角色，相机不会移动，距离到弹簧臂设定距离后，摄像机开始跟随角色移动，可以让相机不进入场景内从而穿帮
##### Camera Settings
- Use Pawn Control Rotation------使用Pawn控制旋转，勾选后，相机的旋转会和控制器同步
##### Lag
- Enable Camera Lag--------------启用摄像机延迟，勾选后，相机延迟至目标位置之后，以平滑其移动
- Camera Lag Speed---------------摄像机延迟速度，如果开启摄像机延迟，此参数控制相机抵达目标位置的速度，数值越低，速度越慢，延迟越高，0为即时无延迟
- Camera Lag Max Distance--------摄像机延迟最大距离，相机延迟至当前位置之后的最大距离，若为0，则不执行最大距离

### Collision/碰撞组件
#### Box Collision/方形碰撞体
```
<UBoxComponent>-----#include"ComponentsBoxComponent.h"
```
##### Events/事件
点击后创建一个相应的事件节点
- On Component Hit---------------当组件受到碰撞时
- On Component Begin Overlap-----当组件开始被穿过时,即当角色走进碰撞体范围内时
- On Component End Overlap-------当组件结束被穿过时,即当角色走出碰撞体范围时

#### Sphere Collision/圆形碰撞体
```
<USphereComponent>-----#include"Components/SphereComponent.h"
```

### Movement
#### Character Movement/角色移动组件
Character类蓝图特有的核心功能组件，控制角色的行走、奔跑、跳跃、游泳等行为
##### Character Movement(Rotation Settings)/角色移动组件（旋转设置）
- Rotation Rate------------------旋转角度范围，一般角色不会前后和左右翻滚，所以X和Y方向范围为0，Z方向为360
- Orient Rotaion to Movement-----将旋转朝向运动，勾选后会让角色朝向加速方向，注意此选项和Class Defaults中的Use Controller Rotation选项有冲突，不能同时勾选

### Paper2D
制作2D游戏蓝图资产
#### Paper Flipbook
用来和Paper Flipbook资产绑定，制作2D有动画的蓝图
#### Paper Sprite/精灵组件
用来和Paper Sprite资产绑定，制作2D无动画的蓝图

### Rendering
#### Scene Capture Component 2D/场景2D捕捉组件
自带一个相机，可以将相机捕捉到的场景映射到TextureRenderTarget2D资源上面，可以用来做简易的小地图
##### Projection/投射
- Projection Type----------------相机投射方式
  - Perspective--------------------透视
  - Orthographic-------------------正交
- Ortho Width--------------------正交宽度
##### Scene Capture/场景捕捉
- Texture Target-----------------选择要映射到的TextureRenderTarget2D资源

快速制作小地图方法：
- 第1步：在玩家的角色蓝图里添加Scene Capture Component 2D组件，放置在人物正上方，相机朝下，相机投射方式设为正交
- 第2步：新建一个TextureRenderTarget2D资源，放置到Texture Target中，并由TextureRenderTarget2D资源创建一个材质，材质设为User Interface类型
- 第3步：创建UI，新建一个图片组件，图像设为TextureRenderTarget2D资源创建的材质
- 第4步：在关卡蓝图中创建并显示UI

#### Skeletal Mesh/骨骼网格组件
见Common-->Skeletal Mesh

### User Interface
#### Widget/控件组件
添加UMG控件蓝图作为组件挂载到Actor身上，可以用来制作人物头顶的血条、箱子的提示等
##### User Interface
- Space--------------------------空间，用于渲染控件的坐标空间
  - World--------------------------世界空间，UMG控件以网格体形式在世界场景中进行渲染，处于世界空间，不会始终朝向屏幕，会有近大远小的透视效果，可以被遮挡，可以连接节点控制让它始终朝向屏幕
  - Screen-------------------------屏幕空间，UMG控件处于屏幕空间，会始终朝向屏幕，没有近大远小的透视效果，不会被遮挡
- Timing Policy------------------定时原则，控制UMG控件如何处理游戏中的定时和暂停等情况
  - Real Time----------------------UMG控件将实时使用。当游戏没有实时进行时（比如游戏暂停），会累积到下一个实时帧被模拟
  - Game Time----------------------UMG控件将使用游戏时间，并考虑暂停和时间扩展
- Widget Class-------------------选择控件蓝图类
- Draw Size----------------------绘制大小，显示的四边形的大小
- Manually Redraw----------------手动重绘，控件是否应该等待被告知重绘，方可实际绘制
- Redraw Time--------------------重绘时间，绘制时间间隔，如果为0，则重绘每一帧。如果为1，将每秒重绘。这也可以与手动重绘（Manually Redraw）配合使用。可以理解为，手动重绘，但只能以这个最大速率重绘
- Draw at Desired Size-----------按要求大小绘制，使渲染目标自动匹配控件类指定的所需大小。如果每一帧都绘制，那么资源消耗会很大
- Pivot--------------------------枢轴，控件相对于该位置放置的对齐点/枢轴点
- Geometry Mode------------------几何形状模式，控制UMG控件的形状
  - Plane--------------------------UMG控件会投射到一个平面上
  - Cylinder-----------------------UMG控件会投射到一个圆柱上
- Cylinder Arc Angle-------------圆柱弧角，投射的圆柱的曲率，单位为度
- Tick Mode----------------------实时帧模式
  - Enabled------------------------组件实时更新
  - Disabled-----------------------组件不会实时更新，直到Enabled重新被启用
  - Automatic----------------------组件只有在需要的时候实时更新

### Utility
#### Arrow/箭头组件
添加一个箭头，箭头在开始游戏后不显示（可以修改参数让其显示），可以用来给添加的对象、特效等定位
#### CapsuleComponent/胶囊组件
默认的胶囊体，这个默认胶囊体尺寸是人的尺寸，一般不用调节
#### Child Actor/子对象
可以把别的蓝图类作为组件，但是在游戏运行后无法改变类
#### Spline/样条组件
添加一个样条，可以在视口中编辑样条，按Alt键拖动点会创建新的点。样条可以控制角色行走路径等

## My Blueprint/我的蓝图
在这里可以自定义添加函数、宏、变量、事件调度器等
#### Graphs/图表
这里包含所有在图表中添加的事件
#### Functions/函数
在这里可以添加和修改函数，函数是将多个节点实现的功能封装起来，使逻辑更清晰，便于调用，且系统消耗也会降低

蓝图函数需要注意的是，不能在里面写TimeLine和Delay这种节点，因为蓝图函数的特点是，必须在调用的一瞬间完成，这一瞬间是一帧以内必须完成

右键选择Find References，可以查找函数在哪里被调用

函数的参数是自下而上计算的

##### 函数与事件的区别
- 重要区别：
  - Delay/Timelines等需要一段时间的节点，事件中可以调用，函数中不能调用
  - 函数可以有返回值，事件没有（如果函数没有设定返回值，那么函数调用节点和事件调用节点相同）
  - 函数不支持网络属性，如果需要网络复制，需要用事件
- 本质区别：
  - 函数调用立刻执行并等待结果，事件调用只是触发
  - 函数执行在同一线程，事件执行在不同线程
- 其他区别：
  - 函数可以有局部变量，事件没有
  - 函数定义独占整个页面，多个事件定义可以共享同一个页面
因为函数执行顺序有保证，所以优先使用函数


##### 函数用法
函数有2种用法：
-用法1：+Fuction-->添加自定义函数
-用法2：Override-->修改父项蓝图类已封装的函数

UE4的蓝图类封装的函数预留的接口，可以用来修改和添加功能
##### Graph
- Category-----------------------类别，可以把函数归类，方便使用，可归入现有类别，也可在上面输入新类别名，相当于C++中UFUNCTION(Category="类别名")
- Access Specifier---------------访问说明符,即访问函数的权限设置
  - Public-------------------------公开，任何Actor均可访问和调用，外部调用的函数设为公开
  - Protected----------------------受保护的，只有自己和自己的子类可以访问和调用
  - Private------------------------私有，只有自己能访问和调用，仅自己使用的内部函数设为私有
- Pure---------------------------不勾选为非纯函数，勾选后变为纯函数，纯函数没有执行端口

在使用纯函数时，一定要遵守这个概念上的必要条件：不对数据进行修改，仅读取数据
纯函数的执行时机：在被需要时自动调用

注意如果图表里没有任何执行端口，那么右键调用函数时无法查询到自定义的非纯函数
##### Inputs/输入
给函数添加输入值
- 输入端口
  - `>`点开左侧三角
  - Default Value------------------默认值，不传入参数时端口参数默认值
  - Pass-by-Reference--------------勾选后以引用方式传入参数，参数显示名会增加(by ref)

非常重要，勾选后函数节点对应的端口会变成三角符号，会以引用方式传入参数
##### Outputs/输出
给函数添加返回值节点和返回值

### Override/函数覆写
即C++中的函数重写概念
- 函数重写-----函数返回值类型、函数名、参数列表完全相同
= 函数重载-----函数名相同即可，返回值类型和参数列表可以不同
### User Widget/用户控件
#### Mouse/鼠标
##### On Mouse Button Down/按下鼠标按钮时
按下鼠标按钮时的逻辑，可以通过Detect Drag if Pressed节点控制按的是哪个按键
   - 输入引脚
 - My Geometry--------------------几何体，所有的UMG都可以当作是几何体，这个引脚传出的是接收事件的UMG控件
 - Mouse Event--------------------鼠标事件，传出的是鼠标事件的相关信息
   - 输出引脚
 - Return Value-------------------返回值，类型是事件回复类型结构体，事件是否得到处理，以及系统采取行动的可能请求
  #### Drag and Drop/拖动和放置
##### On Drag Detected/发现拖动时
当检测到控件被拖动时的逻辑

UE4的拖动原理是控件发生拖动时，删除原来的控件，复制一个新的控件供拖动，在修改拖动功能时，不能违背这个原理
- 输入引脚
  - My Geometry--------------------几何体，所有的UMG都可以当作是几何体，这个引脚传出的是接收事件的UMG控件
  - Pointer Event------------------指针事件，传出的是鼠标拖动事件的相关信息
- 输出引脚
  - Operation----------------------操作，函数返回的是拖放操作的信息

##### On Drop/放置时
当用户在控件上放置东西时触发，在拖拽和放置操作结束时触发
- 输入引脚
  - My Geometry--------------------几何体，所有的UMG都可以当作是几何体，这个引脚传出的是接收事件的UMG控件
  - Pointer Event------------------指针事件，传出的是鼠标拖动事件的相关信息
  - Operation----------------------操作，传出的是拖放操作的信息，连接Get Payload节点，再进行类型转换，可以获得拖拽的控件
- 输出引脚
  - Return Value-------------------返回值，返回一个布尔值，来确定放置操作是否完成


回调函数（Callback Function）
回调函数就是一个被作为参数传递的函数，可能是同步回调，也可能是异步回调，目的是将函数当做变量传出去

常用回调函数的地方：
1. UI
2. 碰撞
3. 网络
4. JavaScript/Node.js

#### Macros/宏
宏与函数的区别是函数只能有一个输入执行引脚和一个输出执行引脚，而宏可以有多个，但是类中的成员宏是私有的，不能被子类继承。因为宏可以有多个执行引脚，因此它非常适合封装流程控制

在宏中使用局部变量，要创建节点Local 变量类型，给局部变量赋值要用Assign节点

成员宏是私有的，不能被子类继承，要使用公开的宏，要创建宏库，并选择作用范围的类，在宏库里创建的宏在选定的类和子类中都可以使用

宏和函数的区别：
1. 处理时机不同，宏是在预处理阶段处理，函数是在编译阶段处理
2. 工作机制不同，宏是展开的，就是在预处理阶段直接把对应的代码复制粘贴到对应位置，然后宏就消失了。函数是编译的
3. 宏运行时无实体，函数运行时有实体，是占用一段内存空间的
4. 宏可以有多个执行入口和多个执行出口，函数只有一个执行入口和一个执行出口
5. 宏可以使用Delay，函数不能使用Delay
6. 宏不能网络复制不能继承，函数可以网络复制可以继承

#### Variables/变量
这里可以显示、添加和修改变量，变量用来存储数据，方便调用

快捷操作：按Ctrl拖拽到图表是Get，按Alt拖拽到图表是Set

变量三要素：地址、变量名、值
##### 变量类型
- Boolean（红色）/布尔型
C++中的bool,字节长度是1，取值范围是True或False
- Byte（墨绿色）/8位整数
C++中的unsigned int8,字节长度是1，取值范围是0-255
- Integer（青色）/32位整数
C++中的int32,字节长度是4，取值范围是-2,147,483,648到2,147,483,647
- Float（绿色）/浮点数
即包含小数，C++中的float,字节长度是4，取值范围是-3.4E+38到3.4E+38。6位有效数字，多的会四舍五入
它会把数字分成两个部分，有效数字和指数进行存储
- Name（紫色）/命名
特化的字符串，即很短的字符，不区分大小写，如名字
- String（品红色）/字符串
中等长度的字符，如人物对话比较常用，函数多用String
- Text（粉红色）/文本
支持本地化的字符串，支持多国语言，可以输入文字，可以输出长篇的字符，如故事背景
- Vector（黄色）/向量
包含3个有序的浮点数
- Rotator（浅蓝色）/旋转
包含3个有序的浮点数，3个浮点数分别表示与X轴、Y轴、Z轴的角度
- Transform（橙色）/变换
/包含3个有序的数值，分别是位置（Vector类型）、旋转（Rotator类型）、缩放（Vector类型）
- Structure（蓝色）/结构体
- Object Types/对象类型
由虚幻定义的类或自定义的类

类型（Type）与类（Class）的区别：
类型包括两种，一种是基本数据类型，一种是自定义类型，类又叫类类型，就是自定义类型

Object/对象
广义指变量（类型的实例），狭义指类的实例
- 对象在蓝图中都是以地址形式传递的
- Struct在蓝图中是以值形式传递的，把Pass-by-Reference勾上，可以地址传递

##### Variable
- Instance Editable--------------可编辑实例，即公开变量，激活后可以选择场景中的Actor或参数等内容
*公开变量：点亮变量后面的眼睛，可以在场景中更改赋值（Actor类型的用的比较多，用来获取场景中的其他Actor）*
- Expose on Spawn----------------生成时公开，在蓝图类被实例化时，动态修改其内容或参数时调用，可以在Spawn Actor、Create widget等创建对象的节点上直接传参赋值，非常方便
- Replication--------------------复制，在网游中，这个变量的传输模式
  - None---------------------------不复制变量，单机游戏和网游中不需要同步的数据设为None
  - Replicated---------------------复制变量，变量数据会从服务端复制到所有的客户端，网游中需要同步的数据设为此项，是单向复制，客户端数据不会复制到服务端

特别注意：
1. 需要在类默认值中Replication里勾选Replicates，才会生效
2. 需要对象一开始就在场景中，或者由服务端生成

设为Replicated后，变量的右上角会出现两个小球
## Replication/复制
是一种同步机制。Actor及Actor中的属性，可以设置是否复制，Actor默认不勾选，Pawn默认勾选。复制是单向的，只能从服务器到客户端
### Actor的产生和复制
客户端Spawn的Actor，不会被复制

服务器Spawn的Actor，可以被复制

初始就放置在关卡中的Actor，可以被复制
- RepNotify----------------------更新通知，会自动创建一个函数，会在复制变量的同时，多有客户端都调用这个函数，功能类似于Multicast（多播），但是RepNotify是可靠的，多播可以自己设置是否可靠

## 数据结构（容器）
### 数组Array
一种可以自动变化大小的容器，容器内只能存储同一种数据，我们也称之为同质容器
Array是最常用的容器，出场率最高的容器，在常规使用中具有典型的优势（随意扩容调整容器大小）。Array在使用时，隐性提供了索引下标。通过下标可以安全的访问到容器中的内容

切记索引下标是从O开始计算，最末位的值永远比容器中元素个数少1

Array特点访问速度快、内存消耗较小、安全性高，可以随意调整容器的大小,但是元素位置在容器中不会发生改变(除去插入和移除)

在Array中进行数据获取时，复制和引用有非常大的差别。复制主要将容器中的对象进行了复制操作，在外部修改不会影响容器内的数据。而引用则是在外部修改数据会影响到容器内的数据内容

#### 特点
- 元素连续存放
- 通过索引访问
- 索引从0开始连续递增
#### 函数调用方法
- Get-------------------------按照索引得到元素
Get分为复制和引用两种方式
在Array中进行数据获取时，复制和引用有非常大的差别。复制主要将容器中的对象进行了复制操作，在外部修改不会影响容器内的数据。而引用则是在外部修改数据会影响到容器内的数据内容，常用的是复制方式
- add-------------------------增加新元素，末尾添加
- Length----------------------数组长度
- Add Unique------------------增加一个新元素，保持独特性，会过滤相同元素，只能添加数组中没有的元素
- Find Item-------------------查找元素是否在数组中，返回值是布尔
- Insert----------------------插入元素
- Remove Index----------------按照索引值删除元素
- Remove Item-----------------按照元素删除（相同元素全部删除）
- Contains Item---------------判断元素是否在数组内，返回值是布尔
- LastIndex------------------数组的最后一个有效索引
- Resize---------------------重新设置数组的长度
- Clear----------------------清空数组

### 集合Set
会剔除重复的元素，集合的元素是无序的
如果添加的元素集合中本来就有，就会忽略添加
需要遍历的时候需要先ToArray转换成数组再遍历
键值类同质容器。键值和元素相同，本身对键值操作隐藏。操作标签即为元素本身
即如果想要操作Set中的内容，需要先知道元素。这与其他两种容器思考方式完全不同
Set不会注重排序，也就是说元素在容器中的顺序是不固定的，不应该依赖顺序
应用场景:游戏中的聊天辱骂过滤，玩家创建名称时敏感词检索，特殊道具持有检查等
#### 特点
- 数据不重复
- 无序
- 会有一些特殊的函数调用方法
#### 函数调用方法
- Add-------------------------增加集合元素
- AddItems--------------------添加一个数组到Set
- Clear-----------------------清除所有元素
- Contains Item---------------判断集合中是否存在某个元素，输出一个布尔值
- Difference------------------差集
- Intersection----------------交集
- Length----------------------集合长度
- Remove----------------------移除某一元素，会输出一个布尔值来判断这个元素是否存在
- Remove Items----------------移除数组
- To Array-------------------把集合转换成数组
- Union----------------------并集
※※※※※集合一般不在默认值处赋值，一般都是在代码中赋值
### 映射（字典）Map（Dictionary）
映射是比较快捷的访问方式
如果添加的元素字典中本来就有，就会替换原来的值
数组可以看作是键值对，映射的键不局限为int
具有键值的同质容器，对于元素操作需要依靠键值，键值是Map的操作标签。键值类型可以是蓝图常规对象类型
元素类型必须相同，键值唯一。也就是加入相同键值元素将被覆盖。
应用场景:游戏中的背包栏（具备格子概念背包)，游戏中的技能栏（具备技能释放快捷键)，游戏中的装备槽等。
#### 特点
-  存储Key-Value格式（键值对）
-  Key不能重复
-  Key只能是一些简单的变量类型Byte Int Float Name String，Value可以是任意类型
#### 函数调用方法
- Add-------------------------增加键值
- Clear-----------------------清除所有键值
- Contains--------------------判断映射是否包含某个键，输出布尔值
-  Find------------------------判断映射是否包含某个键，输出布尔值和该键对应的值
- Keys------------------------将键转化为数组
- Length----------------------输出映射的长度
- Remove----------------------移除某一键值
- Values----------------------将值转化为数组

如果要大量使用遍历，不建议使用映射


#### Event Dispatchers/事件分发器
可以用于蓝图通信，非常方便，同一类物体可以大量减少代码量
主要是减少Tick事件的调用

优点：
1. 多听众时，更方便
2. 某些情况下，从代码组织上看，更有逻辑，也便于迭代

用法：
1. 点击创建之后，在Input中添加变量
2. 编辑图表，最后输出给Call Event作为事件调用，即充当哨兵，敌人来了发出信号
3. 在别的蓝图类中使用Bind Event调用，即战士听到哨兵信号之后发生什么事件
PlayerState的数据一般都以时间调度分发方式传递
#####  Call/调用
发出事件调用信号，一旦触发调用，所有绑定了事件的蓝图都会执行后续事件
#####  Bind/绑定
在别的蓝图中绑定事件，调用处罚后，所有绑定了事件的蓝图都会执行后续事件
#####  Unbind/解除绑定
解除绑定的某个事件，例如只需要触发一次，可以在触发之后解除绑定
#####  Unbind all/解除所有绑定
解除所有绑定的事件，如果调用的节点用在一个需要反复使用的蓝图中，且有多个蓝图绑定了分发事件，而每次使用只需要单个的已绑定的蓝图触发事件，就在调用节点后面连接解除所有绑定事件，触发后即解除绑定
#####  Event/事件
自定义触发事件
#####  Assign/分配
自动生成带自定义事件的绑定，相当于Bind+Event


## Toolbar/工具栏
#### Compile/编译
#### 类设置
##### Interfaces/接口
点击add，可以添加创建的蓝图接口

## Construction Script/构建脚本图表
这里控制关卡运行开始前执行的事件，这里的事件只执行一次，功能和调用时机类似于构造函数，一般在这里写客户端的代码,以及角色蓝图的材质等资源的预加载

创建蓝图类的实例时，构造脚本(Construction Script)在组件列表之后运行。它包含的节点图表允许蓝图实例执行初始化操作。构造脚本的功能可以非常丰富，它们可以执行场景射线追踪、设置网格体和材质等操作，从而根据场景环境来进行设置。例如，光源蓝图可判断其所在地面类型，然后从一组网格体中选择合适的网格体，或者,栅栏蓝图可以向各个方向射出射线，从而确定栅栏可以有多长

*将枪绑定到角色的手上，在构建脚本图表中使用AttachComponentToComponent节点*

## Event Graph/事件图表（节点）
蓝图节点可以分为变量、事件、功能三大类

节点颜色区分
蓝色-----函数调用或事件调用
紫色-----函数定义
红色-----事件定义
绿色-----纯函数调用
灰色-----宏调用
###  Actor
#### Get Component by Class/从类中获取组件
是蓝图的根据名字获得组件的反射机制，如果是蓝图创建的组件，返回的就是显示的组件名，如果是C++创建的组件，显示TEXT中输入的组件名
#### Get Components By Class/从类中获取所有组件
是蓝图的根据名字获得组件的反射机制，如果是蓝图创建的组件，返回的就是显示的组件名，如果是C++创建的组件，显示TEXT中输入的组件名

###  Add Event/添加事件
事件调用的本质是触发
事件分为以下几种类型

### Actor基础生命周期事件
#### Event BeginPlay/开始游戏事件
游戏开始时触发的事件，当一个actor被spawn到关卡时调用
#### Event Tick/持续事件
游戏开始后不停触发的事件，每帧执行
#####  输出引脚
- Delta Seconds------------------当前帧所用时长（单位是秒）即上一帧与下一帧的间隔时间
游戏主循环：
开始游戏
循环执行  接收输入-->处理游戏逻辑-->渲染-->Sleep（用来稳定帧率）
循环执行的流程执行一次即为一帧

处理游戏逻辑的循环流程
还有未处理的Actor吗-->调用这个Actor上的Tick事件-->标记Actor在本帧处理过了
#### Event End Play/事件结束运行
实际运行时机是角色被销毁之前运行
#### Event Destoryed/被销毁之后运行（显式销毁）
通常需要用Destroy Actor等节点来销毁即显式销毁后才能运行，结束游戏等隐式销毁不会运行
### Actor交互类生命周期
- Event Actor On Clicked/Actor被点击
- Event Actor On Released/Actor结束点击
- Event Actor Begin OverLap/与其他物体开始重叠
- Event Actor End OverLap/与其他物体结束重叠
- Event Actor Begin Cursor Over/鼠标滑动到actor之上悬停
- Event Actor End Cursor Over/鼠标结束悬停
###  Actor视角事件
- On Become View Target/当前相机的视角目标是此actor调用
- On End View Target/当前相机视角不是此actor调用
###  物理命中事件
- Event Hit/命中事件
- Event On Actor Hit/Actor被命中事件
###  伤害类事件生命周期
#### EventAnyDamage/任意伤害事件
任意一种伤害类型触发都会调用，与Apply Damage节点对应，调用后需要有物体通过Apply Damage节点应用伤害
baseDamage必须大于0，否则伤害不会生效
#####  输出引脚
- Damage-------------------------伤害，输出事件造成的伤害值
- Damage Type--------------------伤害类型，输出事件的伤害类型
#### Event Point Damage/点状伤害事件
受到点状伤害后触发，与Apply Point Damage节点对应，调用后需要有物体通过Apply Point Damage节点应用伤害，可以理解为发出射线，碰撞到的物体可以触发伤害，一般子弹伤害为点状伤害
#####  输出引脚
- Hit Info-----------------------可用Hit Break Result节点展开碰撞详细信息
#### Event Radial Damage/放射状伤害事件
受到放射状伤害后触发，与Apply Radial Damage节点或Apply Radial Damage with Falloff节点对应，调用后需要有物体通过Apply Radial Damage节点或Apply Radial Damage with Falloff节点应用伤害，可以理解为向周围发出球形放射状射线，碰撞到的物体可以触发伤害，一般手雷伤害为放射状伤害
###  输入事件
输入事件放在哪里的优先级：
1. 考虑联机扩展
2. APlayer Controller最优先
3. APawn其次
4. AActor EnableInput
5. 随便测试的话可以放关卡蓝图
###  AI事件
#### Event Receive Execute/接收执行事件
一般在Task蓝图中使用，后面连接Task的执行逻辑
###  自定义事件
#### Custom Event/自定义事件
创建自定义事件时，会自动创建一个对应的同名函数，调用函数时触发事件
#####  Graph
- Replicates---------------------复制，设置网络复制类型，和函数相比，这是事件特有的，所以涉及网络复制的，都要用事件，而不是函数
  - Not Replicated-----------------不复制，不进行网络复制
  - Multicast----------------------多播，一般在服务端调用事件，复制到所有客户端
  - Run on Server------------------在服务端运行，仅在服务端运行的事件，客户端不运行
  - Run on owning Client-----------仅在自己客户端运行，不复制到服务端

网络复制要注意避免复制引发的重复对象
一般生成对象都要在服务端运行，要进行Has Authority判定

在客户端射击，复制到客户端，并同步到其他所有客户端的方法：
- 第1步：创建一个服务端射击事件Server-ShootEvent，Replicates设为Run on Server，键盘射击输入触发时调用
- 第2步：创建一个射击多播事件All-ShootEvent,Replicates设为Multicast,服务端射击事件Server-Shoot触发时调用
- 第3步：创建一个射击事件ShootEvent，Replicates设为Not Replicated，写生成子弹等射击执行逻辑，射击多播事件All-ShootEvent触发时调用，调用时要加判断Has Authority，仅在拥有控制权的服务端运行，否则会生成重复对象
RPC（Remote Procedure Call）

从服务器调用的RPC
Actor所有权---------Not Replicated----NetMulticast------------------Run on Server----Run on owning Client
Client-owned actor--在服务器上运行----在服务器和所有客户端上运行----在服务器上运行---在actor的所属客户端上运行
Server-owned actor--在服务器上运行----在服务器和所有客户端上运行----在服务器上运行---在服务器上运行
Unowned actor-------在服务器上运行----在服务器和所有客户端上运行----在服务器上运行---在服务器上运行

从客户端调用的 RPC
Actor所有权------------------Not Replicated--------------NetMulticast------------------Run on Server----Run on owning Client
Owned by invoking client-----在执行调用的客户端上运行----在执行调用的客户端上运行------在服务器上运行---在执行调用的客户端上运行
Owned by a different client--在执行调用的客户端上运行----在执行调用的客户端上运行------丢弃-------------在执行调用的客户端上运行
Server-owned actor-----------在执行调用的客户端上运行----在执行调用的客户端上运行------丢弃-------------在执行调用的客户端上运行
Unowned actor----------------在执行调用的客户端上运行----在执行调用的客户端上运行------丢弃-------------在执行调用的客户端上运行

- Reliable-----------------------可靠性，勾选可靠性，数据不会丢失，RPC会立刻发出，适合重要事件。不勾选，数据可能会丢失，适合表现相关的事件

循环中一定要避免Reliable，否则瞬间数据量过大，占用大量网络资源



###  AI
#### AI Move To/AI移动到
给AI角色添加自动寻路的主节点，只要受AIController控制的角色都可以使用，包括玩家角色。可以进行自动寻路

注意它是任务节点

#####  输入引脚
- Pawn---------------------------自动寻路的角色
- Destination--------------------目标位置
- Target Actor-------------------目标Actor，如果是跟随角色，可以在这里传入
- Acceptance Radius--------------可接受半径，距离目标点距离在这里设定的范围之内，就判定为已成功移动到目标点
- Stop on Overlap----------------重叠时停止，当寻路角色发生重叠时停止移动，一般都要勾选，防止卡在障碍物中
#### Run Behavior Tree/运行行为树
运行指定的行为树，函数目标是AIController
#### Use Blackboard/使用黑板
使Al使用指定的黑板资产来控制AI的行为，如果黑板不存在，则创建一个黑板组件
#####  Behavior Tree
###### Finish Execute/完成执行
在Task蓝图中使用，完成当前Task，并返回一个布尔值
#####  Components
###### Is Falling/正在掉落
判断Pawn是不是正在掉落，如果正在掉落，说明Pawn在空中，不在地面上，可以用这个节点在动画蓝图里控制跳跃动画播放
- 输入引脚
  - Target-------------------------目标，需要连接Movement组件，通常使用Get Movement Component节点
- 输出引脚
  - Return Value-------------------输出一个布尔值，正在掉落为真，否则为假
##### Blackboard
###### Set Value as Object/设置对象值
设置黑板中的对象类型的变量值
 - 输入引脚
  - Target-------------------------目标，连接对象值所在的黑板
  - Key Name-----------------------变量的名字
  - Object Value-------------------对象值
#####  Navigation
###### Get Random Location In Navigable Radius/获取可导航半径内的随机位置
获取一个能导航到的随机点，可以通过Move To节点移动过去，使AI达到自动巡逻的效果
 - 输入引脚
  - Origin-------------------------起点，一般获取对象位置传入
  - Radius-------------------------半径，在多大的范围内寻找随机点
  - Nav Data-----------------------Nav数据，默认即可，一般不用传入节点
  - Filter Class-------------------过滤器类
#####  Tasks
###### Move To Location or Actor/移动到位置或Actor
功能和AI Move To功能相同，可以为移动设定一个目标位置或跟随一个Actor

###  Animation
#### Play Anim Montage/播放动画蒙太奇
用来执行动画蒙太奇，一般输入执行端口连接到按键的动作事件的Pressed输出执行端口，Anim Montage中选择动画蒙太奇，它的目标是Character，它可以自动识别Character中的默认Mesh，只能播放默认Mesh的动画蒙太奇

如果对象有动画蓝图，要在动画蓝图中添加插槽，否则没有效果
#### Set Play Rate/设置播放速度
用来设置动画、动画蒙太奇、时间线等的播放速度
#### Stop Anim Montage/停止播放动画蒙太奇
用来停止动画蒙太奇，一般输入执行端口连接到按键的动作事件的Released输出执行端口，Anim Montage中选择动画蒙太奇
#### Try Get Pawn Owner/尝试获取Pawn的拥有者
一般在动画蓝图中使用（动画蓝图默认自带节点），用来尝试获取绑定的Pawn
#####  Montage
###### Play Montage/播放蒙太奇
可以自行选择带骨骼的模型和蒙太奇资源，参数很多很方便，但是只能在事件图表中使用，无法在函数中使用

###  Appearance/外观
#### Get Dynamic Material/获取动态材质
获得设置的材质中的动态参数，有两个节点，目标分别是边界框和图片，根据需要使用节点

需要在材质中开放Parameter接口，才可以获取到，返回动态材质对象

#### Set Brush/设置笔刷
有两个设置笔刷节点，目标分别是边界框和图片，根据需要使用节点
#####  输入引脚
- Target-------------------------目标，分清楚目标是边界框还是图片，根据需要使用
- In Brush-----------------------设置笔刷，可以右键展开引脚
  - In Brush Image Size------------笔刷图片尺寸
  - In Brush Tint------------------笔刷着色
  - In Brush Image-----------------笔刷图片
#### Set Padding/设置填充
设置UMG组件等的填充位置
#####  输入引脚
- In Padding---------------------输入填充，可以展开引脚，手动设置填充距顶部、底部、左侧、右侧的距离

###  Asset Data/资产数据
#### Get Asset/获取资产
从Asset Data获取Object

###  Asset Registry/资产注册表
资源注册表是一个编辑器子系统，它在编辑器加载时异步收集有关未加载的资源的信息。该信息存储在内存中，这样，编辑器无需加载它们就可以创建资源列表。该信息是权威信息，当资源在内存中被更改或文件在磁盘上被更改时，它会自动更新。此系统主要由内容浏览器使用，但是也可能会在编辑器代码的任意位置被使用
#### Get Asset Registry/获取资产注册表
在蓝图中调用资产注册表表的基础函数，获取资产注册表，作为目标，供资产注册表相关的其他函数使用
#### Get Assets by Object Path/按对象路径获取资产
根据对象路径获取资产数据，会返回一个Assets Data的结构体，可以展开，里面包括对象路径，资源包名称、路径，资产名称和资产类名称
#####  输入引脚
- Target-------------------------目标，需要连接Get Asset Registry节点
- Object Path--------------------对象路径，即对象在虚幻工程中存储的位置

###  Audio/音频
#### Play Sound 2D/播放2D声音
最简单的播放音频节点，可以用来播放背景音乐，可以调节音量大小，音频播放范围等，它没有衰减，常用于播放背景音乐和UI界面音效
#### Play Sound at Location/在位置播放声音
用来在场景中某个位置播放声音，可以调节位置衰减

###  Camera/相机
#### Get Camera Location/获取相机位置

###  Character/角色
#### Launch Character/弹射角色
将角色弹射出去。它在角色上设置挂起的发射速度。此速度将在下一个CharacterMovementComponent标记处处理。并将其设置为“下降”状态。触发OnLaunched事件
#####  输入引脚
- Target-------------------------目标
- Launch Velocity----------------弹射速度
- XYOverride---------------------XY方向覆盖，勾选后可以不受导航网格影响，弹射效果更真实
- ZOverride----------------------Z方向覆盖，勾选后可以不受导航网格影响，弹射效果更真实

###  Components/组件
#### Destroy Component/销毁组件
用来销毁组件，如停止开枪后，消除枪口火焰
#### Get Visibility/获取可视性
获取组件的可视性，会返回一个枚举值，可以用Equal节点来判断可视性
#####  Flipbook
###### Get Flipbook Length/获取2D序列动画的时长
单位是秒
###### Get Flipbook Length in Frames/获取2D序列动画的时长帧
单位是帧
#####  Skeletal Mesh
###### Get Anim Instance(Mesh)/获取动画实例
用来调用与骨骼网格体绑定的动画蓝图等动画文件，一般使用此节点后进行类型转换，获取需要调用的动画文件

###  Collision/碰撞
#### Break Hit Result/碰撞命中结果
获取射线碰撞结果的各项数据
#####  输出引脚
- Time---------------------------沿着射线方向多长发生碰撞事件（0,1），0设置开始的位置，1为射线结束的位置，要注意返回1是没有命中
- Distance-----------------------返回射线起始点到检测到物体（hit）的距离
- Location-----------------------检测到的hit的世界空间坐标位置
- Hit Actor----------------------检测到的物体的actor对象引用

#### Line Trace By Channel/由通道检测线条
非常重要的节点。从起点到终点发出追踪射线，可以用作射击效果
#####  输入引脚
- Start--------------------------射线起始点，在制作射击效果时一般是从当前摄像机的位置起始
- End----------------------------射线结束点，在制作射击效果时，先获得当前控制器的朝向，转化成向量后再乘以射程，再加上起始点
- Trace Channel------------------检测通道，可见性和摄像机两种，还可以自定义通道
- Trace Complex------------------是否针对复杂碰撞进行测试，false针对简单碰撞进行测试
- Actors to Ignore---------------忽略的角色，要设定不击中队友和自己，要在这里设置
- Draw Debug Type----------------绘制调试类型
  - Persistent---------------------持续的
- Ignore Self--------------------忽略自身
#####  输出引脚
- Out Hit------------------------一般连接Break Hit Result获取碰撞数据
- Return Value-------------------返回值

#### Multi Line Trace By Channel/由通道检测多线条
通过检测通道获取多个物体

与Line Trace By Channel的区别：
- Line Trace By Channel发出射线后只识别第一个碰到的物体
- Multi Line Trace By Channel可以射线碰到第一个物体之后，再继续和后面的物体发生碰撞
#### Line Trace By Profile/由描述文件检测线条
#### Multi Line Trace By Profile/由描述文件检测多线条
#### Line Trace For Objects/对象的线条检测
根据对象类型检测射线碰撞，射线只会碰撞Object Types设定好的对象类型
#### Multi Line Trace For Objects/对象的多线条检测
根据对象类型检测射线碰撞的多个物体

#### Sphere Trace By Channel/由通道检测球状射线
会以起点为球心，输入半径为半径的球形空间中发出射线，检测碰撞
##### 输入引脚
- Start--------------------------球形空间起始点，在AI自动寻找敌人效果时一般是从当前AI的位置起始
- End----------------------------没有实际意义，设置的与起始点不同就可以
- Radius-------------------------半径，球形检测半径
- Trace Channel------------------检测通道，可见性和摄像机两种，还可以自定义通道
- Trace Complex------------------是否针对复杂碰撞进行测试，false针对简单碰撞进行测试
- Actors to Ignore---------------忽略的角色
- Draw Debug Type----------------绘制调试类型
  - Persistent---------------------持续的
- Ignore Self--------------------忽略自身
##### 输出引脚
- Out Hit------------------------一般连接Break Hit Result获取碰撞数据
- Return Value-------------------返回值

#### Multi Sphere Trace By Channel/由通道检测多重球状射线
会以起点到终点形成的设置半径为半径的球形空间中发出多重射线，检测碰撞
常用来作为AI自动寻找敌人的检测逻辑

#### Set Collision Response to Channel/设置按通道追踪的碰撞响应
射击游戏中给敌人设置被击中时在Construction Script中使用这个节点

###  Data Table/数据表格
#### Get Data Table Row Names/获取数据表行名称
从数据表格中获取所有的行名称，输出一个数组
#### Evaluate Curve Table Row/计算曲线表行
从曲线图表中获取行数据

### Development
#### Execute Console Command/执行控制台命令
可以在游戏中动态执行控制台命令，例如可以用这个命令在网游游戏中切换地图，但是此节点只有打包后才能把所有玩家都切换到新地图，编辑器中只能移动服务端角色
##### 输入引脚
- Command------------------------命令
- Specific Player----------------特殊玩家，连接特定玩家的PlayerController节点，就仅对特定玩家生效

切换地图的方法：
- 第1步：创建一个UI，添加一个ComboBox控件，把关卡名作为选项
- 第2步：使用Format Text节点连接到Execute Console Command节点
- 第3步：Format Text节点输入ServerTravel {Map}?listen  （注意空格）
- 第4步：用Get Selected Option获取选项，连接到Map端口

通过Ip加入游戏房间的方法：
在UI上加入游戏按钮点击事件连接Execute Console Command节点，命令中输入open 127.0.0.1:端口名，如果使用的默认端口，可以不用输入:端口

###  Dynamic Entry Box/动态条目框
在UMG系统中，使用Dynamic Entry Box动态添加条目时使用
#### Create Entry/创建条目
要在Dynamic Entry Box的Entry Layout-->Entry Widget Class中选择要使用的条目控件才能生效。Create Entry节点会返回一个User Widget对象，可以类型转换成对应的用户控件进行赋值
#### Create Entry of Class/从类创建条目
和Create Entry功能相同，选择一个类，创建条目后不需要再进行类型转换
#### Get All Entries/获取所有条目
获取动态条目框的所有条目，返回一个用户控件对象数组
#### Get Num Entries/获取条目数量
获取动态条目框的条目数量
#### Remove Entry/移除条目
#### Reset/重置
移除所有条目

###  Effect
#####  Components
##### Activation
###### Toggle Active/切换动作开关
控制粒子等物体激活和关闭
##### Particle System
###### Spawn Emitter Attached/附加的产卵发射器
可以附在一个对象上的产卵发射器，用来生成粒子特效，如枪口火焰等
###### Spawn Emitter at Location/基于位置的产卵发射器
在设定的位置上生成产卵发射器

###  Game
#### Construct Object from Class/从类构造对象
选择一个类生成对象，以Object为父类的所有类都可以通过这个节点生成，包括非Actor类、用户控件类等
#####  输入引脚
- Class--------------------------选择类
- Outer--------------------------设置构造的对象的拥有者，一般连接Self即可
#####  输出引脚
- Return Value-------------------返回生成的对象
#### Get Current Level Name/获取当前关卡名
#### Get Game Instance/获取游戏实例
获取后一般进行类型转换，获取到创建的游戏实例
#### Get Player Camera Manager/获取玩家相机控制器
获取玩家当前视口对应的相机

Player Camera Manager类是一个摄像机管理器。默认情况下，其自身内置行为与待查看目标和由控制台命令触发的调试摄像机混合。否则，它会查询ViewTarget，以确定如何调整摄像机的视角，以及所有其它摄像机设置

#### Get Player Character/获得玩家角色
在添加AI自动寻找玩家时，需要使用这个节点来获取玩家角色位置
#### Get Player Controller/获得玩家控制器
在一个Pawn中获取玩家的控制器，从V层获取C层，注意是获得的当前玩家的Controller，有可能不是当前角色的Controller
#### Get Player Pawn/获得玩家Pawn
获取玩家的Pawn角色
#### Get Streaming Level/获取正在流送的关卡
通过流送关卡的关卡名来获取流送关卡
#### Is Level Loaded/关卡已加载
判断流送关卡是否已经加载完成，返回一个布尔值
#### Load Stream Level(by Name)/读取流送关卡（根据名字）
根据关卡名加载关卡流送，用来切换关卡，可以异步加载关卡，即在不影响当前关卡运行的同时，后台加载新关卡数据，如果有数据是多个关卡都需要使用的，切换关卡一般使用关卡流送，需要先将关卡设为流送关卡，否则没有效果。关卡流送见Unreal Engine笔记
#####  输入引脚
- Level Name---------------------输入要流送的关卡名
- Absolute-----------------------勾选的话，设置会重置，不勾选会沿用当前关卡的设置
- Options------------------------输入要使用的设置
#### Load Stream Level(by Object Reference)/读取流送关卡（根据对象路径）
选择关卡资产加载关卡流送，用来切换关卡，可以异步加载关卡，即在不影响当前关卡运行的同时，后台加载新关卡数据，如果有数据是多个关卡都需要使用的，切换关卡一般使用关卡流送，关卡流送见Unreal Engine笔记
#### Open Level(by Name)/打开关卡（根据名字）
根据关卡名，打开另一个关卡，当前关卡会销毁，只能同步加载关卡，释放（卸载）原有老关卡，加载并显示新关卡、同步函数，如果数据量过大，会导致性能下降
#####  输入引脚
- Level Name---------------------输入要打开的关卡名
- Absolute-----------------------勾选的话，设置会重置，不勾选会沿用当前关卡的设置
- Options------------------------输入要使用的设置
#### Open Level(by Object Reference)/打开关卡（根据对象路径）
选择关卡资源，打开另一个关卡，当前关卡会销毁，与Open Level(by Name)功能相同，使用起来更方便，只能同步加载关卡
#### Quit Game/退出游戏
#### Spawn Actor From Class/从类生成Actor
很重要的节点，用来在游戏中生成角色

注意：游戏中频繁创建和销毁的对象，会导致大量的内存消耗，产生GC（Garbage Collection），并产生内存碎片，最后直接卡死，要使用对象池来缓存对象

把Actor中的参数设为公开和生成时赋值，可以利用这个节点传参
#####  输入引脚
- Class--------------------------选择要生成的类
- Spawn Transform----------------设置生成的Actor的移动旋转缩放
- Collision Handing Override-----设置生成的Actor的碰撞覆盖
#### Set Game Paused/设置游戏暂停
#### Suggest Projectile Velocity Custom Arc/建议发射物速度自定义弧形
输入起始位置和结束位置，会计算发射物从起始位置静止状态抛射出后，到结束为止着陆所需的发射速度
##### 输入引脚
- Start Pos----------------------起始位置
- End Pos------------------------结束位置
- Override Gravity Z-------------覆盖Z方向重力
- Arc Param----------------------弧形参数，0为0度，1为90度，0.5为45度
##### 输出引脚
- Out Launch Velocity------------发射速度

#### Unload Stream Level(by Name)/卸载流送关卡（根据名字）
用来卸载流送关卡，一般在不同的流送关卡切换时，在新关卡异步加载结束后，使用此节点卸载旧的流送关卡
#### Unload Stream Level(by Object Reference)/卸载流送关卡（根据对象路径）
用来卸载流送关卡，一般在不同的流送关卡切换时，在新关卡异步加载结束后，使用此节点卸载旧的流送关卡

#####  Damage
###### Apply Damage/应用伤害
与Event Any Damage对应
- 输入引脚
  - Damaged Actor------------------被伤害的Actor，伤害应用到哪个Actor上
  - Base Damage--------------------基础伤害，受到的基础伤害值
###### Apply Point Damage/应用点状伤害
与Event Point Damage对应
###### Apply Radial Damage/应用放射状伤害
与Event Radial Damage对应
放射状伤害不用设置造成伤害的目标 所有的可受伤害的物体 只要在半径范围之内 都会接受到伤害事件
###### Apply Radial Damage with Falloff/应用带衰减的放射状伤害
与Event Radial Damage对应
#####  Player
###### Convert Mouse Location To WorldSpace/将鼠标位置转换为场景空间
很重要，可以获取鼠标点击的位置，并转换为实际的场景坐标
- 输入引脚
  - Target-------------------------连接获取和转换好的对应的Player Controller
- 输出引脚
  - World Location-----------------鼠标点击的位置
  - World Direction----------------鼠标点击位置的方向向量
  - Return Value-------------------是否转换成功

###### Convert Screen Location To World Location/将屏幕位置转换为场景位置
很重要，2D和3D位置信息转换的渠道
  - Target-------------------------连接获取和转换好的对应的Player Controller
  - Screen X-----------------------屏幕坐标系X轴坐标
  - Screen Y-----------------------屏幕坐标系Y轴坐标
- 输出引脚
  - World Location-----------------3D空间的世界位置
  - World Direction----------------3D空间的世界方向
  - Return Value-------------------是否转换成功

###### Convert World Location To Screen Location/将场景位置转换为屏幕位置
很重要，2D和3D位置信息转换的渠道
- 输入引脚
  - Target-------------------------连接获取和转换好的对应的Player Controller
  - World Location-----------------3D空间的世界位置
- 输出引脚
  - Screen Location----------------2D空间的屏幕位置，输出的是一个二维向量，代表屏幕空间的XY两个轴向
  - Return Value-------------------是否转换成功

###### Is Input Key Down/按输入键
检测是否按了鼠标或键盘或手柄、摇杆、手机按键等输入设备的某个键，目标是Player Controller，输出一个布尔值

###  Input/输入
#### Enable Input/允许输入
使用Enable Input节点使蓝图中的输入事件生效
#### Disable Input/禁止输入
使用Disable Input节点使蓝图中的输入事件失效，防止误操作
#### Set Input Mode Game And UI/设置输入模式游戏和UI
游戏输入和UI输入同时有效，默认即如此，如果不和下面两个节点配合，一般不使用此节点
##### 输入引脚
- Player Controller--------------连接Player Controller
- In Widget to Focus-------------选择UI控件，只有特定的UI控件输入有效，可以不选择，不选择就是所有的UI输入都有效
- In Mouse Lock Mode-------------锁定光标
  - Do Not Lock--------------------不锁定
  - Lock Always--------------------始终锁定光标，光标不会超出游戏画面范围
#### Set Input Mode Game Only/设置仅输入模式游戏
只有游戏输入有效，UI输入无效
#### Set Input Mode UI Only/设置仅输入模式UI
只有UI输入有效，游戏输入无效
##### Action Event/动作事件
在项目设置中添加的动作事件，动作事件有两个输出执行端口，分别为按下按键和松开按键，一般用来用于动画蒙太奇，比如开火、瞄准等
##### Axis Event/坐标轴事件
在项目设置中添加的坐标轴事件，坐标轴事件只有一个输出执行端口，前进后退向左向右按键绑定都是坐标轴事件

### Invalidation Box/无效框
控制UMG系统中的无效框控件的节点
#### Get Can Cache/获取可以缓存状态
#### Set Can Cache/设置可以缓存状态

### Layout/布局
#####  Canvas Slot/画布插槽
###### Set Layout/设置布局
设置插槽的布局数据
- 输入引脚
  - Target-------------------------连接Canvas Panel Slot对象，可以用Slot as Canvas Slot节点获取
  - In Layout Data-----------------布局数据，可以右键展开
- \>
- In Layout Data Offsets---------锚点偏移量
- In Layout Data Anchors---------锚点位置，展开后分为最大和最小的XY两个轴向的偏移量，指的是UMG控件中锚点菊花标志的四个花瓣的偏移量，最左为0，居中为0.5，最右为1
- In Layout Data Alignment-------锚点对齐模式，(0.5,0.5)为居中

###  List View/列表视图
UMG系统中List View控件的相关节点
#### Add Item/添加元素

###  Math
#####  Conversions/转换
###### To Quaternion(Vector)/为四元数（向量）
把向量转换为四元数，四元数是个四维数，通常用来计算旋转，可以转为旋转体
#####  Date Time/日期 时间
###### Now/现在
获取当前的系统日期和系统时间
###### Today/今天
获取当前的系统日期
#####  Float/浮点数
###### Nearly Equal(float)/近似等于
判断A和B是否近似相等，可以设定近似的范围，返回布尔值
#####  Interpolation/插值
###### FInterp To/浮点插值
将输入的浮点数值基于步长和速度，输出接近（或等于）目标值的新浮点数值
- 输入引脚
  - Current------------------------当前传入的浮点值
  - Target-------------------------目标值
  - Delta Time---------------------帧时间差，上一帧与下一帧的间隔时间
  - Interp Speed-------------------插值速度，插值步进到目标值的速度，数值越大速度越快，0为不动，不能为负数
- 输出引脚
  - Return Value-------------------输出接近（或等于）目标值的插值浮点值
###### FInterp To Constant/浮点插值到常数
在常数时间差内，将输入的浮点数值基于步长和速度，输出接近（或等于）目标值的新浮点数值
###### VInterp To/向量插值
用法和FInterp To类似
###### Rinterp To/旋转插值
用法和FInterp To类似
#####  Random/随机
###### Random Float In Range/在范围内生成随机浮点数
###### Random Integer in Range/在范围内生成随机整数
是真随机数
###### Random Integet in Range from Stream/从随机流中生成设定范围内的随机整数
注意，随机是由随机流控制的，随机流如果是固定值，则生成的是伪随机数，可以用时间来控制随机流的随机种子
###### Random Unit Vector in Cone in Radians/以弧度表示的圆锥中的随机单位向量
会根据输入的圆锥顶点和半角弧度生成一个随机的方向单位向量
- 输入引脚
  - Cone Dir----------------------传入一个表示方向的单位向量，作为圆锥的顶点和圆锥的方向
  - Cone Half Angle in Radians----圆锥的半角弧度，来确定圆锥的大小
可以用来生成射击的弹着点的随机偏移
Cone Dir传入射击方向，用配置的圆盘半径除以枪的射程，传入Cone Half Angle in Radians，输出作为射击方向

#####  Rotator/旋转
###### Break Rotator
断开旋转值，将旋转数据拆分成R、P、Y单独的值
###### CombineRotators
将两个Rotator合并
###### Find Look at Rotation/寻找查看旋转
非常重要和好用的节点，从起始点开始旋转到目标点，输出一个旋转值（Rotator）
###### Make Rotator
Rotator也是一个向量，包含Roll,Pitch,Yaw三个维度，顺时针旋转为正值，逆时针旋转为负值，Rotator（0,0,0）=Vector（1,0,0）
#####  Transform/转换
###### Transform Location/转换位置
传入一个Location值，可以将对象的坐标基于Location值转换。如果Location值为0，即将相对坐标转为世界坐标
- 输入引脚
  - T------------------------------传入一个Transform值，可以将Transform中的位置信息基于Location值转换
  - Location-----------------------传入一个Location值，转换时基于这个点，如果为0，即将相对坐标转为世界坐标
- 输出引脚
  - Return Value-------------------返回转换后的坐标
#####  Trig/三角函数
###### Sin(Degrees)/正弦（角度）
###### Sin(Radians)/正弦（弧度）
#####  Vector/向量
Vector向量在UE4中既可以表示方向和大小（ForwardVector）也可以表示位置(Location)
任何一个位置，都可以表示为从（0,0,0）点出发的一条向量
###### Break Vector/拆分向量
###### Cross Product/向量叉乘
两个向量叉乘结果是同时垂直于它们的向量，用来获得两个向量所在平面的法向量
###### Distance(Vector)/距离（向量）
获取两个向量之间的距离，即两个向量相减取模
###### Dot Product/向量点乘
两个向量点乘，主要用来求两个向量夹角，还可以判断方向，点乘结果为正，两向量夹角小于180度，即同向，点乘结果为负，两向量夹角大于180度，即不同向
a·b=∣a∣∣b∣cosθ
###### Get Forward Vector/获取向前向量
将Rotator转化为Vector，即获取Actor前方的单位向量，即获取Actor的朝向
###### Get Right Vector/获取向右向量
将Rotator的Yaw正向旋转90度后转化为Vector，即获取Actor向右方的单位向量
###### Get Up Vector/获取向上向量
即获取Actor向上方的单位向量
###### Is Unit(Vector)/为单位（向量）
判断向量是不是单位向量
###### Is Uniform(Vector)/为统一（向量）
判断向量是不是XYZ3个方向相同
###### Lerp(Vector)/插值（向量）
使用非常频繁，求AB两个向量的插值
###### Make Rot from X/利用X创建旋转
从X轴正向开始旋转到输入向量的旋转值，可以让物体很方便地沿着Y轴或Z轴旋转，沿X轴旋转设置不方便，但是一般角色不会沿X轴旋转，因为人物不会侧空翻
###### Make Vector/创建向量
由3个浮点数输入XYZ创建一个向量
###### Normalize
将向量标准化，即长度改为单位长度
###### Rotation From Axis and Angle/轴和角中的旋转体
由一个轴向和一个角度创建旋转体，即某个轴旋转多少角度
如（1,0,0）旋转30度，是X轴旋转30度，X轴旋转是绕着Z轴旋转的，所以创建的旋转体是（0,0,30）
###### Rotation From X Vector/X向量中的旋转

###### Vector Length/向量长度
对向量取模，求它的长度
###### Vector+Vector
两个向量相加
###### Vector*Float
向量与浮点数相乘

###  Media
####  Media Player
##### Close/关闭
关闭视频播放器
##### Open Source/打开来源
打开视频资源，Media Player连接这个节点，选择好要播放的视频，才可以正常播放
##### Pause/暂停
暂停视频
##### Play/播放
播放视频

### Menu Anchor/菜单锚
Menu Anchor是UMG系统的控件，可以指定组件作为弹出式菜单，固定到锚点位置，并从该位置调用
#### Close/关闭
关闭菜单
#### Open/打开
打开菜单


###  Montage Play
#### Montage Play/蒙太奇播放

###  Networking
#### Has Authority/拥有网络控制权
判断当前对象对目标对象是否有网络控制权，返回一个布尔值

在网游中，由当前进程创建的Actor，对其拥有网络控制权

#### Is Dedicated Server/是专用服务器
判断是否是专用服务器，在创建UI时一般要判断，因为专用服务器不能创建UI
#### Switch Has Authority/拥有网络控制权开关
一个宏，就是把Has Authority和Branch封装成一个Switch节点，方便使用

###  Online
####  Session/会话
##### Create Session/创建会话
创建一个包含默认在线子系统的会话，即网游中创建房间功能
- 输入引脚
  - Player Controller--------------对应的玩家控制器
  - Public Connections-------------公开连接数，相当于房间最大玩家人数
  - Use LAN------------------------是否使用局域网
- 输出引脚
  - On Success---------------------创建成功的后续执行逻辑
  - On Failure---------------------创建失败的后续执行逻辑
##### Find Sessions/寻找会话
寻找网络中已创建的会话
- 输入引脚
  - Player Controller--------------对应的玩家控制器
  - Max Results--------------------查找的最大结果数，即查找到多少个会话后停止查找
  - Use LAN------------------------是否使用局域网
- 输出引脚
  - On Success---------------------查找成功的后续执行逻辑
  - On Failure---------------------查找失败的后续执行逻辑
  - Results------------------------查找到的会话数组
##### Join Session/加入会话
加入选定的会话，即网游中的加入房间功能，一般要先寻找会话，而后再加入会话
- 输入引脚
  - Player Controller--------------对应的玩家控制器
  - Search Results-----------------输入查找到的会话结果
- 输出引脚
  - On Success---------------------加入成功的后续执行逻辑
  - On Failure---------------------加入失败的后续执行逻辑

###  Pawn
#### Detach from Controller Pending Destroy/脱离控制器控制
让蓝图角色不再受蓝图控制器控制
#### Get Controlled Pawn/获取受控制的Pawn
在Controller类蓝图中使用，用来获取控制的Pawn，例如在AIController类蓝图中给AI角色添加自动寻路等功能
#### Get Controller/获取控制器
获取Pawn的控制器，注意目标Pawn如果不是当前玩家的角色，那么获取到的控制器就不是当前玩家的玩家控制器
#### Get Control Rotation/获得控制器的方向
用这个节点来获取控制器当前的朝向
#### Is Locally Controlled/是否受本地控制
检测Pawn是受本地控制还是网络控制，如果本地控制，则返回True
例如可以在网游中通过这个节点来设定自己是第一人称，在别的客户端显示为第三人称
#### Posses/控制
通常在PlayerController中使用，用来控制Pawn
#### Unposses/接触控制
通常在PlayerController中使用，用来解除对Pawn的控制
#####  input
###### Add Controller Pitch Input/添加控制器Y轴旋转
常用来控制角色上下看
###### Add Controller Yaw Input/添加控制器Z轴旋转
常用来控制角色左右看
###### Add Movement Input/添加移动输入
获取Movement组件的移动输入，一般和坐标轴事件连接
- 输入引脚
  - Target-------------------------选择移动的对象
  - World Direction----------------设置移动方向
  - Scale Value--------------------设置移动的值，一般用坐标轴事件的Axis Value输入
  - Force--------------------------强制移动
###### Consume Movement Input Vector/消耗移动输入向量
返回输入的移动向量值，可以输出给场景中的Pown，并清零，防止累加


### Physics
需要开启Simulate Physics（模拟物理）才有作用
#### Add Force/添加作用力
给物体施加作用力，单位：牛顿
如果有重力时要抬起物体，需要持续施加力，用Tick
AddForce可以理解为给予物体一个可持续的力，一般用于模拟真实物理
#### Add Impulse/添加冲量
瞬间的冲量
Impulse可以理解为给物体一个瞬间的冲击力，一般用于碰撞或者爆炸
#### Add Radial Force/添加径向力
给物体施加径向作用力，做爆炸效果可以用径向力
#### Add Radial Impulse/添加径向冲量
给物体一个瞬间的径向冲击力，一般用于碰撞或者爆炸
- 输入引脚
  - Target-------------------------接受冲击力的对象，需要是实体的组件才可以接受冲击力
  - Origin-------------------------冲击点
  - Radius-------------------------冲击半径
  - Strength-----------------------冲击力大小
  - Falloff------------------------衰减方式
- RIF Constant-----------------常量，无衰减
- RIF Linear-------------------线性衰减
#### Put Rigid Body to Sleep/催眠刚体
让刚体不受重力等的影响，类似于C4D中的碰撞体
#### Set Physics Angular Velocity/设置物理角速度
设置物体的角速度
#### Set Physics Linear Velocity/设置物理线速度
设置物体的线速度
#### Wake Rigid Body/唤醒刚体
让催眠的刚体重新受到重力等力的影响


###  Rendering
#### Set Visibility/设置可见性
#####  Components
##### Decal
###### Set Fade Screen Size/设置衰退屏幕尺寸
设置贴花根据距离渐隐
###### Spawn Decal at Location/在位置生成贴花
动态生成贴花效果，可以用来制作子弹击中墙壁后的弹孔
##### Light
###### Set Light Color/设置灯光颜色
在蓝图中控制灯光颜色
#####  Material
###### Set Material/设置材质
目标是初始组件，用来在游戏中给组件动态设置材质
###### Set Vector Parameter Value/设置向量参数值
在蓝图中设置材质的向量Parameter参数

### Save Game/保存游戏
#### Async Load Game from Slot/从槽位异步加载游戏
从选定的存档插槽中异步加载游戏存档
#####  输入引脚
- Slot Name----------------------输入要加载的存档插槽名
#####  输出引脚
- Exec---------------------------输出执行引脚，同时执行的逻辑
- Completed Exec-----------------加载游戏完成时调用的逻辑
- Save Game----------------------返回Save Game Object对象
- Success------------------------返回是否加载成功的布尔值
#### Async Save Game to Slot/将游戏异步保存到槽位
把当前游戏数据异步存档到选定的存档槽位
##### 输入引脚
- Save Game Object---------------选择Save Game Object对象
- Slot Name----------------------输入要保存到的存档插槽名
##### 输出引脚
- Exec---------------------------输出执行引脚，同时执行的逻辑
- Completed Exec-----------------保存游戏完成时调用的逻辑
- Save Game----------------------返回Save Game Object对象
- Success------------------------返回是否保存成功的布尔值
#### Create Save Game Object/创建游戏存档对象
从输入的Save Game类中创建一个空白的Save Game Object对象来设置和缓存对象
##### 输入引脚
- Save Game Class----------------输入Save Game类
##### 输出引脚
- Return Value-------------------返回Save Game Object对象
#### Delete Game in Slot/删除插槽中的游戏
删除选定的存档插槽中的游戏存档
##### 输入引脚
- Slot Name----------------------输入要删除的存档插槽名
##### 输出引脚
- Return Value-------------------返回一个布尔值，判断存档是否删除成功
#### Does Save Game Exist/游戏存档存在
检查游戏存档是否以指定的命名存在
##### 输入引脚
- Slot Name----------------------输入存档插槽名
##### 输出引脚
- Return Value-------------------返回一个布尔值，判断存档是否存在
#### Load Game from Slot/从插槽加载游戏
从给定的存档插槽中加载游戏数据，返回一个Save Game Object对象，在获取数据的时候需要连一个类型转换
##### 输入引脚
- Slot Name----------------------输入存档插槽名
##### 输出引脚
- Return Value-------------------返回Save Game Object对象
#### Save Game to Slot/将游戏保存到插槽
把Save Game Object中缓存的数据保存到存档插槽，输出到磁盘文件中
##### 输入引脚
- Save Game Object---------------选择Save Game Object对象
- Slot Name----------------------输入存档插槽名
##### 输出引脚
- Return Value-------------------是否存储成功，返回一个布尔值


### Settings/设置
#### Apply Settings/应用设置
将所有当前用户设置应用于游戏并保存到持久化存储中，目标是User Settings对象
#### Get Game User Settings/获取游戏用户设置
获取游戏本地机器设置（分辨率、窗口模式、可伸缩性等），返回一个User Settings对象
#### Load Settings/读取设置
从持久化存储中加载游戏设置，目标是User Settings对象
#### Set Screen Resolution/设置屏幕分辨率
设置游戏屏幕分辨率的用户设置，以像素为单位，目标是User Settings对象

设置游戏屏幕分辨率方法：
- 第1步：使用Get Game User Settings节点获取User Settings对象
- 第2步：连接Load Settings节点，读取User Settings对象中的游戏设置
- 第3步：使用Set Screen Resolution节点，设置分辨率
- 第4步：使用Apply Settings节点，应用修改的设置

### Slot/插槽
#### Slot as Canvas Slot/插槽为画布插槽
获取目标子控件的插槽对象作为画布插槽，可以用来操作布局信息

### Spline/样条
#### Get Location at Distance Along Spline/获取样条的距离位置
获取样条线上某个位置的坐标数据
#### Get Rotation at Distance Along Spline/获取样条的距离旋转
获取样条线上某个位置的旋转数据
#### Get Spline Length/获取样条长度
读取样条线的长度数据

### Sprite/精灵
Paper2D相关节点
#### Set Flipbook/设置序列
重新设置Sprite组件中的Source Flipbook资源，一般用来切换动画，用Branch判断来切换2D人物Idle和Run等状态
#### Set Sprite Color/设置精灵颜色
设置精灵资源显示颜色，比如设置角色碰到怪物后变红

### Utilities
#### Actor Has Tag/Actor拥有标签
检查Actor是否有某个标签
- 输入引脚
  - Target-------------------------连接要检查的Actor
  - Tag----------------------------输入判断的标签
- 输出引脚
  - Return Value-------------------输出一个布尔值
#### Async Load Asset/异步加载资产
异步加载软对象引用，如果加载成功，则返回正确类型的对象，即在后台加载资产
#### Destroy Actor/销毁对象
从内存中销毁对象，慎重使用，频繁的销毁会导致大量的内存消耗，产生GC（Garbage Collection），并产生内存碎片，最后直接卡死，一般要使用对象池来缓存对象
#### Equal(Class)
快捷键=，类的相等
#### Get Class
获取对象的类
#### Get Data Table Row/获取数据表格行
需要选择一个数据表格，输入行名字，输出行数据
#### Get Display Name/获取显示命名
#### Select/选择
一个简单方便的流程控制，与Switch类似，但是比Switch简洁，提供二选一或多选一的功能，右键可以增加选项
- 输入引脚
  - Option 0-----------------------连接索引0的执行逻辑，如果Variable'pin Type选择的是bool，则连接false的执行逻辑
  - Option 1-----------------------连接索引1的执行逻辑，如果Variable'pin Type选择的是bool，则连接true的执行逻辑
  - Index--------------------------索引
  - Variable'pin Type--------------选择引脚变量类型，常用bool
#### ？Is Valid/有效
判断条件是否有效，一般用来检测对象是否被实例化到场景中
#####  Array/数组
###### Make Array/创建数组
给数组的元素赋值，输出数组
#####  Casting
###### Cast To 其他蓝图名
类型转换，蓝图类子类可以直接作为父类使用，父类获取子类通过此节点来将父类转换为子类，从而可以获取和调用子类中的函数等信息

只有父类转为子类，才能转换成功
###### Get Actor Of Class/获取类的Actor
选择一个类，获取场景中这个类的Actor，返回一个Actor值，这个节点适合场景中只有一个Actor的类
###### Get All Actors Of Class/获取类的所有Actor
选择一个类，获取场景中这个类的所有Actor，返回一个Actor数组，这个节点适合场景中有多个Actor的类，这个节点需要遍历场景中的所有Actor，资源消耗大，慎用，获取后如果后续还要使用，一般缓存成变量
###### Get All Actors Of Class with Tag/获取类的所有带标签的Actor
选择一个类，输入一个标签，获取场景中这个类带这个标签的所有Actor，返回一个Actor数组，这个节点资源消耗比Get All Actors Of Class小
####  Flow Control/流程控制
###### Branch/分支
编程中的IF语句，流程控制的基础，非常常用
快捷键B，作用是返回值为True时执行什么动作，返回值为False时执行什么动作
###### Delay/延迟
快捷键D，设定时间，触发后在延迟设定的时间后执行事件，控制延迟多长时间后执行后面的节点，如果在延迟还未结束，再次触发则会被忽略，不会重复执行
原理是触发Delay之后，Delay后面的执行逻辑会被引擎放到延迟的秒数之后的游戏逻辑中处理
###### Do N/执行N次
控制动作触发一次执行一次，总共触发N次。在达到限制后，再激活触发条件，不再执行动作。直到Reset输入触发
例如可以启动车辆20次，经过加油事件后重置
- 输入引脚
  - N------------------------------执行次数
  - Reset--------------------------重置输入
- 输出引脚
  - Counter------------------------计数
###### Do Once/仅执行一次
控制动作仅执行一次，第一次激活触发条件，会执行动作，之后再激活触发条件，不再执行动作。直到Reset输入触发。该节点等同于DoN节点中N=1的情况
- 输入引脚
  - Reset--------------------------重置输入
  - Start Closed-------------------开始时关闭，重置一次之后打开
###### Do Once MultiInput/多重输入的仅执行一次
只要有一个输入执行了一次，所有的输入均不会再触发，只有触发了Reset，所有的输入才都可以重新触发
###### Flip Flop/正反触发器
取入执行输出并在两个执行输出间切换。其第一次被调用时，将会输出A。 第二次被调用时，将会输出B，然后再是A，然后又是B，循环往复
这个流程控制在室内设计中控制开关灯用的很多
###### For Loop/For循环
即C++的for循环语句
※※※※※For Loop会在帧之间运算，循环结束后再执行后面的，如果计算量过大，会导致卡顿
- 输入引脚
  - First Index--------------------第一次参与循环的索引
  - Last Index---------------------最后一次参与循环的索引
- 输出引脚
  - LoopBody-----------------------循环体，每一次循环执行
  - Index--------------------------当前索引
  - Completed----------------------完成后，循环完成后执行
###### For Loop with Break/可跳出的for循环
设定一个条件，循环中如果满足条件，就退出循环，不用遍历所有
###### For Each Loop/数组遍历For循环
专门为数组创建的循环体系，原理的更新迭代器
只能控制数组
遍历就是把一个数组从第一个元素到最后一个元素逐个执行某项操作
- 输入引脚
  - Array--------------------------需要遍历的数组对象
- 输出引脚
  - LoopBody-----------------------循环体，每一次循环执行
  - Array Element------------------遍历的数组元素
  - Array Index--------------------当前的数组索引
  - Completed----------------------完成后，循环完成后执行
###### For Each Loop with Break/可跳出的数组遍历For循环

###### Reverse for Each Loop/逆向数组遍历For循环

##### Gate/门
用来开启和关闭执行流。Enter传入执行流，同时门的当前状态（开启或关闭）将会决定是否从Exit输出中传出执行流
 - 输入引脚
  - Open---------------------------开门
  - Close--------------------------关门
  - Toggle-------------------------开关门切换

###### MultiGate/多重门
相当于路由，单个输入执行流，并将其分配到任意数量的输出流，多次输入时，默认按输出引脚的顺序执行，所有的执行完就不再执行，如果勾选Loop，多次输入时，会循环执行输出，不会停止
- 输入引脚
  - Reset--------------------------重置
  - Is Random----------------------随机输出
  - Loop---------------------------循环
  - Start Index--------------------从哪个索引开始输出

##### Retriggerable Delay/可重触发延迟
与Delay节点基本功能相同，但是Delay节点的触发时间不会刷新，始终按设定时间触发，Retriggerable Delay节点的触发时间会刷新。如设定一个按键触发事件，使用Delay节点延迟1秒，如果在事件没触发时又按了按键，那么会忽略第二次触发。使用Retriggerable Delay节点延迟1秒，如果在事件没触发时又按了按键，那么时间会清零重新开始计时延迟
##### Sequence/序列
快捷键S，很常用，先执行Then0，再执行Then1，可自行添加Then的数目，按顺序从第一个执行到最后一个
##### Switch/开关
即C++中的Switch语句，二选一使用Branch，多选一使用Switch，Switch配合枚举使用非常方便
- 输入引脚
  - Selection----------------------用于判断的变量
  - Default------------------------默认执行分支
  - Add pin------------------------添加执行分支

##### While Loop/遍历循环
适合基础循环，使用的不多，在有限的循环中，执行重复的事情
 - 输入引脚
  - Condition----------------------条件，次循环检查该条件，如果符合就继续执行。条件要确保不会死循环
 - 输出引脚
  - LoopBody-----------------------循环体，每一次循环执行
  - Completed----------------------完成后，循环完成后执行

####  Macro/宏
只能在宏中使用
##### Assign/分配
在宏里给变量赋值
##### Local Integer/本地整数型
在宏里创建Int整数型变量
####  Name
##### Make Literal Name/创建命名字符串
输入命名，并输出
####  String
##### Append/附加
将多个字符串合成一个
##### Contains/包含
判断字符串中是否存在某个字符或字符串
- 输入引脚
  - Search In----------------------原字符
  - Substring----------------------判断是否包含的子字符或子字符串
  - Use Case-----------------------是否区分大小写
  - Search from End----------------从结尾处开始查询
##### Get Character Array from String/获取字符串中字符数组
从字符串中获取字符数组，把字符串中的每一个字符作为数组的一个值，从而将字符串转为数组
##### Make Literal String/创建文字字符串
输入字符串，并输出
##### Print String/打印字符串
在屏幕中打印输入的字符串，一般用于测试蓝图结果
- 输入引脚
  - In String----------------------输入字符
  - Print to Screen----------------是否打印到屏幕
  - Print to Log-------------------是否写入日志
  - Text Color---------------------字体颜色
  - Duration-----------------------持续时间
##### Reverse/反转
反转字符串
#####  Struct
###### Make LinearColor/制作线性颜色
分别对RGBA通道输入数据，生成线性颜色
####  Text
##### Format Text/格式文本
使用可用的格式参数值生成格式化字符串
使用｛｝表示格式参数，之后会多出参数引脚
参数类型可以是字节、整数、浮点、文本、字符串、名称、布尔、对象或文本类别
####  Time
##### Get Time Seconds/获取时间（秒）
获取当前游戏时间，游戏开始时开始计时，注意不是现实世界时间
##### Get World Delta Seconds/获取场景差量（秒）
输出当前的帧时间差，即上一帧与下一帧的间隔时间
##### Set Timer by Event/根据事件设定计时器
封装的计时器，设定好时间，添加自定义事件，事件到会运行事件，勾选循环会循环计时和触发
- 输入引脚
  - Event--------------------------事件
  - Time---------------------------时间
  - Looping------------------------是否循环运行
##### Set Timer by Function Name/根据函数名设定计时器
封装的计时器，设定好时间和函数名，时间到运行函数，不用再手动添加计时器
- 输入引脚
  - Object-------------------------对象
  - Function Name------------------函数名
  - Time---------------------------时间
  - Looping------------------------是否循环运行

制作枪射击打出子弹的方法
1. 在蓝图中新建函数，在之前创建的开枪函数中按S增加一个序列节点，Then0连接到开火动画蒙太奇，Then1连接到新建的射击函数节点
2. 新建的射击函数节点执行输出端口连接到Set Timer by Function Name节点，Set Timer by Function Name节点的Time设为开枪间隔时间，勾选Looping

####  Transformation
##### Add Local Offset/添加本地偏移
在本地坐标系中给物体添加一个位置偏移
##### Attach Actor To Component/将对象附加到组件
可以动态地把对象附加到组件上，例如有多把枪，可以动态选择绑定到人物的手上
##### Attach Component To Component/将组件附加到组件
在角色骨骼的关节上添加插槽，之后在Construction Script图表中用这个节点，可以把枪械等道具绑定到人物的手上或身上
- 输入引脚
  - Target-------------------------要绑定的组件
  - Parent-------------------------要绑定的到的组件（需要有插槽）
  - Socket Name--------------------输入绑定的插槽名
##### Get Actor Rotation/获取Actor旋转信息
默认的移动方向是世界坐标方向，制作游戏时都要改成角色坐标方向，因为如果使用世界坐标方向，旋转角色后，移动方向会错乱，使用这个节点来获取角色旋转信息，来重新赋予世界方向

在设置前进后退的坐标方向时把GetActorRotation连接到Get Forward Vector节点，转化成向量，再连接到Add Movement Input节点的World Direction端口

在设置向左向右的坐标方向时有两种方法：
1. 添加一个Make Rotator节点，Yaw为90，再使用Combine Rotators合并两个节点，再连接到Get Forward Vector节点，转化成向量，再连接到Add Movement Input节点的World Direction端口
2. 把GetActorRotation连接到Get Right Vector节点，转化成向右向量，再连接到Add Movement Input节点的World Direction端口
##### Get Forward Vector/获取向前向量
获取对象前方的单位向量，获取对象朝向
##### Get Right Vector/获取向右向量
获取对象向右侧的单位向量
##### Get Up Vector/获取向上向量
获取对象向上方的单位向量
##### Get Velocity/获取速度
获取对象当前的移动速度
##### Get World Location/获取世界位置
获取对象的世界坐标，输出的数据是Vector类型
##### Set Actor Location/设置Actor位置
##### Set Actor Rotation/设置Actor旋转
##### Set Actor Scale 3D/设置Actor缩放3D
设置对象的缩放
##### Set Relative Location/设置相对位置
设置对象的相对位置
##### Set Relative Rotation/设置相对旋转
设置对象的相对旋转
##### Set World Location/设置世界位置
设置对象的世界位置
##### Set World Rotation/设置世界旋转信息
设置对象的世界旋转值



###  User Interface/用户界面
#### Create Drag&Drop Operation/创建拖放操作
UE4规定的拖放操作是在原物体位置创建一个新的临时物体来拖动，放置时临时物体消失。要实现正确的拖放，应该还要在函数覆写中添加拖动时隐藏原物体，放置时把原物体显示到鼠标所在位置的逻辑
##### 输入引脚
- Class--------------------------默认的Drag Drop Operation(拖放操作)即可
- Payload------------------------负载，连接原物体
- Default Drag Visual------------默认拖动视觉，连接拖动时的临时物体
- Pivot--------------------------拖动时，临时物体的中心点
##### 输出引脚
- Return Value-------------------返回拖放操作

#### Create Widget/创建控件
用来将创建的UI关联到关卡中，根据关卡、角色等需要，考虑在关卡蓝图、在GameMode蓝图、在PlayerController蓝图、在Player蓝图还是其他的蓝图中关联
#####  Animation
###### Is Animation Playing/动画正在播放
判断UMG控件动画是否正在播放，需要输入UMG控件动画，输出一个布尔值
###### Is Playing Animation/正在播放动画
判断UMG控件是否有动画正在播放，输出一个布尔值，不用传入UMG控件动画，任何该UMG控件动画在播放，都会输出True
###### Play Animation/播放动画
用来播放UMG系统中的UI动画
#####  Geometry/几何
###### Absolute to Local/绝对到本地
将绝对坐标转换为控件的本地坐标，绝对坐标可以是在桌面空间或窗口空间，取决于控件层次结构的根组件所在的空间
##### Viewport
###### Add to Viewport/添加到视窗中

### Variables
#### Set By-Ref Var/以引用的方式设置变量值
##### 输入引脚
- Target-------------------------要设置的变量
- Value--------------------------变量值
##### Controller
###### Get Player State/获取玩家状态
获取玩家的PlayerState蓝图

### Viewport
#### Get Mouse Position on Viewport/获取视口上的鼠标位置
在视口控件的本地坐标空间获取鼠标位置，即获取视口坐标系的鼠标位置
#### Get Viewport Size/获取视口尺寸
获取视口尺寸，返回一个二维向量，分别为视口的横向和竖向尺寸

视口尺寸设定方法：
在引擎主界面点击Play右侧小箭头，点击Advanced Settings，在Game Viewport Settings-->New Viewport Resolution中设置视口长和宽
#### Project World Location to Widget Position/项目场景位置到控件位置
中文名称翻译不准确，实际是把世界位置投射到控件位置。功能是为玩家获取世界位置投射到屏幕的位置，然后转换为控件位置，和Convert World Location To Screen Location功能类似，不同的是这个节点会考虑到任何的质量缩放
##### 输入引脚
- Player Controller--------------连接获取和转换好的对应的Player Controller
- World Location-----------------3D空间的世界位置
##### 输出引脚
- Screen Location----------------2D空间的屏幕位置，输出的是一个二维向量，代表屏幕空间的XY两个轴向
- Return Value-------------------是否转换成功

### Widget
大部分节点在UMG中使用
#### Get All Widgets Of Class/获取类的所有控件
遍历场景，获取选择的控件类生成的控件对象，返回一个控件对象数组

注意要小心使用，如果在角色蓝图中使用，会使角色对UI产生依赖关系，而角色不应该对UI产生依赖
##### 输入引脚
- Widget Class-------------------选择控件类
- Drag key-----------------------选择按下的按键
##### 输出引脚
- Return Value-------------------返回值，侦测的事件回复
#### Get Cached Geometry/获取缓存的几何体
获取控件的最后一个几何体
#### Get Parent/获取父项
获取控件的父控件
#### Is Visible/可见
判断UMG控件中的子控件是否可见，输出一个布尔值
#### Remove from Parent/从父项中移除
把子控件从父控件中移除，一般清除UMG控件时使用，需要注意的是，子控件只是从父项中移除，不会显示，但是它在内存中依然存在
#### Set Checked State/设置选择状态
设置UMG控件中复选框控件的选择状态
#### Set Focus/设置聚焦
为这个UI的拥有者聚焦到此UI
#### Set Keyboard Focus/设置键盘聚焦
为文字输入框UI获得键盘输入的焦点
#### Set User Focus/设置用户聚焦
为一个用户聚焦到此UI，需要传入用户的玩家控制器
#### Set Visibility/设置可见性
设置UMG控件中的子控件的可见性
#####  Drag and Drop/拖拽和放置
###### Event Reply/事件回复
###### Detect Drag if Pressed/按下时侦测拖动
给定指针事件，如果按下提供的键，则发出DetectDrag回复。如果提供的是是一个触摸键，也可以侦测
#####  输入引脚
- Pointer Event------------------连接指针事件
- Drag key-----------------------选择按下的按键
#####  输出引脚
- Return Value-------------------返回值，侦测的事件回复
#####  Panel
###### Add Child/添加子项
给UMG控件添加子控件等子项


### 特殊节点
#### Add Math Expression/添加数学表达式
手动输入数学运算表达式，会自动生成内部运算节点，如(a+b)/2*c，注意输入的数学运算符需要是C++的格式，支持C++头文件cmath中的所有函数，且生成后内部运算节点为只读，无法编辑
#### Add Timeline/添加时间轴
可以添加一个时间轴，对一个值随时间变化而赋值，允许根据游戏中的事件快速设计和播放基于时间的简单动画。时间轴与简单Matinee序列有几分类似， 因为它们允许对简单值进行动画处理，并允许随着时间的推移触发事件。可以通过在图表（Graph）选项卡中 或我的蓝图（My Blueprint）选项卡中双击时间轴（Timeline），在蓝图编辑器中直接编辑这些时间轴。它们经过专门设计，用于处理简单的非电影任务，例如开门、改变光源 或在场景中对Actor执行其他以时间为中心的操作
##### 输入引脚
- Play---------------------------播放，使得时间轴从当前时间处开始正向播放
- Play from Start----------------从开始处播放，使得时间轴从开始处正向播放，无论从第几秒触发，都会跳到开始处从头播放
- Stop---------------------------停止，在当前时间处停止播放时间轴
- Reverse------------------------反向播放，从当前时间处反向播放时间轴
- Reverse from End---------------从结尾处开始反向播放，从结尾开始反向播放时间轴
- Set New Time-------------------设置新时间，将当前时间设置为New Time（新时间）输入中的设置的变量(或输入)
- New Time-----------------------新时间，该数据引脚取入一个代表时间的浮点值，以秒为单位，当调用Set New Time(设置新时间)输入时，时间轴可以跳转到该浮点值设置的时间处
##### 输出引脚
- Update-------------------------更新，一调用该时间轴就输出一个执行信号
- Finished-----------------------完成，当播放结束时输出一个执行信号。该引脚不会被Stop函数触发
- Direction----------------------方向，输出枚举数据，指明了时间轴的当前播放方向
- Track--------------------------输出轨迹数据
##### 节点内部
- Add Float Track----------------添加浮点型轨迹
- Length-------------------------输出的轨迹长度
- AutoPlay-----------------------自动播放
- Loop---------------------------循环
- Ignore Time Dilation-----------忽略时间膨胀，是做特殊效果用的，比如荒野大镖客的死亡之眼，黑客帝国尼奥躲子弹。忽略意味着当场景时间膨胀（更快或更慢）时，时间轴触发的事件依旧保持自己的速度运行，不受影响

自动播放和循环（AutoPlay&Loop）一般做恐怖游戏时才会用，比如窗户不停的自己开关等等

*Shift+鼠标左键，快速添加运动点位*



### 统一建模语言/UML（Unified Modeling Language）
统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言

有十多种图
#### 类图/Class Diagram
表达类之间的关系
继承、组合
实现、聚合、依赖、关联

--------->   关联(Association)
---------▷   继承(Inheritance)
- - - - -▷   实现(Realization/Implementation)
- - - - ->   依赖(Dependency)
--------<>   聚合(Aggregation)
--------◀▶  组合(Composition)



### 重构
#### 概念
重构（Refactoring）就是通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性
系统发展到一定阶段后，使用重构的方式，不改变系统的外部功能，只对内部的结构进行重新的整理。通过重构，不断的调整系统的结构，使系统对于需求的变更始终具有较强的适应能力
重构可以降低项目的耦合度，使项目更加模块化，有利于项目的开发效率和后期的维护。让项目主框架突出鲜明，给人一种思路清晰，一目了然的感觉，其实重构是对框架的一种维护
#### 重构时机
1. 添加新功能时
2. 在修改bug时
3. 在代码复审时
#### 注意事项
要时刻保证代码是能跑的，要尽量避免修改了很多地方再测试 


# 人工智能
## 树
### 树的定义
树是一种数据结构
树由点和有向边组成
树是连通的
树没有环
### 相关概念
#### Root/根节点
跟节点没有父节点
#### Child/子节点
有向边的终点
#### Parent/父节点
有向边的起点
#### Siblings/兄弟节点
具有相同父节点的节点
#### Descendant/后代节点
子节点以及子节点的子节点
#### Ancestor/祖先节点
父节点，以及父节点的父节点
#### Leaf/叶节点
没有子节点的节点
#### Branch(Internal)/分枝节点（内部节点）
至少有一个子节点的节点
#### Degree/度
子节点的个数
#### Edge/边
节点与其他节点连接的连接
#### Path/路径
将节点与后代连接起来的一系列节点和边缘
#### Level/级别
节点的级别由1+(节点与根之间的连接数)定义
#### Height of node/节点高度
节点的高度是该节点与树之间最长路径上的边数
#### Height of tree/树的高度
树的高度是根部的高度
#### Depth/深度
节点的深度是指从树根节点到节点的边缘数
#### Forest/森林
森林是一组n，2，0不相交的树
### 行为树
#### 定义
行为树是一个计划执行的数据模型，描述的是在一个有限任务集中以模块形式进行转换


## 人工智能相关资产
### Artificial Intelligence/人工智能资产
#### Behavior Tree/行为树
行为树可以让AI角色自行思考并自行做出决定，行为树资源是一系列逻辑脚本集合，行为树在内存中是惟一的
可以完全不使用行为树，仅在蓝图和代码中实现AI的逻辑也是可行的，但是行为树会更方便，简化了操作。它与蓝图节点最大的不同是它可以一个节点执行完再执行下一个节点，逐个执行，而蓝图中实现可能需要计算时间或做执行是否完成的判断等，非常麻烦
#### Blackboard/黑板
存储数据，本质上是一种类似于Map的数据类型，用于数据的传递，判断任务是否可以执行

# Behavior Tree行为树编辑器
## Behavior Tree/行为树图表
UE4中的行为树按照从左到右，从上到下的顺序执行逻辑。操作的数字顺序显示在图表中所放置节点的右上角
行为树节点可以分为根节点和合成节点、装饰器节点、服务节点、任务节点四大类
### Root/根节点
充当行为树起始点的节点即根节点。它是整个行为树内的一个独特节点，因此拥有一些特殊规则。它只能有一个连接，且不支持附接装饰器节点或服务节点。尽管根节点没有自己的属性，但选中它会在详细信息面板中显示行为树的属性，可以在该面板中设置行为树的黑板资源（Blackboard Asset）

### Composite/合成节点
此类节点定义分支的根以及执行该分支的基本规则
合成（Composite）节点定义分支的根，以及执行该分支的基本规则。可以对其应用装饰器（Decorators）节点，从而修改进入它们分支的条目，甚至取消执行中的条目。此外，它们还可以连接服务（Services）节点，这些服务节点只有在合成节点的子节点正在被执行时才会激活

只有合成节点可以被连接至行为树的根节点
### Selector/选择器
选择器节点按从左到右的顺序执行其子节点。当其中一个子节点执行成功时，选择器节点将停止执行。如果选择器的一个子节点成功运行，则选择器运行成功。如果选择器的所有子节点运行失败，则选择器运行失败
即从左向右开始判断，有一个为true，它就为true，执行true的分支
#### Composite
- Apply Decorator Scope----------应用装饰器范围，如果启用此设置，当以下分支完成执行流时，分支中所有装饰器都将被移除（此节点上的装饰器不受影响）
#### Description
- Node Name----------------------节点名称，节点在行为树图中显示的名称
### Sequence/序列
序列节点按从左到右的顺序执行其子节点。当其中一个子节点失败时，序列节点也将停止执行。如果有子节点失败，那么序列就会失败。如果该序列的所有子节点运行都成功执行，则序列节点成功
即从左向右开始判断，所有的都为true，它才为true
### Simple Parallel/简单平行
简单平行节点允许一个主任务节点沿整个的行为树执行。主任务完成后，结束模式（Finish Mode） 中的设置会指示该节点是应该立即结束，同时中止次要树，还是应该推迟结束，直到次要树完成
简单平行节点不常用，并行结构不符合人类思维方式，且可以用服务节点替代
#### Parallel 
- Finish Mode--------------------结束模式
- Immediate----------------------立即，主任务完成后，后台树的执行将立即中止
- Delayed------------------------推迟，主任务完成后，允许后台树继续执行直至完成

### Decorators/装饰器节点
装饰器节点（在其他行为树系统中也称为条件语句）附加到合成（Composite）或任务（Task）节点，并定义树中的分支，甚至单个节点是否可以执行
也称为条件。它们连接到另一节点，并决定树中的分支、甚至单个节点能否被执行
在Composite节点上右键Add Decorator即可添加装饰器
如果返回值是false，则它下面所有子节点都不执行
装饰器是条件判断，控制树的切换逻辑，控制某一个节点是否执行
父类是BTDecorator Blueprint Base
#### Blackboard/黑板
很常用，黑板节点检查给定的黑板键与当前黑板对应的键的值，可以检查是否为空、是否相等、是否包含等
##### Flow Control
- Notify Observer----------------通知观察者
  - On Value Change----------------值改变时，仅在观察到的黑板键改变时进行重新计算
  - On Result Change---------------结果改变时，仅在条件改变时进行重新计算
- Observer Aborts----------------观察者中止
  - None---------------------------无，不中止执行，即装饰器不起任何作用，这个选项的存在是用于Debug
  - Self---------------------------自身，中止此节点自身和在其下运行的所有子树，如果装饰器结果为true，执行所修饰的任务或节点，允许继续查找下级节点；如果装饰器结果为false ，不执行所修饰的任务或节点，变为false当前任务会马上停止，也不会继续查找下级节点
  - Lower Priority-----------------低优先级，中止此节点右侧的所有节点。如果装饰器结果为true，执行当前节点或任务，同时会停止比当前节点优先级低的各种节点；如果装饰器结果为false，则不能执行当前节点或任务，要执行比这更节点优先级更低的节点
  - Both---------------------------两者，中止此节点自身和在其下运行的所有子树，以及此节点右侧的所有节点。既可以立即停止自身，也可以立即停止低优先级
##### Blackboard
- Key Query----------------------键查询
  - Is Set-------------------------已经设置，数值已经设置则节点返回true
  - Is Not Set---------------------尚未设置，数值尚未设置则节点返回true
  - Is Equal To--------------------等于，数值等于Key Balue，则节点返回true
  - Is Not Equal To----------------不等于，数值不等于Key Balue，则节点返回true
  - Contains-----------------------包含，数值包含Key Balue，则节点返回true
  - Not Contains-------------------不包含，数值不包含Key Balue，则节点返回true
- Key Value----------------------键值
- Blackboard Key-----------------黑板键，装饰器将运行的黑板键
##### Description
- Node Name----------------------节点名称，节点应该在行为树图表中显示的名称

### Service/服务节点
此类节点附接至合成节点，而且只要其分支正在执行，它们就会按照定义的频率执行。它们通常用于检查和更新黑板。它们取代了其他行为树系统中的传统并行节点
用于间隔更新黑板值
父类是BTService Blueprint Base

### Task/任务节点
任务节点的功能是实现操作，例如移动AI或调整黑板值。它们可以连接至装饰器节点或服务节点
此类节点是行为树的叶。它们是可执行的操作，没有输出连接
任务节点用于更新黑板值或调用角色的行为
父类是BTTaskBlueprintBase
#### Move To/移动至
移动至（Move To）任务将使拥有角色移动组件的Pawn使用寻路网格体移动至矢量黑板键
##### Node
- Acceptable Radius--------------可接受半径，移动到距目标多少距离
- Filter Class-------------------应该使用哪些导航数据？如设为None，将使用默认导航数据
- Allow Strafe-------------------是否允许AI在向目的地移动时进行扫射
- Reach Test Includes Agent Radius--到达测试包括代理半径，启用后，AI胶囊体的半径将被添加至AI和目标位置之间的阈值
- Reach Test Includes Goal Radius---到达测试包括目标半径，启用后，目标处胶囊体的半径将被添加至AI和目标位置之间的阈值
- >>
- Allow Partial Path-------------允许不完整路径启用后，将允许AI在无法移动至目标位置时使用不完整的路径
- Track Moving Goal--------------跟踪移动目标，启用后，当Actor移动时，目标Actor的路径将自动更新
- Project Goal Location----------投射目标位置，启用后，目标位置将在使用前被投射至寻路网格体上
##### Blackboard
- Blackboard Key-----------------黑板键，用于检查的键。在黑板上设置对应的变量，并在蓝图中进行绑定

使用方法：
如果让AI移动至玩家位置
- 第1步：在黑板中新增变量，命好名，Key Type设为Object,Base Class设为Actor
- 第2步：在行为树的Move To节点的Blackboard Key中选择黑板中对应的变量
- 第3步：在AIController中使用Use Blackboard节点使用当前黑板
- 第4步：连接Set Value as Object节点，Target为当前黑板，Key Name提升为变量，设为黑板中对应的变量名，Object Value连接Get Player Pawn节点
- 第5步，连接Run Behavior Tree节点，运行当前行为树
##### Task
- Ignore Restart Self------------无视重启自身，启用后，选择执行的任务已在运行时任务搜索将被放弃
##### Description
- Node Name----------------------节点名称，节点在行为树图表中显示的名称
#### Play Animation/播放动画
播放动画节点可用于播放指定的动画资源
##### Node
- Animation to Play--------------选择播放的动画资产
- Looping------------------------循环

所选的动画必须与行为树控制的Pawn骨架相匹配

#### Wait/等待
等待节点使树在此节点上等待，直至指定的等待时间（Wait Time）结束
##### Wait
- Wait Time----------------------等待时间
- Random Deviation---------------随机偏差


**任务（Task）节点、装饰（Decorator）节点、服务（Service）节点都是可编程的，在Toolbar中点击New可以创建这三类节点的蓝图**



# 自动寻路
## 算法
### 宽（广）度优先搜索/BFS算法
盲目搜索，全部顶点标记，一直找邻居，直到找到目标
### 迪杰斯特拉（Dijkstra）算法
盲目搜索，最短路径，迪杰斯特拉算法是基于代价的，算起点到当前点代价最小的
### 贪婪优先算法
目标导向搜索，算当前点到目标代价最小的。它是有效搜索，但是路径不是最优
### A*寻路算法
#### A*算法定义
A星是结合迪杰斯特拉算法和贪婪优先算法的寻路，维护2个列表，开放和封闭列表，每次寻路的时候，从开放列表找出一个总代价最小的节点，如果不是终点，就算出起点到当前位置的移动代价G和当前位置到终点的移动代价H，计算出总代价F，然后加入封闭列表，并把这个节点所有的邻居都遍历一遍，计算总代价，加入开放列表，然后循环遍历，直到找到终点
A*算法路径最短，效率高效
#### A*实现的原理
场景地图抽象的理解是一个以2D的网格来划分的二维数组，数组元素->Node

```
Node存储的数据
{
   gCost: 距离起始点的估价（评分 消耗）
   hCost: 距离目标点的估价 基于二位数组中 x坐标和y坐标的偏移量来决定 以较小的偏移作为斜线个消耗个数 偏移量的差作为直线的消耗个数 
   fCost: 整体估价 gCost+hCost
}
```
##### 比较估价
优先比较fCost，选择fCost较小的Node，如果整体估价相同，选择hCost较小的节点
Node上本身如果是障碍物，那么Node不参与比较
选中一个Node之后，添加到链表，以选中的Node作为中心点，遍历九宫格，再找下一个节点，添加到链表，以此类推
当所找到的Node和目标点Node相同，则生成路径
 
#### A*实现流程
- 第1步：确定横线和斜线的消耗值（横3 斜4）
- 第2步：找到起始点和目标点所对应的二维数组的Node，根据障碍物的碰撞体积，标记不可行走的区域
- 第3步：从StartNode出发，获取周边最多8个Node，存入开启列表（如果存在于关闭列表中或标记是不可行走，则不需要判断），给8个Node分别计算和赋值gCost、hCost、fCost 
- 第4步：遍历开启列表，确定估价最低的Node，添加到路径列表，同时把所有已经判断过的Node存储到关闭列表
- 第5步：得到新节点后，继续以新节点作为九宫格中心点，获取周边8个Node依次计算
- 第6步：当开启列表中包含EndNode，说明已经找到路径，则退出循环，得到路径列表，当遍历到数组边界，依然没有找到EndNode，则说明路径生成失败

## UE的Navigation自动寻路系统
导航的前提是必须有AIController
### Navigation资源
#### Nav Mesh Bounds Volume/导航网格体边界体积
AI自动寻路的范围框，在添加AI自动寻路前要添加一个Nav Mesh Bounds Volume设置好寻路范围，将所有可以到达的区域都包裹住，添加好范围框后按P键查看AI可以寻路的范围

注意：导航网格体是根据碰撞体积来生成的，与模型的复杂程度无关，因此，如果物体的碰撞体积设置过于复杂，会影响导航网格的效率

#### Recast Nav Mesh/重投射导航网格
在场景中添加Nav Mesh Bounds Volume后，会自动生成Recast Nav Mesh，可以设置导航网格的显示、生成导航网格瓦片、查询规则等
##### Display/显示
显示导航网格的相关信息，主要用来Debug时提供信息
- Draw Triangle Edges------------绘制三角形边缘
##### Generation/生成
- Agent Radius-------------------代理半径，代理即进行导航的对象，比如怪物NPC或玩家等，代理半径主要控制代理网格的边缘不可行走的区域范围，防止自动寻路时从网格边缘掉落
- Agent Height-------------------代理高度，可以理解为玩家或NPC的高度，例如场景中有个山洞，这个数值可以决定角色是否能从山洞中通过
- Agent Max Slope----------------代理最大坡度，能爬上的斜坡的最大坡度
- Agent Max Step Height----------代理最大步高，能上去的台阶的最大高度
##### Runtime/运行时
- Force Rebuild on Load----------加载时强制重构，一般不勾选，因为重构会导致瞬间数据量过大
- Auto Destroy when No Navigation--无导航时自动销毁
- Runtime Generation-------------运行时生成
- Static-------------------------静态，运行时任何情况下，导航网格都不会改变，始终保持运行前设置的状态
- Dynamic Modifiers Only---------仅动态修改器，最常用方式，不监测静态物体，只会监测Nav Modifier Volume
- Dynamic------------------------动态，运行时实时监测，如果场景中出现障碍物移动等情况，需要改变导航网格，会实时改变，消耗较大，一般不使用

#### Nav Modifier Volume/导航修改器体积
包含一个AreaClass区域类，应用于导航网格，用于更改网格体积空间多变性的属性，从而最终修改通过成本。改变通过成本来改变寻路规则，如避开障碍物等
如果是桥或者门等有渲染效果的障碍物，可以在对应的障碍物的蓝图中添加Nav Modifier组件
##### Default/默认设置
- Area Class---------------------区域类，这是导航修改器体积的核心功能
- None---------------------------无，导航修改器体积不起任何作用
- NavArea_Default----------------导航区域_默认，正常的导航区域，显示为绿色
- NavArea_LowHeight--------------导航区域_低高度，可在上方自由高度不足的空间中生成的特殊区域。任何人都无法穿越，显示为蓝色
- NavArea_Null-------------------导航区域_无，任何人无法通过，任何时候寻路算法无法遍历，不显示颜色
- NavArea_Obstacle---------------导航区域_障碍物，高成本区域，除非没有其他路径，否则任何人都不应该穿越
##### Brush Settings/笔刷设置
控制导航修改器的形状

#### Nav Link Proxy/导航链接代理
如果寻路目标与当前角色所在位置没有连通，无法自动寻路，需要使用导航链接代理来控制角色从当前区域跳跃到目标区域等操作。但是一般使用蓝图中的导航链接代理，因为编辑器自带的没有响应事件，无法进行精确控制或额外操作，需要使用Nav Link Proxy蓝图
##### Simple Link/简单链接
- Point Links--------------------点链接，通过添加和设置点来设置链接
##### Smart Link/智能链接
- Copy End Point from Simple Link to SmartLink--将简单链接中的结束点复制到智能链接中
- Link Direction-----------------链接方向，一般选择双向
- Smart Link Is Relevant---------智能链接为相关，勾选后可以开启广播功能
##### Broadcast/广播
- Notify when Enabled------------启用时通知，当寻路角色走到链接处时会通知
- Broadcast Channel--------------广播通道，一般都选择Pawn

## 优化导航网格生成速度（影响导航系统效率的几个点）
- 尽量使用较大的CellSize体素单元大小和较大的CellHieght体素单元高度
体素越小，导航的精度也越高，障碍物周围的导航就越准确，但是也会导致在运行时，重新构建导航网格处理的也越多。所以在满足Agent所需的精度的情况下，Cell尽可能的大
- 限制TileSize瓦片大小
导航网格是多瓦片的集合，而每一个瓦片从Cell进行构建，较大的Tiles就包含更多的Cells，重建成本就会变高
- 网格的碰撞影响导航精度（简化网格的碰撞也可以提升导航网格的构建效率）
导航根据对象的碰撞数据来生成，所以碰撞网格中使用的三角面越少，生成速度越快
- 减少影响导航网格的场景对象
将一些不会移动的物体设置会静态或设置不影响导航的生成
- 在场景切换异步加载资源等特殊时期锁定和解锁导航网格的生成
在异步加载资源时，虽然场景发生变化，但是此时并不需要更新导航网格，因此可以把导航网格锁定，需要的时候再解锁。是代码中的一个动态布尔值控制的bInitialBuildingLocked=true，需要在代码中修改




# 控制台
在编辑器中或游戏在编辑器中运行时，按~键可以呼出控制台，输入指令执行一些操作
控制台中的指令不区分大小写
##  Collision
### show collision
显示碰撞，会显示场景内所有对象的碰撞盒
##  Help
### Help
输入help会弹出一个网页，里面有所有的控制台命令
##  Game
### HighResShot
高质量截图，命令后面跟分辨率 如HighResShot 1920x1080
注意中间是字母x
### Shot
截图，只能在游戏运行中使用
##  Net
### Net PktLag=毫秒数
模拟网络延迟，单位是毫秒
### Net PktLagVariance=毫秒数
模拟网络随机范围秒数延迟,需要先使用Net PktLag模拟网络延迟，否则没有效果
### Net PktLoss=数字
模拟网络丢包率，数字为即为百分之多少，输入100，则完全丢包
### Net PktOrder=
模拟数据包顺序还是乱序，0为顺序，1为乱序
### Net Pktdup=数字
模拟网络重复发包率，数字为百分之多少
##  Spawn
### Spawn 类名
可以生成对象



