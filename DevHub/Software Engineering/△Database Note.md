# 基础
## 数据库的基本概念
### 数据（Data）
对客观事物特征所进行的一种抽象化、符号化表示
### 信息（Information）
有一定含义的、经过加工处理的、对决策有价值的数据
信息=数据+处理
#### 数据转换为信息
- 收集
- 存储
- 加工
- 排序
- 检索
#### 数据与信息的关系
- 数据是信息的载体，它表示了信息
- 信息是数据的内涵，即数据的语义解释
### 结构化数据
#### 结构化数据
数据按照一定的规则（数据模型）来存放，就是“结构化数据”
#### 非结构化数据
- 数据结构不规则或不完整，没有预定医德数据模型，不方便用数据库二位逻辑表来表现的数据是“非结构化数据”
- 所有格式的文档、文本、图片、XML、HTML、图像、音频、视频等都是非结构化数据
### 数据库
#### 结构化数据库（DataBase,DB）
是存储在计算机存储设备上，按照某种数据结构存储的相关数据的集合
- 概括地讲，数据库数据具有永久存储、有组织和可共享3个基本特点
- 严格地讲，数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享
- 结构化数据库的关键有两点
  - 结构
  - 相关
#### 非结构化数据库
各种NoSQL(Not Only SQL)数据库

## 数据库系统
### 数据库集合（DataBase,DB）
是存储在计算机外存上的若干设计合理、满足应用需求的数据库
### 数据库管理系统（DataBase Management System,DBMS）
位于用户和操作系统之间的一层数据管理软件，和操作系统一样是计算机的基础软件
#### 主要功能
- 数据定义功能
- 数据组织、存储和管理
- 数据操纵功能
- 数据库的事务管理和运行管理
- 数据库的建立和维护功能
- 其他功能（通信功能、数据转换功能、互访和互操作功能等）
### 数据库系统
是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统
### SQL（Structered Query Language）
操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准


## 数据模型
两类数据模型：概念模型+逻辑模型和物理模型（先将现实世界抽象为信息世界，然后将信息世界转换为机器世界）
### 概念模型
也叫信息模型，是按用户观点来对数据和信息建模，主要用于数据库设计


基本概念：
#### 实体
客观存在并可相互区别的事物，例如人
#### 属性
实体所具有的某一特性，例如人的鼻子、嘴巴
#### 码
唯一标识实体的属性，例如学号
#### 实体型
用实体名及其属性集合来抽象和刻画同类实体，例如含有鼻子和嘴巴的人
#### 实体集
同一类型实体的集合。例如学校
#### 联系
实体之间的联系通常是指不同实体集之间的联系。实体之间的联系有一对一、一对多和多对多等多种联系
实体内部的联系通常指实体各属性之间的联系

概念模型的一种表示方法：实体-联系方法
用E-R图来描述现实世界的概念模型，E-R方法也称为E-R模型

### 逻辑模型
按计算机系统的观点对数据建模，主要用于数据库管理系统的实现
包括3种
#### 层次模型
用树状结构来存储数据，它是一对多的联系，开发效率较低
#### 网状模型
它是多对多的联系，开发效率较低
#### 关系模型
关系模型是结构化数据库的主要模型，它是用二维表结构表示实体以及实体之间联系的模型。即由若干行和若干列组成的表格，这样的二维表格称为一个关系

### 物理模型
是对数据最底层的抽象，它描述数据在系统内部的表示方法和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的


**E-R图**
- **ER图分为实体、属性、关系三个核心部分，实体用长方形表示，属性用椭圆形表示、关系用菱形表示**
- **作为主键的属性在文字下面加下划线**


### 常用的数据模型
层次模型、网状模型、关系模型、面向对象数据模型、半结构化数据模型
#### 层次模型
树状结构
- 有且只有一个结点且没有双亲结点，称为根结点
- 根以外的其他结点有且只有一个双亲结点
#### 网状模型
- 允许一个以上结点无双亲
- 一个结点可以有多于一个双亲
#### 关系模型
- 关系
一个关系对应通常说的一张表
- 元组
表中的一行
- 属性
表中的一列
- 码
也称码键，表中的某个属性组
- 域
是一组具有相同数据类型的值的集合
- 分量
元组中的一个属性

### 数据库系统的结构
模式数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体的值。其一个具体值称为模式的一个实例
模式是相对稳定的。实例是相对变动的
#### 三级模式结构
外模式+模式+内模式
##### 外模式
也称子模式或用户模式，它是数据库用户〈包括应用程序员和最终用户）能够看见和使用的局部数据的逻辄结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。
##### 模式
也称为逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。
##### 内模式
也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式
#### 二级映像
##### 外模式/模式映像
当模式改变时，由数据库管理员对各个外模式/模式映像作相应改变，可以使外模式保持不变。应用程序不必修改。保证了数据与程序的逻辑独立性
##### 模式/内模式映像
当数据库的存储结构改变时，有数据库管理员对模式/内模式作相应改变，可以使模式保持不变，从而应用程序也不用改变。保证了数据与程序的物理独立性
数据与程序之间的独立性使得数据的定义和措述可以从应用程序中分离出去。另外，由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改

### 数据库系统的组成
#### 硬件平台及数据库
足够大内存、磁盘或磁盘阵列等设备，较高的通道能力以提高数据的传送率
#### 软件
数据库管理系统，支持数据库管理系统运行的操作系统，具有与数据库接口的高级语言及其编译系统，以数据库管理系统为核心的应用开发工具，为特定应用环境开发的数据库应用系统
#### 人员
开发、管理和使用数据库的人员主要包括数据库管理员、系统分析员和数据库设计人员、应用程序员和最终用户

数据库管理员职责：决定数据库中的信息内容和结构、决定数据库的存储结构和存取策略、定义数据的安全性要求和完整性约束条件、监控数据库的使用和运行、数据库的改进和重组、重构


## 数据库设计
### 数据库设计目标
最终目标是建立一个能满足用户需求、如实反映数据联系、符合数据库规范的数据库结构
### 数据库设计要求
- 满足用户的要求
- 符合选定的数据库管理系统的要求
- 具有较高的范式
  - 范式是评价数据库结构是否合理的一种标准
  - 不同级别的范式对数据的保障不同
  - 范式级别高，才能保证数据有更好的完整性、更低的数据冲突
### 数据库设计基本步骤
#### 用户需求分析
需求分析阶段的主要任务是对所要处理的对象进行全面详细的了解，收集汇总用户对数据库的信息要求、处理要求、完全需求等，以各种标准文件记录下来
#### 概念结构设计
概念结构设计是在确定用户信息需求后，对信息进行规范的分析，最终规划出反应用户信息需求的数据库概念结构，也称为概念数据模型（简称概念模型）
*在这个环节中常用的工具是E-R模型（实体-联系模型）*
#### 逻辑结构设计
逻辑结构设计是在概念模型基础上，结合所采用的某个数据库管理系统软件的数据模型特征，按照一定的转换规则，将概念模型转换为这个DBMS所能接受、识别的逻辑模型
#### 物理结构设计

### 概念结构设计
概念结构设计的一般方法是E-R方法，即实体--联系模型，也叫E-R模型
#### 实体--联系模型（Entity Relationship Model）
包含以下概念
##### 实体（Entity）
实体是指客观存在、可相互区分的事物。实体可以是一个具体的对象，例如学生，也可以是抽象的对象，例如课程
在进行概念结构设计时，如果一个概念满足以下任一条件，那么它肯定是一个实体：
- 具有非关键属性，即不仅仅是某物的名称
- 与其他实体有任何关系
- 它位于关系的多方
##### 实体集（Entity Set）
性质相同的实体组成的集合称为实体集
##### 实体型（Entity Type）
实体型是实体集的表示。用实体的名称和实体的属性名称来表示同类型的实体
###### 具体表现形式为
```
实体名(属性名1,属性名2,...,属性名n)
```
例如：
```
课程(课程号,课程名,学时数,学分,是否必修)
```
##### 弱实体集/型（Weak Entity Set/Type）
一个实体集的存在依赖于另一个实体集
弱实体集没有自己的关键属性
例如：
孩子必须有父母，订单项目必须属于采购订单

**注意：避免冗余**
**冗余是以不止一种方式陈述同一件事，如果一个概念可以建模为属性，则无需将其建模为实体类型，不要过度使用弱实体类型**

##### 超类（Superclass）
一种实体类型，包含其出现的一个或多个不同子组，必须在数据模型中表示
##### 子类（Subclass）
实体类型出现的不同子组，必须在数据模型中表示
超类和子类的关系是1对1，他们的关系叫 超类/子类关系（superclass/subclass relationship）
##### 共享子类（Shared Subclass）
一个子类拥有多个超类，他们之间的关系叫 多继承（Multiple inheritance）
##### 属性（Attribute）
###### 属性概念
每个实体都具有一组描述自己特征的数据项，每一个数据项都代表了实体一个特性，我们把实体所具有的某一特性称为属性
属性可以采用所有可能值的集合
###### 简单属性/元属性（Simple/Atomic Attribute）
不能分成更小的子部分的属性，例如：性别、城市、学号等
###### 复合属性（Composite Attribute）
可以分为更小的子部分的属性
例如：地址包含门牌号、邮政编码、城市和国家；姓名有名字和姓氏
###### 派生属性
其值可以从其他属性或现有数据的值中派生的属性
例如：
年龄可以从出生日期推算出来
通过统计实体集中的实体可以得出部门的员工数量
###### 多值属性
同一实体具有一组值的属性
例如：
一个人可能有0个或多个爱好
##### 域（Field/domain）
每一个属性都有一个值域，即属性的取值范围
##### 码（Code）
如果一个属性或若干属性（属性组）的值能唯一地识别实体集中每个实体，就称该属性（或属性组）为实体集的码，也称为键，码用下划线标注
*一个实体集的码有可能由该实体中的若干属性组成*
###### 候选键（Candidate Key）
唯一标识实体类型每次出现的最小属性集，没有 2 个实体具有相同的这些属性值
例如：员工的 EmpID 属性
###### 主键（Primary Key）
选择用于唯一标识实体类型的每次出现的候选键。为了限定，一个属性/属性集不允许Null值，不允许重复。一个实体只能有一个主键，在E-R图中用{PK}标记
###### 替代键（Alternative keys）
从候选键中选择主键后，剩余的候选键叫做替代键，在E-R图中用{AK}标记
###### 复合键（Composite Key）
1个键由1个以上的属性组成
例如：
车辆登记的（州、号）属性，编号可以跨州使用，但同一州内不重复
###### 部分键（Partial Key）
唯一标识与同一所有者/父实体相关的弱实体的属性，在E-R图中用{PPK}标记
例如：监护人姓名
###### 超级键（Super Key）
唯一标识元组中的一组属性关系,即关系中没有两个元组具有相同的值对于那些属性
默认情况下，所有属性的集合是一个超级键

##### 联系（Relation）
现实世界中事物是相互联系的,这种联系必然要在数据库中有所反映，表现为实体之间的联系。联系共有以下三种
###### 一对一联系（1:1）
如果对于实体集A中的每一个实体，在实体集B中至多只有一个（也可以没有）实体与之相对应，反之亦然，这时则称实体集A与实体集B具有一对一联系，记为1:1
###### 一对多联系（1:n）
如果对于实体集A中的每一个实体，在实体集B中都有多个实体（也可以没有）实体与之相对应；反过来，对于实体集B中的每一个实体最多和实体集A中的一个实体相对应，则称实体集A与实体集B具有一对多联系，记为1:n
###### 多对多联系（n:n）
如果对于实体集A中的每一个实体，在实体集B中都有任意个（n个，n≥0）实体与之相对应；反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之相对应，则称实体集A与实体集B具有多对多联系，记为m：n
#### 实体-联系模型的图形表示（E-R图）
##### 实体集
用矩形框表示，矩形框内注明实体的名称
##### 属性
用椭圆形框表示，椭圆框内书写属性的名称，并用一条直线与其对应的实体相连接
##### 实体间的联系
用菱形框表示，菱形框内书写联系的名称，用直线将联系与相应的实体相连接，并且在直线附近靠近实体一端标上1或n等，以表明联系的类型（1:1、1:n或m:n）

**注意：**
- **如果一个联系具有属性，则这些属性也要用直线与该联系连接起来**
- **实体集的码属性用下划线标注**

### 逻辑结构设计
逻辑结构设计将概念模型（E-R模型）转化为逻辑模型（关系模型）
#### 关系模型
关系模型用二维表表示实体集中的数据，简称为关系（Relation）
由于关系模型要由E-R模型转化而来，因此关系模型中的许多概念都和E-R模型相呼应
#### 关系术语
##### 元组（记录）
二维表中的每一行称为一个元组。元组是构成关系的基本要素，即一个关系由若干相同结构的元组组成
##### 属性（字段）
二维表中每一列称为一个属性。若干属性的集合构成关系中的元组
##### 值域（域）
即属性的取值范围。合理的定义属性的值域，可以提高数据表操作的效率
##### 关键字（主键、主码）
在一个关系中有这样一个或几个字段，它（们）的值可以唯一地标识一条记录，这样的字段或字段组称之为关键字（Key），也称为主关键字、主码或主键（Primary Key）。例如，学生关系的主键是学号
##### 外部关键字（外键）
某个属性或一组属性，不是当前关系的主键，而是另一个关系的主键，那么，这样的属性在当前关系中称为外键（Foreign Key）。外部关键字在各个数据表即关系之间架起了一座桥梁，使数据库中的表相互制约、相互依赖，形成一个整体
##### 关系模式
对关系的一种抽象表示形式（类似实体型）
关系名（属性名1，属性名2，…，属性名n）
#### 概念模型和关系模型的对应
概念模型用于概念设计阶段，关系模型用于逻辑结构设计阶段

| 概念模型         | 关系模型            |
|:----------------|:-------------------|
| 实体             | 元组                |
| 属性             | 属性（字段）        |
| 域               | 值域                |
| 码               | 关键字 / 外关键字   |
| 实体集           | 关系                |
| 实体型           | 关系模式            |

#### 关系特点
在关系模型中，二维表是其标准的数据结构，二维表具有以下特点
- 每一个属性均不可再分，即表中不能再包含表
- 同一个关系中不能有相同的属性名
- 同一个关系中不能有内容完全一样的元组
- 任意两行或任意两列互换位置，不影响关系的实际含义
#### 关系模型完整性规则
##### 实体完整性规则
一个关系中任何记录的关键字不能为空值，并且不能存在重复的值
例如：一个学生不能没有学号，也不能和其他学生的学号重复
##### 参照完整性规则
数据库中的表之间都存在一定的联系，参照完整性规则解决关系与关系间引用数据时的合理性。这种引用、制约关系是通过关键字与外部关键字来完成的
###### 具体规则为
若属性（或属性组）F是关系R的外部关键字，它与关系S的关键字K相对应（关系R和S不一定是不同的关系），则R中每个F的取值必须等于S中某个K的值

例如，可以很容易在学生和选课成绩表中找到相应的参照规则，即选课成绩表的学号（外键）属性受到学生表的学号（主键）控制

即不存在的学生不能选课，学生不能选不存在的课
##### 用户自定义完整性规则
根据需求制定的数据约束条件就是用户自定义的完整性它反映数据必须满足的语义要求
例如：规定成绩只能大于等于0，规定性别只能是男或女
#### E-R模型转化为关系模型
##### 转化目的
E-R转换为关系模型的最终目的之一就是将E-R图中的数据项放到适当的表中
##### 转化时要解决的问题
转换时要解决的问题是如何将实体和实体间的联系转换为关系模式，如何确定这些关系模式的属性（字段）和码（关键字）
##### 对应关系
###### 实体（E-R模型）----元组（关系模型）
语义：二维表中的行，代表一个特定的事物
###### 属性（E-R模型）----属性（关系模型）
语义：二维表的列，即事物的具体特性
###### 实体集（E-R模型）----关系（关系模型）
语义：一个二维表，表示具有相同特性事物的集合
###### 实体型（E-R模型）----关系模式（关系模型）
语义：一般格式为：
实体名（属性名1，属性名2，……，属性名n）
关系名（属性名1，属性名2，……，属性名n）
###### 域（E-R模型）----值域（关系模型）
语义：属性的取值范围
###### 主键（E-R模型）----主键（关系模型）
语义：能唯一标示实体（元组）的属性或属性组
###### 候选键（E-R模型）----候选键（关系模型）
语义：一个关系中有多个属性或属性组具有关键字特性时，选定其中一个为关键字，其余的定义为候选关键字
###### 外部键（E-R模型）----外部键（关系模型）
语义：某个属性或一组属性，不是当前关系的关键字，而是另一个关系的关键字，那么，这样的属性在当前关系中称为外部关键字
###### 联系（E-R模型）
语义：实体集与实体集之间的联系（共有三种1:1、1:n、m:n）
##### 两种模型的组成要素
- E-R模型
实体集、实体的属性、实体之间的联系三个要素组成
- 关系模型
一组有关联的二维表组成的集合
##### 转换遵循的规则
- 一个实体型转换为一个关系模型
- 一个1:1的联系可以转换为一个独立的关系模型，也可以与任意一端对应的关系模型合并
- 一个1:n联系可以转换为一个独立的关系模型，也可以与n端对应的关系模型合并
- 一个m:n联系转换为一个关系模型。与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合
- 三个或三个以上实体间的一个多元联系可以转换为一个关系模型。与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合
- 具有相同码的关系模型可以合并

## SQL
全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准
### MySQL
#### 调用数据库方法
##### 方法1
在系统命令行中输入
```
mysql -u 用户名 -p
```
然后输入密码
##### 方法2
使用MySQL自带的命令行
##### 方法3
使用DataGrip等可视化软件

### SQL通用语法
- SQL语句可以单行或多行书写，以分号结尾
- SQL语句可以使用空格/缩进来增强语句的可读性
- MySQL数据库的SQL语句不区分大小写，关键字建议使用大写
- 注释：
单行注释：```-- 注释内容``` 或 ```# 注释内容```
多行注释：```/* 注释内容 */```


### MySQL数据类型
MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型
#### 数值类型
| 类型       | 占用空间 | 有效值范围（有符号）              | 有效值范围（无符号）             | 类似类型           |
|:------------|:-----------|:------------------------------------|:---------------------------------|:-------------------|
| `tinyint`    | 1 字节      | -128 到 127                         | 0 到 255                          | UE 中的 `Byte`       |
| `smallint`   | 2 字节      | -32,768 到 32,767                   | 0 到 65,535                       | C++ 中的 `short`     |
| `mediumint`  | 3 字节      | -8,388,608 到 8,388,607             | 0 到 16,777,215                   | 无                  |
| `int` / `integer` | 4 字节 | -2,147,483,648 到 2,147,483,647     | 0 到 4,294,967,295                | C++ 中的 `int`       |
| `bigint`     | 8 字节      | -2^63 到 2^63-1                     | 0 到 2^64-1                       | C++ 中的 `long`      |
| `float`      | 4 字节      | 依赖于具体实现                      | 依赖于具体实现                    | 单精度浮点型         |
| `double`     | 8 字节      | 依赖于具体实现                      | 依赖于具体实现                    | 双精度浮点型         |
| `decimal`    | 依赖于 M 和 D | 精度 M 和 标度 D 决定               | 精度 M 和 标度 D 决定             | 高精度定点数值类型   |

#### 字符串类型
| 类型         | 类型说明                     | 大小范围                    |
|:--------------|:------------------------------|:-----------------------------|
| `char`         | 定长字符串（需指定长度）         | 0 - 255 bytes                  |
| `varchar`      | 变长字符串（需指定长度）         | 0 - 65,535 bytes（取决于字符集和行大小） |
| `tinyblob`     | 不超过 255 个字符的二进制数据     | 0 - 255 bytes                  |
| `tinytext`     | 短文本字符串                    | 0 - 255 bytes                  |
| `blob`         | 二进制形式的长文本数据            | 0 - 65,535 bytes               |
| `text`         | 长文本数据                      | 0 - 65,535 bytes               |
| `mediumblob`   | 二进制形式的中等长度文本数据       | 0 - 16,777,215 bytes           |
| `mediumtext`   | 中等长度文本数据                 | 0 - 16,777,215 bytes           |
| `longblob`     | 二进制形式的极大文本数据          | 0 - 4,294,967,295 bytes        |
| `longtext`     | 极大文本数据                    | 0 - 4,294,967,295 bytes        |

#### 日期时间类型
| 类型         | 类型说明                 | 占用空间 | 值范围                                      | 格式                    |
|:--------------|:--------------------------|:-----------|:---------------------------------------------|:------------------------|
| `date`         | 日期值                     | 3 字节      | 1000-01-01 至 9999-12-31                     | YYYY-MM-DD               |
| `time`         | 时间值或持续时间             | 3 字节      | -838:59:59 至 838:59:59                      | HH:MM:SS                 |
| `year`         | 年份值                     | 1 字节      | 1901 至 2155                                 | YYYY                     |
| `datetime`     | 混合日期和时间值             | 8 字节      | 1000-01-01 00:00:00 至 9999-12-31 23:59:59   | YYYY-MM-DD HH:MM:SS      |
| `timestamp`    | 时间戳，混合日期和时间值       | 4 字节      | 1970-01-01 00:00:01 至 2038-01-19 03:14:07   | YYYY-MM-DD HH:MM:SS      |



### SQL分类
SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL
### DDL
Data Definition Language
数据定义语言，用来定义数据库对象(数据库，表，字段)
#### 数据库操作
##### 查询所有数据库
语法：
```
show databases;
```
##### 查询当前数据库
语法：
```
select database();
```
##### 创建数据库
语法：
```
create database 数据库名;
```
#### 表操作
##### 表操作-查询创建
###### 查询当前数据库所有表
语法：
```
show tables;
```
###### 查看指定表结构
语法：
```
desc 表名;
```
通过这条指令，我们可以查看到指定表的字段，字段的类型、是否可以为NULL，是否存在默认值等信
息
###### 查询指定表的建表语句
语法：
```
show create table 表名;
```
通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询
到，因为这部分是数据库的默认值，如：存储引擎、字符集等

###### 创建表结构
语法：
```
CREATE TABLE 表名(
字段1 字段1类型 [ COMMENT 字段1注释 ],
字段2 字段2类型 [COMMENT 字段2注释 ],
字段3 字段3类型 [COMMENT 字段3注释 ],
......
字段n 字段n类型 [COMMENT 字段n注释 ]
) [ COMMENT 表注释 ] ;
```
**[...]内为可选参数，最后一个字段后面没有逗号**

##### 表操作-修改
###### 添加字段
语法：
```
alter table 表名 add 字段名 类型（长度）[comment 注释][约束];
```
###### 修改数据类型
语法：
```
alter table 表名 modify 字段名 新数据类型(长度);
```
###### 修改字段名和字段类型
语法：
```
alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释][约束];
```
###### 删除字段
语法：
```
alter table 表名 drop 字段名;
```
###### 修改表名
语法：
```
alter table 表名 rename to 新表名;
```
##### 表操作-删除
###### 删除表
语法：
```
drop table [if exists] 表名;
```
可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不
加该参数项，删除一张不存在的表，执行将会报错)
###### 删除指定表，并重新创建表
语法：
```
truncate table 表名;
```
**注意: 在删除表的时候，表中的全部数据也都会被删除**

### DML
Data Manipulation Language
数据操作语言，用来对数据库表中的数据进行增删改操作
核心是3个关键字
- **添加数据（INSERT）**
- **修改数据（UPDATE）**
- **删除数据（DELETE）**
#### 添加数据（INSERT）
##### 给指定字段添加数据
语法：
```
insert into 表名(字段名1,字段名2,...) values(值1,值2,..);
```
##### 给全部字段添加数据
语法：
```
insert into 表名 values(值1,值2,...);
```
##### 批量添加数据
语法：
```
insert into 表名(字段名1,字段名2,...) values (值1,值2,...),(值1, 值2, ...), (值
1, 值2, ...);
```
```
insert into 表名 values (值1, 值2, ...),(值1, 值2, ...),(值1, 值2, ...);
```
**注意事项**
1. 插入数据时，指定的字段顺序需要与值的顺序是一一对应的
2. 字符串和日期型数据应该包含在引号中
3. 插入的数据大小，应该在字段的规定范围内

#### 修改数据（UPDATE）
语法：
```
update 表名 set 字段名1=值1, 字段名2=值2, ... [where 条件];
```
**注意事项**
**修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据**

#### 删除数据（DELETE）
语法：
```
delete from 表名 [where 条件];
```
**注意事项**
1. DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据
2. DELETE语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)
3. 当进行删除全部数据操作时，datagrip会提示我们，询问是否确认删除，我们直接点击Execute即可

### DQL
DQL Data Query Language

数据查询语言，用来查询数据库中表的记录

查询的关键字是SELECT

在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站，在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作
#### 基本语法
```
SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数
```
具体分为以下几种查询
1. 基本查询（不带任何条件）
2. 条件查询（```WHERE```）
3. 聚合函数（```count``` ```max``` ```min``` ```avg``` ```sum```）
4. 分组查询（```group by```）
5. 排序查询（```order by```）
6. 分页查询（```limit```）

#### 基础查询
不带任何查询条件
##### 查询多个字段
语法：
```
SELECT 字段1, 字段2, 字段3 ... FROM 表名;
```
```
SELECT * FROM 表名;
```
**注意**
**```*``` 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率**
##### 字段设置别名
语法：
```
SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;
```
```
SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;
```
##### 去除重复记录
语法：
```
SELECT DISTINCT 字段列表 FROM 表名;
```
#### 条件查询（WHERE）
语法：
```
SELECT 字段列表 FROM 表名 WHERE 条件列表 ;
```
条件：
##### 比较运算符
| 运算符/关键字           | 含义说明                                              |
|:------------------------|:------------------------------------------------------|
| `>`                      | 大于                                                  |
| `>=`                     | 大于等于                                              |
| `<`                      | 小于                                                  |
| `<=`                     | 小于等于                                              |
| `=`                      | 等于                                                  |
| `<>` 或 `!=`             | 不等于                                                |
| `BETWEEN ... AND ...`    | 在某个范围之内（包含最小、最大值，`between` 后写最小值，`and` 后写最大值）|
| `IN(...)`                | 在 `in` 后的列表中的值，多选一                        |
| `LIKE` + 占位符          | 模糊匹配，`_` 匹配单个字符，`%` 匹配任意个字符        |
| `IS NULL`                | 判断是否为 `NULL` 值                                  |


##### 逻辑运算符
| 运算符/关键字   | 含义说明                      |
|:----------------|:------------------------------|
| `AND` 或 `&&`    | 并且（多个条件同时成立）        |
| `OR` 或 `\|\|`     | 或者（多个条件任意一个成立）    |
| `NOT` 或 `!`     | 非、不是（取反）                |


#### 聚合函数（count、max、min、avg、sum）
将一列数据作为一个整体，进行纵向计算

常见的聚合函数：

| 函数     | 含义说明      |
|:-----------|:---------------|
| `count`     | 统计数量        |
| `max`       | 求最大值        |
| `min`       | 求最小值        |
| `avg`       | 求平均值        |
| `sum`       | 求和            |

语法：
```
SELECT 聚合函数(字段列表) FROM 表名;
```
**注意：NULL值是不参与所有聚合函数运算的**

#### 分组查询（group by）
语法：
```
SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ];
```

where与having区别：
- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤
- 判断条件不同：where不能对聚合函数进行判断，而having可以

**注意事项：**
1. 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义
2. 执行顺序: where > 聚合函数 > having
3. 支持多字段分组, 具体语法为 : ```group by columnA,columnB```

#### 排序查询（order by）
排序是日常开发中非常常见的操作，有升序排序和降序排序
语法：
```
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;
```
排序方式：

| 关键字  | 含义说明     |
|:-----------|:---------------|
| `ASC`       | 升序（默认值）   |
| `DESC`      | 降序             |

**注意事项**
- 如果是升序, 可以不指定排序方式ASC
- 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序

#### 分页查询（limit）
分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台
都需要借助于数据库的分页操作
语法：
```
SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;
```
**注意事项：**
- 起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数
- 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT
- 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10

#### 执行顺序
##### 编写顺序
①SELECT 字段列表 ②FROM 表名列表 ③WHERE 条件列表 ④GROUP BY 分组字段列表 ⑤HAVING 分组后条件列表 ⑥ORDER BY 排序字段列表 ⑦LIMIT 分页参数
##### 执行顺序
⑤SELECT 字段列表 ①FROM 表名列表 ②WHERE 条件列表 ③GROUP BY 分组字段列表 ④HAVING 分组后条件列表 ⑥ORDER BY 排序字段列表 ⑦LIMIT 分页参数

### DCL
DCL Data Control Language
数据控制语言，用来创建数据库用户、控制数据库的访问权限
#### 管理用户
##### 查询用户
语法：
```
select * from mysql.user;
```
查询结果中：
- Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的
- User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一个用户
##### 创建用户
语法：
```
CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
```
##### 修改用户密码
语法：
```
ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码' ;
```
##### 删除用户
语法：
```
DROP USER '用户名'@'主机名' ;
```
**注意事项：**
1. 在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户
2. 主机名可以使用 % 通配。
3. 这类SQL开发人员操作的比较少，主要是DBA（Database Administrator 数据库管理员）使用

#### 权限控制
| 权限关键字               | 含义说明                        |
|:---------------------------|:---------------------------------|
| `ALL` 或 `ALL PRIVILEGES`    | 所有权限                        |
| `SELECT`                     | 查询数据                        |
| `INSERT`                     | 插入数据                        |
| `UPDATE`                     | 修改数据                        |
| `DELETE`                     | 删除数据                        |
| `ALTER`                      | 修改表结构                      |
| `DROP`                       | 删除数据库 / 表 / 视图         |
| `CREATE`                     | 创建数据库 / 表                 |

##### 查询权限
```
SHOW GRANTS FOR '用户名'@'主机名' ;
```
##### 授予权限
```
GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';
```
##### 撤销权限
```
REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';
```
**注意事项：**
- 多个权限之间，使用逗号分隔
- 授权时，数据库名和表名可以使用 ```*``` 进行通配，代表所有


## 函数
- 函数是指一段可以直接被另一段程序调用的程序或代码。也就意味着，这一段程序或代码在MySQL中
- 已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可

MySQL中的函数主要分为以下四类： 
- 字符串函数
- 数值函数
- 日期函数
- 流程函数
### 字符串函数
##### CONCAT
```
CONCAT(S1,S2,...Sn)
```
字符串拼接，将S1，S2，... Sn拼接成一个字符串
##### LOWER
```
LOWER(str)
```
将字符串str全部转为小写
##### UPPER
```
UPPER(str)
```
将字符串str全部转为大写
##### LPAD
```
LPAD(str,n,pad)
```
左填充，用字符串pad对str的左边进行填充，达到n个字符串长度
##### RPAD
```
RPAD(str,n,pad)
```
右填充，用字符串pad对str的右边进行填充，达到n个字符串长度
##### TRIM
```
TRIM(str)
```
去掉字符串头部和尾部的空格
##### SUBSTRING
```
SUBSTRING(str,start,len)
```
返回从字符串str从start位置起的len个长度的字符串
### 数值函数
| 函数            | 含义说明                          |
|:------------------|:---------------------------------|
| `CEIL(x)`          | 向上取整                          |
| `FLOOR(x)`         | 向下取整                          |
| `MOD(x, y)`        | 返回 `x / y` 的模（余数）           |
| `RAND()`           | 返回 0 到 1 内的随机数             |
| `ROUND(x, y)`      | 求参数 `x` 的四舍五入值，保留 `y` 位小数 |

### 日期函数
| 函数                         | 含义说明                             |
|:------------------------------|:-------------------------------------|
| `CURDATE()`                   | 返回当前日期                         |
| `CURTIME()`                   | 返回当前时间                         |
| `NOW()`                       | 返回当前日期和时间                   |
| `YEAR(date)`                  | 获取指定 `date` 的年份               |
| `MONTH(date)`                 | 获取指定 `date` 的月份               |
| `DAY(date)`                   | 获取指定 `date` 的日期               |
| `HOUR(time)`                  | 获取指定 `time` 的小时               |
| `MINUTE(time)`                | 获取指定 `time` 的分钟               |
| `SECOND(time)`                | 获取指定 `time` 的秒                 |
| `DATE_ADD(date, INTERVAL exprtype)` | 返回 `date` 加上指定时间间隔 `expr` 后的时间值 |
| `DATEDIFF(date1, date2)`      | 返回 `date1` 和 `date2` 之间的天数   |

### 流程函数
##### IF语句
语法：
```
IF(value , t , f)
```
如果value为true，则返回t，否则返回f
##### IFNULL语句
语法：
```
IFNULL(value1 , value2)
```
如果value1不为空，返回value1，否则返回value2
##### CASE语句
```
CASE WHEN [ val1 ] THEN [res1] ...ELSE [ default ] END
```
如果val1为true，返回res1，... 否则返回default默认值
##### CASE语句2
```
CASE [ expr ] WHEN [ val1 ] THEN[res1] ... ELSE [ default ] END
```
如果expr的值等于val1，返回res1，... 否则返回default默认值


## 约束
### 概念
约束是作用于表中字段上的规则，用于限制存储在表中的数据
### 目的
保证数据库中数据的正确、有效性和完整性
### 分类
| 约束类型         | 关键字           | 含义说明                                      |
|:-----------------|:-----------------|:---------------------------------------------|
| 非空约束          | `NOT NULL`       | 限制该字段的数据不能为 `NULL`                |
| 唯一约束          | `UNIQUE`         | 保证该字段的所有数据都是唯一、不重复的        |
| 主键约束          | `PRIMARY KEY`    | 主键是一行数据的唯一标识，要求非空且唯一      |
| 默认约束          | `DEFAULT`        | 如果未指定该字段的值，则采用默认值           |
| 检查约束（8.0.16版本之后） | `CHECK`          | 保证字段值满足某一个条件                    |
| 外键约束          | `FOREIGN KEY`    | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 |


**注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束**
  
### 外键约束
#### 定义
用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性
#### 语法
##### 添加外键
###### 创建表时添加外键
```
CREATE TABLE 表名(
字段名 数据类型,
...
[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)
);
```
###### 对已有表添加外键
```
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) ;
```
##### 删除外键
```
ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
```
#### 删除/更新行为
添加了外键之后，再删除父表数据时产生的约束行为，称为删除/更新行为
具体的删除/更新行为有以下几种：
##### NO ACTION
当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。 (与 RESTRICT 一致) 默认行为
##### RESTRICT
当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。 (与 NO ACTION 一致) 默认行为
##### CASCADE
当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录
##### SET NULL
当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取null）
##### SET DEFAULT
父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)
#### 语法
```
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;
```

## 多表查询
### 多表关系
项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：
- 一对多(多对一)
- 多对多
- 一对一
#### 一对多
- 案例: 部门 与 员工的关系
- 关系: 一个部门对应多个员工，一个员工对应一个部门
- 实现: 在多的一方建立外键，指向一的一方的主键

#### 多对多
- 案例: 学生 与 课程的关系
- 关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择
- 实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键

#### 一对一
- 案例: 用户 与 用户详情的关系
- 关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率
- 实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)


### 概述
多表查询就是指从多张表中查询数据。

原来查询单表数据，执行的SQL形式为：```select * from 表名;```
那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： ```select * from 表1名 , 表2名;```

笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况

在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据

### 分类
#### 连接查询
##### 内连接
相当于查询A、B交集部分数据
内连接的语法分为两种: 隐式内连接、显式内连接
###### 隐式内连接
语法：
```
SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;
```
###### 显式内连接
语法：
```
SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;
```
**注意：**
**一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段**

##### 外连接
外连接分为两种，分别是：
- 左外连接
- 右外连接
###### 左外连接
查询左表所有数据，以及两张表交集部分数据
语法：
```
SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;
```
###### 右外连接
查询右表所有数据，以及两张表交集部分数据
语法：
```
SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;
```
**注意事项：**
左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接

##### 自连接
###### 自连接查询
自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次
语法：
```
SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;
```
- 当前表与自身的连接查询，自连接必须使用表别名
- 对于自连接查询，可以是内连接查询，也可以是外连接查询

**注意事项:**
在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段

###### 联合查询
对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集
语法：
```
SELECT 字段列表 FROM 表A ...
UNION [ ALL ]
SELECT 字段列表 FROM 表B ....;
```
**注意**
1. 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致
2. union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重

**注意**
如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报错

#### 子查询
SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询
##### 语法
```
SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );
```
子查询外部的语句可以是```INSERT / UPDATE / DELETE / SELECT``` 的任何一个

##### 分类
根据子查询结果不同，分为：
###### 标量子查询（子查询结果为单个值）
子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询
常用的操作符：```=``` ```<>``` ```>``` ```>=``` ```<``` ```<=```

###### 列子查询(子查询结果为一列)
子查询返回的结果是一列（可以是多行），这种子查询称为列子查询
常用的操作符：``IN``  ```NOT IN```   ```ANY```  ```SOME```   ```ALL```

| 运算符    | 含义说明                              |
|:----------|:--------------------------------------|
| `IN`      | 在指定的集合范围之内，多选一           |
| `NOT IN`  | 不在指定的集合范围之内                |
| `ANY`     | 子查询返回列表中，有任意一个满足即可  |
| `SOME`    | 与 `ANY` 等同，使用 `SOME` 的地方都可以使用 `ANY` |
| `ALL`     | 子查询返回列表的所有值都必须满足      |

###### 行子查询(子查询结果为一行)
子查询返回的结果是一行（可以是多列），这种子查询称为行子查询
常用的操作符：```=```  ```<>```  ```IN```  ```NOT IN```
###### 表子查询(子查询结果为多行多列)
子查询返回的结果是多行多列，这种子查询称为表子查询
常用的操作符：```IN```

根据子查询位置，分为：
- WHERE之后
- FROM之后
- SELECT之后


## 事务
### 事务简介
事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败

**注意：默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务**

### 控制事务一
#### 查看/设置事务提交方式
##### 查看事务提交方式
语法：
```
SELECT @@autocommit ;
```
##### 设置事务提交方式
语法：
```
SET @@autocommit = 0 ;
```
#### 提交事务
语法：
```
COMMIT;
```
#### 回滚事务
语法：
```
ROLLBACK;
```
**注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交**

### 控制事务二
#### 开启事务
语法：
```
START TRANSACTION 或 BEGIN ;
```
#### 提交事务
语法：
```
COMMIT;
```
#### 回滚事务
语法：
```
ROLLBACK;
```
### 事务的四大特性
事务的四大特性，简称ACID
#### 原子性（Atomicity）
事务是不可分割的最小操作单元，要么全部成功，要么全部失败
#### 一致性（Consistency）
事务完成时，必须使所有的数据都保持一致状态
#### 隔离性（Isolation）
数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
#### 持久性（Durability）
事务一旦提交或回滚，它对数据库中的数据的改变就是永久的

### 并发事务问题
#### 脏读
一个事务读到另外一个事务还没有提交的数据
#### 不可重复读
一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读
#### 幻读
一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 "幻影"

### 事务隔离级别
为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：
| 隔离级别             | 脏读    | 不可重复读 | 幻读    | 含义                 |
|:----------------------|:--------|:-----------|:--------|:------------------------|
| `Read uncommitted`    | √       | √          | √       | 读未提交（允许脏读、不可重复读、幻读） |
| `Read committed`      | ×       | √          | √       | 读已提交（避免脏读，但存在不可重复读和幻读） |
| `Repeatable Read`     | ×       | ×          | √       | 可重复读（避免脏读、不可重复读，但存在幻读） |
| `Serializable`        | ×       | ×          | ×       | 串行化（完全避免脏读、不可重复读、幻读，性能最差） |

#### 查看事务隔离级别
语法：
```
SELECT @@TRANSACTION_ISOLATION;
```
#### 设置事务隔离级别
语法：
```
SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
```
**注意：事务隔离级别越高，数据越安全，但是性能越低**


# 进阶
## 存储引擎
### MySQL体系结构
#### 连接层
最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
#### 服务层
第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。
#### 引擎层
存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。
#### 存储层
数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互

和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎

### 存储引擎介绍
存储引擎是mysql数据库的核心，需要在合适的场景选择合适的存储引擎

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎

#### 建表时指定存储引擎
语法：
```
CREATE TABLE 表名(
字段1 字段1类型 [ COMMENT 字段1注释 ] ,
......
字段n 字段n类型 [COMMENT 字段n注释 ]
) ENGINE = INNODB [ COMMENT 表注释 ] ;
```
#### 查询当前数据库支持的存储引擎
语法：
```
show engines;
```
### 存储引擎特点
#### InnoDB
InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL存储引擎
##### 特点

| 特性     | 说明                                                 |
|:---------|:----------------------------------------------------|
| 事务     | DML 操作遵循 **ACID** 模型，支持事务管理，保证数据一致性 |
| 锁       | 行级锁（**Row-level Locking**）提高并发访问性能，避免数据冲突 |
| 外键约束 | 支持 **FOREIGN KEY** 约束，保证数据的完整性和正确性，维护表之间的关系 |

##### 文件
```
xxx.ibd
```
xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引
参数：
```
innodb_file_per_table
```
```
show variables like 'innodb_file_per_table';
```
如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件

在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构
##### 逻辑存储结构
###### 表空间
InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段
###### 段
表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区
###### 区
区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页
###### 页
页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区
###### 行
InnoDB存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段

#### MyISAM
MyISAM是MySQL早期的默认存储引擎
##### 特点
- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快
##### 文件
MyISAM存储时会生成3个文件

| 文件类型      | 说明                    |
|:--------------|:------------------------|
| `xxx.sdi`     | 存储表结构信息           |
| `xxx.MYD`     | 存储数据                 |
| `xxx.MYI`     | 存储索引                 |


#### Memory
Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用
##### 特点
- 内存存放
- hash索引（默认）
##### 文件
```
xxx.sdi
```
存储表结构信息

#### 三种引擎的区别及特点
| 特性               | `InnoDB`              | `MyISAM`              | `Memory`            |
|:-------------------|:----------------------|:----------------------|:--------------------|
| 存储限制           | 64TB                  | 有                    | 有                  |
| 事务安全           | 支持                  | 不支持                | 不支持              |
| 锁机制             | 行锁                  | 表锁                  | 表锁                |
| B+tree索引         | 支持                  | 支持                  | 支持                |
| Hash索引           | 不支持                | 不支持                | 支持                |
| 全文索引           | 支持 (5.6 版本之后)    | 支持                  | 不支持              |
| 空间使用           | 高                    | 低                    | N/A                 |
| 内存使用           | 高                    | 低                    | 中等                |
| 批量插入速度       | 低                    | 高                    | 高                  |
| 支持外键           | 支持                  | 不支持                | 不支持              |


面试题:
InnoDB引擎与MyISAM引擎的区别?
1. InnoDB引擎, 支持事务, 而MyISAM不支持
2. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁
3. InnoDB引擎, 支持外键, 而MyISAM是不支持的

### 存储引擎选择
在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合
#### InnoDB
是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择
#### MyISAM 
如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的
#### MEMORY
将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性


## 索引
### 索引概述
#### 介绍
索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引

- 无索引时，查找就需要从第一行开始扫描，一直扫描到最后一行，我们称之为全表扫描，性能很低
- 有索引时会大大提升查询效率
#### 特点
##### 优势
1. 提高数据检索的效率，降低数据库的IO成本
2. 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗

##### 劣势
1. 索引列也是要占用空间的
2. 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低

### 索引结构
#### 概述
MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：
##### B+Tree索引
最常见的索引类型，大部分引擎都支持 B+ 树索引
##### Hash索引
底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询
##### R-tree(空间索引)
空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少
##### Full-text(全文索引)
是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES


| 索引类型            | `InnoDB`              | `MyISAM`              | `Memory`            |
|:-------------------|:----------------------|:----------------------|:--------------------|
| B+tree索引         | 支持                  | 支持                  | 支持                |
| Hash索引           | 不支持                | 不支持                | 支持                |
| R-tree索引         | 不支持                | 支持                  | 不支持              |
| Full-text索引      | 5.6版本之后支持       | 支持                  | 不支持              |


**注意： 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引**

#### B+树
##### 二叉树
不选择使用二叉树的原因：
1. 顺序插入时，会形成一个链表，查询性能大大降低
2. 大数据量情况下，层级较深，检索速度慢
##### 红黑树
不选择使用红黑树的原因：
- 大数据量情况下，层级较深，检索速度慢

所以MySQL的索引结构选择的是B+Tree
##### B树
B-Tree（B树）是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉

以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针

###### 特点
1. 5阶的B树，每一个节点最多存储4个key，对应5个指针
2. 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂
3. 在B树中，非叶子节点和叶子节点都会存放数据

##### B+树
B+Tree是B-Tree的变种，它分为两部分
###### 索引部分
仅仅起到索引数据的作用，不存储数据
###### 数据存储部分
在其叶子节点中要存储具体的数据

B+Tree 与 B-Tree相比，主要有以下三点区别：
1. 所有的数据都会出现在叶子节点
2. 叶子节点形成一个单向链表
3. 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的

MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序

**为什么InnoDB存储引擎选择使用B+tree索引结构?**
1. 相对于二叉树，层级更少，搜索效率高
2. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低
3. 相对Hash索引，B+tree支持范围匹配及排序操作

#### Hash
MySQL中除了支持B+Tree索引，还支持一种索引类型---Hash索引。
##### 结构
哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中

如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决
##### 特点
- Hash索引只能用于对等比较(```=``` ```in```)，不支持范围查询（```between``` ```>``` ```<``` ...）
- 无法利用索引完成排序操作
- 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引
##### 存储引擎支持
在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的

### 索引分类
#### 索引分类
在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引
##### 主键索引
针对于表中主键创建的索引，默认自动创建, 只能有一个，关键字：PRIMARY
##### 唯一索引
避免同一个表中某数据列中的值重复，可以有多个，关键字：UMIQUE
##### 常规索引
快速定位特定数据，可以有多个
##### 全文索引
全文索引查找的是文本中的关键词，而不是比较索引中的值，可以有多个，关键字：```FULLTEXT```

#### 聚集索引&二级索引
在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：
##### 聚集索引(Clustered Index)
将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据，特点是必须有，而且只有一个
##### 二级索引(Secondary Index)
将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键，特点是可以存在多个

##### 聚集索引选取规则
- 如果存在主键，主键索引就是聚集索引
- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引
- 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引

##### 聚集索引和二级索引的具体结构如下
- 聚集索引的叶子节点下挂的是这一行的数据
- 二级索引的叶子节点下挂的是该字段值对应的主键值

##### 回表查询
先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询


### 索引语法
#### 创建索引
语法：
```
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... ) ;
```
#### 查看索引
语法：
```
SHOW INDEX FROM table_name ;
```
#### 删除索引
语法：
```
DROP INDEX index_name ON table_name ;
```

### SQL性能分析
#### SQL执行频率
MySQL 客户端连接成功后，通过 ```show [session|global] status``` 命令可以提供服务器状态信
息。通过如下指令，可以查看当前数据库的```INSERT``` ```UPDATE``` ```DELETE``` ```SELECT```的访问频次

语法：
```
-- session 是查看当前会话 ;
-- global 是查询全局数据 ;
SHOW GLOBAL STATUS LIKE 'Com_______';
```
通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据
- 如果是以增删改为主，我们可以考虑不对其进行索引的优化
- 如果是以查询为主，那么就要考虑对数据库的索引进行优化了

#### 慢查询日志
慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志

MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 ```slow_query_log```

如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：
```
# 开启MySQL慢日志查询开关
slow_query_log=1

# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```

#### profile详情
```show profiles``` 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过 ```have_profiling``` 参数，能够看到当前MySQL是否支持profile操作

##### 语法
查看当前MySQL是否支持Profile操作
```
SELECT @@have_profiling ;
```
开启profiling
```
SET profiling = 1;
```
查看每一条SQL的耗时基本情况
```
show profiles;
```
查看指定query_id的SQL语句各个阶段的耗时情况
```
show profile for query query_id;
```
查看指定query_id的SQL语句CPU的使用情况
```
show profile cpu for query query_id;
```

#### explain
EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行
过程中表如何连接和连接的顺序
##### 语法
直接在select语句之前加上关键字 explain / desc
```
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
```
##### Explain 执行计划中各个字段的含义
###### id
select查询的序列号，表示查询中执行select子句或者是操作表的顺序
(id相同，执行顺序从上到下；id不同，值越大，越先执行)
###### select_type
表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等
###### type
表示连接类型，性能由好到差的连接类型为```NULL``` ```system``` ```const``` ```eq_ref``` ```ref``` ```range```  ```index``` ```all```
###### possible_key
显示可能应用在这张表上的索引，一个或多个
###### key
实际使用的索引，如果为NULL，则没有使用索引
###### key_len
表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好
###### rows
MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的
###### filtered
表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好
###### Extra
```Using where; UsingIndex```
查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据

```Using index condition```
查找使用了索引，但是需要回表查询数据


### 索引使用
#### 最左前缀法则
如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)

查询时，最左侧的列必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效

**注意：最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关**

#### 范围查询
联合索引中，出现范围查询(```>``` ```<```)，范围查询右侧的列索引失效

所以，在业务允许的情况下，尽可能的使用类似于 ```>=``` 或 ```<=``` 这类的范围查询，而避免使用 ```>``` 或 ```<```


#### 索引失效情况
##### 索引列运算
不要在索引列上进行运算操作，索引将失效
##### 字符串不加引号
字符串类型字段使用时，不加引号，索引将失效
##### 模糊查询
尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效
##### or连接条件
用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到
当or连接的条件，左右两侧字段都有索引时，索引才会生效
##### 数据分布影响
如果MySQL评估使用索引比全表更慢，则不使用索引

相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效


#### SQL提示
SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优
化操作的目的
##### use index 
建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）
语法：
```
explain select * from 表名 use index(索引名) where 查询条件;
```
##### ignore index
忽略指定的索引
语法：
```
explain select * from 表名 ignore index(索引名) where 查询条件;
```
##### force index
强制使用索引
语法：
```
explain select * from 表名 force index(索引名) where 查询条件;
```

#### 覆盖索引
尽量使用覆盖索引，减少```select *```
覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到

在查询时应尽量避免回表查询，而 ```select *``` 必定会回表查询，除非把所有列都作为联合索引，因此效率较低

#### 前缀索引
当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率

##### 语法
```
create index idx_xxxx on table_name(column(n));
```
##### 前缀长度
可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的

可以使用下面的语句来查询
```
select count(distinct email) / count(*) from 表名 ;
```
```
select count(distinct substring(email,1,5)) / count(*) from 表名 ;
```
##### 前缀索引的查询流程
前缀查询也是需要回表查询的

#### 单列索引与联合索引
- 单列索引：即一个索引只包含单个列
- 联合索引：即一个索引包含了多个列

在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引

### 索引设计原则
- 针对于数据量较大，且查询比较频繁的表建立索引
- 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引
- 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高
- 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引
- 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
- 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率
- 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询


## SQL优化
### 插入数据
#### insert
如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化
##### 优化方案一----批量插入数据
```
Insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
```
##### 优化方案二----手动控制事务
```
start transaction;
insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');
commit;
```
##### 优化方案三----主键顺序插入，性能要高于乱序插入

#### 大批量插入数据
如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入

可以执行如下指令，将数据脚本文件中的数据加载到表结构中：
```
-- 客户端连接服务端时，加上参数 -–local-infile
mysql –-local-infile -u root -p
-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;
-- 执行load指令将准备好的数据，加载到表结构中
load data local infile '/root/sql1.log' into table tb_user fields terminated by ',' lines terminated by '\n' ;
```

查询从本地加载文件导入数据的开关状态
```
select @@local_infile;
```
### 主键优化
主键顺序插入的性能是要高于乱序插入的
#### 数据组织方式
- 在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)行数据，都是存储在聚集索引的叶子节点上的
- 在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接
#### 页分裂
页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列
##### 主键顺序插入效果
- 第1步：从磁盘中申请页， 主键顺序插入
- 第2步：第一个页没有满，继续往第一页插入
- 第3步：当第一个页写满之后，再写入第二个页，页与页之间会通过指针连接
- 第4步：当第二页写满了，再往第三页写入
##### 主键乱序插入效果
乱序插入时，不会直接将数据插入页中，而是先将前一页的后一半数据放到放在一个新的页中，再插入新数据，然后改变页的指针指向
这种现象，称之为 "页分裂"，是比较耗费性能的操作
#### 页合并
- 当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用
- 当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用

**```MERGE_THRESHOLD``` ：合并页的阈值，可以自己设置，在创建表或者创建索引时指定**

#### 索引设计原则
- 满足业务需求的情况下，尽量降低主键的长度
- 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键
- 尽量不要使用UUID做主键或者是其他自然主键，如身份证号
- 业务操作时，避免对主键的修改


### order by优化
MySQL的排序，有两种方式：
##### Using filesort
通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序
##### Using index
通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高

对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index

##### Backward index scan
反向扫描索引

#### order by优化原则
- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则
- 尽量使用覆盖索引
- 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）
- 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)


### group by优化
对于分组操作，在联合索引中，也是符合最左前缀法则的

在分组操作中，我们需要通过以下两点进行优化，以提升性能：
- 在分组操作时，可以通过索引来提高效率
- 分组操作时，索引的使用也是满足最左前缀法则的

### limit优化
在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低

因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大

#### 优化思路
一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化


### count优化
#### 概述
如果数据量很大，在执行count操作时，是非常耗时的
MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 ```count(*)``` 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢
InnoDB 引擎就麻烦了，它执行 ```count(*)``` 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数

如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)

#### count用法
count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加1，否则不加，最后返回累计值

用法：
```
count（*）、count（主键）、count（字段）、count（数字）
```
##### count（主键）
InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)
##### count（字段）
- 没有not null约束
InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加
- 有not null约束
InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加
##### count（数字）
InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加
##### count（*）
InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加

按照效率排序的话，count(字段) < count(主键 id) < count(1) ≈ count(*)，所以尽量使用 count(*)


### update优化
- 当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放
- 但是当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能大大降低

**InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁**

## 视图
### 介绍
视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的

通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上

### 语法
##### 创建
```
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL] CHECK OPTION ]
```
##### 查询
###### 查看创建视图语句
```
SHOW CREATE VIEW 视图名称;
```
###### 查看视图数据
```
SELECT * FROM 视图名称 ...... ;
```
##### 修改
###### 方式一
```
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
```
###### 方式二
```
ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
```
##### 删除
```
DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...
```
### 检查选项
当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： ```CASCADED``` 和 ```LOCAL```
，默认值为 ```CASCADED```
#### CASCADED/级联
比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1
#### LOCAL/本地
比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创建时未指定检查选项。 则在执行检查时，知会检查v2，不会检查v2的关联视图v1

### 视图的更新
要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系

如果视图包含以下任何一项，则该视图不可更新：
- 聚合函数或窗口函数（ ```SUM()```  ```MIN()``` ```MAX()``` ```COUNT()```等）
- ```DISTINCT```
- ```GROUP BY```
- ```HAVING```
- ```UNION``` 或者 ```UNION ALL```

### 视图作用
##### 简单
视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件
##### 安全
数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据
##### 数据独立
视图可帮助用户屏蔽真实表结构变化带来的影响

## 存储过程
### 概念
存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用

类似于编程语言中的函数

### 特点
- 封装，复用
可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可
- 可以接收参数，也可以返回数据
在存储过程中，可以传递参数，也可以接收返回值
- 减少网络交互，效率提升
如果涉及到多条SQL，每执行一次都是一次网络传输。而如果封装在存储过程中，我们只需要网络交互一次可能就可以了

### 基本语法
##### 创建
```
CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])
BEGIN
-- SQL语句
END ;
```
##### 调用
```
CALL 名称 ([ 参数 ]);
```
##### 查看
###### 询指定数据库的存储过程及状态信息
```
SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'xxx';
```
###### 查询某个存储过程的定义
```
SHOW CREATE PROCEDURE 存储过程名称 ;
```
##### 删除
```
DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ;
```
**注意:**
**在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符**


### 变量
在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量
#### 系统变量
系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）
##### 查看系统变量
###### 查看所有系统变量
```
SHOW [ SESSION | GLOBAL ] VARIABLES ;
```
###### 可以通过LIKE模糊匹配方式查找变量
```
SHOW [ SESSION | GLOBAL ] VARIABLES LIKE '......';
```
###### 查看指定变量的值
```
SELECT @@[SESSION | GLOBAL] 系统变量名;
```
##### 设置系统变量
```
SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;
SET @@[SESSION | GLOBAL]系统变量名 = 值 ;
```
**注意**
- **如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量**
- **mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置**

全局变量(GLOBAL): 全局变量针对于所有的会话
会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了

#### 用户定义变量
用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 "@变量名" 使用就可以。其作用域为当前连接
##### 赋值
###### 方式一
```
SET @var_name = expr [, @var_name = expr] ... ;
SET @var_name := expr [, @var_name := expr] ... ;
```
赋值时，可以用=，也可以用:=，一般使用:=，因为SQL语言中相等也是=
###### 方式二
```
SELECT @var_name := expr [, @var_name := expr] ... ;
SELECT 字段名 INTO @var_name FROM 表名;
```
##### 使用
```
SELECT @var_name ;
```
**注意: 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为 ```NULL```**

#### 局部变量
局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的 ```BEGIN ... END``` 块
##### 声明
```
DECLARE 变量名 变量类型 [DEFAULT ... ] ;
```
变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等
##### 赋值
```
SET 变量名 = 值 ;
SET 变量名 := 值 ;
SELECT 字段名 INTO 变量名 FROM 表名 ... ;
```
### if
#### 定义
if 用于做条件判断
#### 语法
具体的语法结构为：
```
IF 条件1 THEN 执行1;
.....
ELSEIF 条件2 THEN 执行2;-- 可选
.....
ELSE 执行3;-- 可选
.....
END IF;
```
在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有

### 参数
#### 定义
参数的类型，主要分为以下三种：IN、OUT、INOUT
具体的含义如下：
##### IN
该类参数作为输入，也就是需要调用时传入值 默认
##### OUT
该类参数作为输出，也就是该参数可以作为返回值
##### INOUT
既可以作为输入参数，也可以作为输出参数
#### 语法
```
CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])
BEGIN
-  SQL语句
END ;
```

### case
#### 定义
case结构及作用，和流程控制函数很类似
#### 语法
有两种语法格式
##### 语法1
```
-- 含义：当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_list
CASE case_value
     WHEN when_value1 THEN statement_list1
     [ WHEN when_value2 THEN statement_list2] ...
     [ ELSE statement_list ]
END CASE;
```
##### 语法2
```
-- 含义：当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_list
CASE
    WHEN search_condition1 THEN statement_list1
    [WHEN search_condition2 THEN statement_list2] ...
    [ELSE statement_list]
END CASE;
```
**注意：如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接**

### while
#### 定义
while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句
#### 语法
```
-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑
WHILE 条件 DO
SQL逻辑...
END WHILE;
```
### repeat
#### 定义
repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环
类似编程语言中的do while
#### 语法
```
-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环
REPEAT
    SQL逻辑...
    UNTIL 条件
END REPEAT;
```
### loop
#### 定义
LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环
LOOP可以配合一下两个语句使用：
###### LEAVE
配合循环使用，退出循环
###### ITERATE
必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环
#### 语法
```
[begin_label:] LOOP
SQL逻辑...
END LOOP [end_label];

LEAVE label; -- 退出指定标记的循环体
ITERATE label; -- 直接进入下一次循环
```
上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记


### 游标
#### 定义
游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE
#### 语法
##### 声明游标
```
DECLARE 游标名称 CURSOR FOR 查询语句 ;
```
##### 打开游标
```
OPEN 游标名称 ;
```
##### 获取游标记录
```
FETCH 游标名称 INTO 变量 [, 变量 ] ;
```
##### 关闭游标
```
CLOSE 游标名称 ;
```
### 条件处理程序
#### 定义
条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤
#### 语法
```
DECLARE handler_action HANDLER FOR condition_value [, condition_value]... statement ;
```
##### handler_action 的取值：
###### CONTINUE
继续执行当前程序
###### EXIT
终止执行当前程序
##### condition_value 的取值：
| 状态码类型       | 说明                           |
|:------------------|:-------------------------------|
| `SQLSTATE sqlstate_value` | 状态码，如 02000              |
| `SQLWARNING`      | 所有以01开头的 **SQLSTATE** 代码的简写 |
| `NOT FOUND`       | 所有以02开头的 **SQLSTATE** 代码的简写 |
| `SQLEXCEPTION`    | 所有没有被 **SQLWARNING** 或 **NOT FOUND** 捕获的 **SQLSTATE** 代码的简写 |


### 存储函数
#### 定义
存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的
#### 语法
```
CREATE FUNCTION 存储函数名称 ([ 参数列表 ])
RETURNS type [characteristic ...]
BEGIN
   -- SQL语句
   RETURN ...;
END ;
```

##### characteristic说明

| 特性             | 说明                                 |
|:-----------------|:------------------------------------|
| `DETERMINISTIC`  | 相同的输入参数总是产生相同的结果     |
| `NO SQL`         | 不包含 SQL 语句                     |
| `READS SQL DATA` | 包含读取数据的语句，但不包含写入数据的语句 |


在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定characteristic特性，否则就会报错

存储函数使用的不多，存储函数的功能完全可以用存储过程替代

### 触发器
#### 定义
- 触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作
- 使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发
#### 触发器类型--NEW和OLD
##### INSERT型触发器
NEW表示将要或者已经新增的数据
##### UPDATE型触发器
OLD表示修改之前的数据, NEW表示将要或已经修改后的数据
##### DELETE型触发器
OLD表示将要或者已经删除的数据
#### 语法
##### 创建
```
CREATE TRIGGER trigger_name
BEFORE/AFTER INSERT/UPDATE/DELETE
ON tbl_name FOR EACH ROW -- 行级触发器
BEGIN
    trigger_stmt ;
END;
```
##### 查看
```
SHOW TRIGGERS ;
```
##### 删除
```
DROP TRIGGER [schema_name.]trigger_name ;
-- 如果没有指定 schema_name，默认为当前数据库
```

## 锁
### 概述
锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂
#### 锁的分类
MySQL中的锁，按照锁的粒度分，分为以下三类：
| 锁类型   | 说明                         |
|:---------|:-----------------------------|
| 全局锁   | 锁定数据库中的所有表         |
| 表级锁   | 每次操作锁住整张表           |
| 行级锁   | 每次操作锁住对应的行数据     |


### 全局锁
#### 定义
- 全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞
- 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性

对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性

#### 语法
##### 加全局锁
```
flush tables with read lock ;
```
##### 数据备份
```
mysqldump -uroot –p1234 itcast > itcast.sql
```
##### 释放锁
```
unlock tables ;
```
#### 特点
数据库中加全局锁，是一个比较重的操作，存在以下问题：
- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆
- 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟

在InnoDB引擎中，我们可以在备份时加上参数 
```
--single-transaction 参数来完成不加锁的一致性数据备份

mysqldump --single-transaction -uroot –p123456 itcast > itcast.sql
```

### 表级锁
#### 定义
表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中

#### 分类
对于表级锁，主要分为以下三类：
- 表锁
- 元数据锁（meta data lock，MDL）
- 意向锁

#### 表锁
对于表锁，分为两类：
- 表共享读锁（read lock）
- 表独占写锁（write lock）

##### 语法
###### 加锁
```
lock tables 表名... read/write
```
###### 释放锁
```
unlock tables / 客户端断开连接 
```
##### 特点
读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写

#### 元数据锁
meta data lock , 元数据锁，简写MDL

MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性

这里的元数据，可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的

在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)

常见的SQL操作时，所添加的元数据锁：
| 锁类型操作                          | 锁类型                 | 说明                                      |
|:------------------------------------|:-----------------------|:-----------------------------------------|
| `LOCK TABLES xxx READ/WRITE`        | SHARED_READ_ONLY / SHARED_NO_READ_WRITE | 锁定表的读写权限                          |
| `SELECT` 或 `SELECT ... LOCK IN SHARE MODE` | SHARED_READ            | 允许其他事务读取但不修改数据，兼容 `SHARED_READ` 和 `SHARED_WRITE`，与 `EXCLUSIVE` 互斥 |
| `INSERT`、`UPDATE`、`DELETE` 或 `SELECT ... FOR UPDATE` | SHARED_WRITE           | 允许其他事务读取或写入数据，兼容 `SHARED_READ` 和 `SHARED_WRITE`，与 `EXCLUSIVE` 互斥 |
| `ALTER TABLE ...`                   | EXCLUSIVE              | 锁住整个表，禁止其他事务的读写操作，和其他锁类型互斥 |


可以通过下面的SQL，来查看数据库中的元数据锁的情况：
```
select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks ;
```

#### 意向锁
为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查

##### 分类
###### 意向共享锁(IS)
由语句select ... lock in share mode添加
意向共享锁与表锁共享锁(read)兼容，与表锁排他锁(write)互斥
###### 意向排他锁(IX)
由insert、update、delete、select...for update添加。
意向排他锁与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥

**注意：一旦事务提交了，意向共享锁、意向排他锁，都会自动释放**


### 行级锁
#### 定义
行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中
InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁
#### 分类
行级锁，主要分为三类
- 行锁（Record Lock）
锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持
- 间隙锁（Gap Lock）
锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持
- 临键锁（Next-Key Lock）
行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持

#### 行锁
InnoDB实现了以下两种类型的行锁：
- 共享锁（S）
允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
- 排他锁（X）
允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁

两种行锁的兼容情况：

| 当前锁类型   | 请求锁类型   | 兼容性/冲突情况                    |
|:------------|:------------|:-----------------------------------|
| 共享锁 (S)  | 共享锁 (S)   | 兼容                                |
| 共享锁 (S)  | 排他锁 (X)   | 冲突                                |
| 排他锁 (X)  | 共享锁 (S)   | 冲突                                |
| 排他锁 (X)  | 排他锁 (X)   | 冲突                                |






